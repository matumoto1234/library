{
  "segment-tree.hpp": {
    "prefix": "cppsegment_tree",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  // verify:AOJ_DSL_2_A",
      "  template <typename T, T (*op)(T, T), T (*e)()>",
      "  class SegmentTree {",
      "  private:",
      "    int n;",
      "    vector<T> data;",
      "",
      "    T search(int l, int r) {",
      "      T vl = e(), vr = e();",
      "      l += n, r += n;",
      "      while (l < r) {",
      "        if (l & 1)",
      "          vl = op(vl, data[l++]);",
      "        if (r & 1)",
      "          vr = op(vr, data[--r]);",
      "        l >>= 1, r >>= 1;",
      "      }",
      "      return op(vl, vr);",
      "    }",
      "",
      "  public:",
      "    SegmentTree() {}",
      "    SegmentTree(int _n) {",
      "      assign(_n);",
      "    }",
      "",
      "    void assign(int _n) {",
      "      n = 1;",
      "      while (n < _n) {",
      "        n <<= 1;",
      "      }",
      "      data.assign(2 * n, e());",
      "    }",
      "",
      "    T get(int i) {",
      "      return data[i + n];",
      "    }",
      "",
      "    void set(int i, T key) {",
      "      i += n;",
      "      data[i] = key;",
      "      while (i > 0) {",
      "        i >>= 1;",
      "        data[i] = op(data[i << 1 | 0], data[i << 1 | 1]);",
      "      }",
      "    }",
      "",
      "    // [l, r)",
      "    T prod(int l, int r) {",
      "      return search(l, r);",
      "    }",
      "",
      "    T all_prod() {",
      "      return n != 0 ? data[0] : e();",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of segment_tree",
    "scope": "cpp"
  },
  "dynamic-imos.hpp": {
    "prefix": "cppdynamic_imos",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <tuple>",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  template <typename T>",
      "  struct DynamicImos {",
      "    vector<T> xs, imos;",
      "    vector<tuple<T, T, T>> intervals;",
      "",
      "    DynamicImos() {}",
      "",
      "    // [l, r)",
      "    void add(T l, T r, T v) {",
      "      intervals.emplace_back(l, r, v);",
      "      xs.emplace_back(l);",
      "      xs.emplace_back(r);",
      "    }",
      "",
      "    void build() {",
      "      sort(xs.begin(), xs.end());",
      "      xs.erase(unique(xs.begin(), xs.end()), xs.end());",
      "      imos.assign(xs.size(), 0);",
      "",
      "      for (auto [l, r, v]: intervals) {",
      "        l = lower_bound(xs.begin(), xs.end(), l) - xs.begin();",
      "        r = lower_bound(xs.begin(), xs.end(), r) - xs.begin();",
      "        imos[l] += v;",
      "        imos[r] -= v;",
      "      }",
      "",
      "      for (int i = 1; i < static_cast<int>(imos.size()); i++) {",
      "        imos[i] += imos[i - 1];",
      "      }",
      "    }",
      "",
      "    // vector<[l,r), value>",
      "    vector<pair<pair<T, T>, T>> interval_values() {",
      "      vector<pair<pair<T, T>, T>> res(xs.size() - 1);",
      "      for (int i = 0; i < static_cast<int>(xs.size()) - 1; i++) {",
      "        T l = xs[i];",
      "        T r = xs[i + 1];",
      "        T v = imos[i];",
      "        res[i] = pair(pair(l, r), v);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of dynamic_imos",
    "scope": "cpp"
  },
  "dynamic-connectivity.hpp": {
    "prefix": "cppdynamic_connectivity",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <functional>",
      "#include <iostream>",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  template <typename T>",
      "  class DynamicConnectivity {",
      "    class EulerTourTree {",
      "    public:",
      "      struct node;",
      "      using np = node *;",
      "      using lint = long long;",
      "      struct node {",
      "        np ch[2] = { nullptr, nullptr };",
      "        np p = nullptr;",
      "        int l, r, sz;",
      "        T val = et, sum = et;",
      "        bool exact;",
      "        bool child_exact;",
      "        bool edge_connected = 0;",
      "        bool child_edge_connected = 0;",
      "        node() {}",
      "        node(int l, int r): l(l), r(r), sz(l == r), exact(l < r), child_exact(l < r) {}",
      "        bool is_root() {",
      "          return !p;",
      "        }",
      "      };",
      "      vector<unordered_map<int, np>> ptr;",
      "      np get_node(int l, int r) {",
      "        if (ptr[l].find(r) == ptr[l].end())",
      "          ptr[l][r] = new node(l, r);",
      "        return ptr[l][r];",
      "      }",
      "      np root(np t) {",
      "        if (!t)",
      "          return t;",
      "        while (t->p)",
      "          t = t->p;",
      "        return t;",
      "      }",
      "      bool same(np s, np t) {",
      "        if (s)",
      "          splay(s);",
      "        if (t)",
      "          splay(t);",
      "        return root(s) == root(t);",
      "      }",
      "      np reroot(np t) {",
      "        auto s = split(t);",
      "        return merge(s.second, s.first);",
      "      }",
      "      pair<np, np> split(np s) {",
      "        splay(s);",
      "        np t = s->ch[0];",
      "        if (t)",
      "          t->p = nullptr;",
      "        s->ch[0] = nullptr;",
      "        return { t, update(s) };",
      "      }",
      "      pair<np, np> split2(np s) {",
      "        splay(s);",
      "        np t = s->ch[0];",
      "        np u = s->ch[1];",
      "        if (t)",
      "          t->p = nullptr;",
      "        s->ch[0] = nullptr;",
      "        if (u)",
      "          u->p = nullptr;",
      "        s->ch[1] = nullptr;",
      "        return { t, u };",
      "      }",
      "      tuple<np, np, np> split(np s, np t) {",
      "        auto u = split2(s);",
      "        if (same(u.first, t)) {",
      "          auto r = split2(t);",
      "          return make_tuple(r.first, r.second, u.second);",
      "        } else {",
      "          auto r = split2(t);",
      "          return make_tuple(u.first, r.first, r.second);",
      "        }",
      "      }",
      "      template <typename First, typename... Rest>",
      "      np merge(First s, Rest... t) {",
      "        return merge(s, merge(t...));",
      "      }",
      "      np merge(np s, np t) {",
      "        if (!s)",
      "          return t;",
      "        if (!t)",
      "          return s;",
      "        while (s->ch[1])",
      "          s = s->ch[1];",
      "        splay(s);",
      "        s->ch[1] = t;",
      "        if (t)",
      "          t->p = s;",
      "        return update(s);",
      "      }",
      "      int size(np t) {",
      "        return t ? t->sz : 0;",
      "      }",
      "      np update(np t) {",
      "        t->sum = et;",
      "        if (t->ch[0])",
      "          t->sum = fn(t->sum, t->ch[0]->sum);",
      "        if (t->l == t->r)",
      "          t->sum = fn(t->sum, t->val);",
      "        if (t->ch[1])",
      "          t->sum = fn(t->sum, t->ch[1]->sum);",
      "        t->sz = size(t->ch[0]) + (t->l == t->r) + size(t->ch[1]);",
      "        t->child_edge_connected = (t->ch[0] ? t->ch[0]->child_edge_connected : 0) | (t->edge_connected) | (t->ch[1] ? t->ch[1]->child_edge_connected : 0);",
      "        t->child_exact = (t->ch[0] ? t->ch[0]->child_exact : 0) | (t->exact) | (t->ch[1] ? t->ch[1]->child_exact : 0);",
      "        return t;",
      "      }",
      "      void push(np t) {",
      "        //遅延評価予定",
      "      }",
      "      void rot(np t, bool b) {",
      "        np x = t->p, y = x->p;",
      "        if ((x->ch[1 - b] = t->ch[b]))",
      "          t->ch[b]->p = x;",
      "        t->ch[b] = x, x->p = t;",
      "        update(x);",
      "        update(t);",
      "        if ((t->p = y)) {",
      "          if (y->ch[0] == x)",
      "            y->ch[0] = t;",
      "          if (y->ch[1] == x)",
      "            y->ch[1] = t;",
      "          update(y);",
      "        }",
      "      }",
      "      void splay(np t) {",
      "        push(t);",
      "        while (!t->is_root()) {",
      "          np q = t->p;",
      "          if (q->is_root()) {",
      "            push(q), push(t);",
      "            rot(t, q->ch[0] == t);",
      "          } else {",
      "            np r = q->p;",
      "            push(r), push(q), push(t);",
      "            bool b = r->ch[0] == q;",
      "            if (q->ch[1 - b] == t)",
      "              rot(q, b), rot(t, b);",
      "            else",
      "              rot(t, 1 - b), rot(t, b);",
      "          }",
      "        }",
      "      }",
      "      void debug(np t) {",
      "        if (!t)",
      "          return;",
      "        debug(t->ch[0]);",
      "        cerr << t->l << \"-\" << t->r << \" \";",
      "        debug(t->ch[1]);",
      "      }",
      "",
      "    public:",
      "      EulerTourTree() {}",
      "      EulerTourTree(int sz) {",
      "        ptr.resize(sz);",
      "        for (int i = 0; i < sz; i++)",
      "          ptr[i][i] = new node(i, i);",
      "      }",
      "      int size(int s) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        return t->sz;",
      "      }",
      "      bool same(int s, int t) {",
      "        return same(get_node(s, s), get_node(t, t));",
      "      }",
      "      void set_size(int sz) {",
      "        ptr.resize(sz);",
      "        for (int i = 0; i < sz; i++)",
      "          ptr[i][i] = new node(i, i);",
      "      }",
      "      void update(int s, T x) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        t->val = fn(t->val, x);",
      "        update(t);",
      "      }",
      "      void edge_update(int s, auto g) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        function<void(np)> dfs = [&](np t) {",
      "          assert(t);",
      "          if (t->l < t->r and t->exact) {",
      "            splay(t);",
      "            t->exact = 0;",
      "            update(t);",
      "            g(t->l, t->r);",
      "            return;",
      "          }",
      "          if (t->ch[0] and t->ch[0]->child_exact)",
      "            dfs(t->ch[0]);",
      "          else",
      "            dfs(t->ch[1]);",
      "        };",
      "        while (t and t->child_exact) {",
      "          dfs(t);",
      "          splay(t);",
      "        }",
      "      }",
      "      bool try_reconnect(int s, auto f) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        function<bool(np)> dfs = [&](np t) -> bool {",
      "          assert(t);",
      "          if (t->edge_connected) {",
      "            splay(t);",
      "            return f(t->l);",
      "          }",
      "          if (t->ch[0] and t->ch[0]->child_edge_connected)",
      "            return dfs(t->ch[0]);",
      "          else",
      "            return dfs(t->ch[1]);",
      "        };",
      "        while (t->child_edge_connected) {",
      "          if (dfs(t))",
      "            return 1;",
      "          splay(t);",
      "        }",
      "        return 0;",
      "      }",
      "      void edge_connected_update(int s, bool b) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        t->edge_connected = b;",
      "        update(t);",
      "      }",
      "      bool link(int l, int r) {",
      "        if (same(l, r))",
      "          return 0;",
      "        merge(reroot(get_node(l, l)), get_node(l, r), reroot(get_node(r, r)), get_node(r, l));",
      "        return 1;",
      "      }",
      "      bool cut(int l, int r) {",
      "        if (ptr[l].find(r) == ptr[l].end())",
      "          return 0;",
      "        np s, t, u;",
      "        tie(s, t, u) = split(get_node(l, r), get_node(r, l));",
      "        merge(s, u);",
      "        np p = ptr[l][r];",
      "        np q = ptr[r][l];",
      "        ptr[l].erase(r);",
      "        ptr[r].erase(l);",
      "        delete p;",
      "        delete q;",
      "        return 1;",
      "      }",
      "      T get_sum(int p, int v) {",
      "        cut(p, v);",
      "        np t = get_node(v, v);",
      "        splay(t);",
      "        T res = t->sum;",
      "        link(p, v);",
      "        return res;",
      "      }",
      "      T get_sum(int s) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        return t->sum;",
      "      }",
      "    };",
      "    int dep = 1;",
      "    vector<EulerTourTree> ett;",
      "    vector<vector<unordered_set<int>>> edges;",
      "    int sz;",
      "",
      "  public:",
      "    DynamicConnectivity(int sz): sz(sz) {",
      "      ett.emplace_back(sz);",
      "      edges.emplace_back(sz);",
      "    }",
      "    bool link(int s, int t) {",
      "      if (s == t)",
      "        return 0;",
      "      if (ett[0].link(s, t))",
      "        return 1;",
      "      edges[0][s].insert(t);",
      "      edges[0][t].insert(s);",
      "      if (edges[0][s].size() == 1)",
      "        ett[0].edge_connected_update(s, 1);",
      "      if (edges[0][t].size() == 1)",
      "        ett[0].edge_connected_update(t, 1);",
      "      return 0;",
      "    }",
      "",
      "    bool same(int s, int t) {",
      "      return ett[0].same(s, t);",
      "    }",
      "",
      "    int size(int s) {",
      "      return ett[0].size(s);",
      "    }",
      "",
      "    vector<int> get_vertex(int s) {",
      "      return ett[0].vertex_list(s);",
      "    }",
      "",
      "    void update(int s, T x) {",
      "      ett[0].update(s, x);",
      "    }",
      "",
      "    T get_sum(int s) {",
      "      return ett[0].get_sum(s);",
      "    }",
      "",
      "    bool cut(int s, int t) {",
      "      if (s == t)",
      "        return 0;",
      "      for (int i = 0; i < dep; i++) {",
      "        edges[i][s].erase(t);",
      "        edges[i][t].erase(s);",
      "        if (edges[i][s].size() == 0)",
      "          ett[i].edge_connected_update(s, 0);",
      "        if (edges[i][t].size() == 0)",
      "          ett[i].edge_connected_update(t, 0);",
      "      }",
      "      for (int i = dep - 1; i >= 0; i--) {",
      "        if (ett[i].cut(s, t)) {",
      "          if (dep - 1 == i) {",
      "            dep++;",
      "            ett.emplace_back(sz);",
      "            edges.emplace_back(sz);",
      "          }",
      "          return !try_reconnect(s, t, i);",
      "        }",
      "      }",
      "      return 0;",
      "    }",
      "",
      "    bool try_reconnect(int s, int t, int k) {",
      "      for (int i = 0; i < k; i++) {",
      "        ett[i].cut(s, t);",
      "      }",
      "      for (int i = k; i >= 0; i--) {",
      "        if (ett[i].size(s) > ett[i].size(t))",
      "          swap(s, t);",
      "        auto g = [&](int s, int t) {",
      "          ett[i + 1].link(s, t);",
      "        };",
      "        ett[i].edge_update(s, g);",
      "        auto f = [&](int x) -> bool {",
      "          for (auto itr = edges[i][x].begin(); itr != edges[i][x].end();) {",
      "            auto y = *itr;",
      "            itr = edges[i][x].erase(itr);",
      "            edges[i][y].erase(x);",
      "            if (edges[i][x].size() == 0)",
      "              ett[i].edge_connected_update(x, 0);",
      "            if (edges[i][y].size() == 0)",
      "              ett[i].edge_connected_update(y, 0);",
      "            if (ett[i].same(x, y)) {",
      "              edges[i + 1][x].insert(y);",
      "              edges[i + 1][y].insert(x);",
      "              if (edges[i + 1][x].size() == 1)",
      "                ett[i + 1].edge_connected_update(x, 1);",
      "              if (edges[i + 1][y].size() == 1)",
      "                ett[i + 1].edge_connected_update(y, 1);",
      "            } else {",
      "              for (int j = 0; j <= i; j++) {",
      "                ett[j].link(x, y);",
      "              }",
      "              return 1;",
      "            }",
      "          }",
      "          return 0;",
      "        };",
      "        if (ett[i].try_reconnect(s, f))",
      "          return 1;",
      "      }",
      "      return 0;",
      "    }",
      "    constexpr static T et = T();",
      "    constexpr static T fn(T s, T t) {",
      "      return s + t;",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of dynamic_connectivity",
    "scope": "cpp"
  },
  "range-fenwick-tree.hpp": {
    "prefix": "cpprange_fenwick_tree",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  template <typename T>",
      "  class RangeFenwickTree {",
      "  private:",
      "    int n;",
      "    vector<T> data[2];",
      "",
      "    void init(int n_) {",
      "      n = n_ + 1;",
      "      for (int p = 0; p < 2; p++)",
      "        data[p].assign(n, 0);",
      "    }",
      "",
      "    void internal_add(int p, int i, T x) {",
      "      for (int k = i; k < n; k += k & -k) {",
      "        data[p][k] += x;",
      "      }",
      "    }",
      "",
      "    T internal_sum(int p, int i) {",
      "      T res = 0;",
      "      for (int k = i; k > 0; k -= k & -k) {",
      "        res += data[p][k];",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // [1,r)",
      "    T sum(int r) {",
      "      r--;",
      "      return internal_sum(0, r) + internal_sum(1, r) * r;",
      "    }",
      "",
      "  public:",
      "    RangeFenwickTree(int n_) {",
      "      init(n_);",
      "    }",
      "",
      "    // [l, r)",
      "    void add(int l, int r, T x) {",
      "      internal_add(0, l, -x * (l - 1));",
      "      internal_add(0, r, x * (r - 1));",
      "      internal_add(1, l, x);",
      "      internal_add(1, r, -x);",
      "    }",
      "",
      "    // [l,r)",
      "    T sum(int l, int r) {",
      "      return sum(r) - sum(l);",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of range_fenwick_tree",
    "scope": "cpp"
  },
  "fenwick-tree.hpp": {
    "prefix": "cppfenwick_tree",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  // verify:ARC033_C",
      "  template <typename T>",
      "  class FenwickTree {",
      "  private:",
      "    int n;",
      "    vector<T> dat;",
      "",
      "    // [1,r]",
      "    T sum(int r) {",
      "      T res = 0;",
      "      for (int k = r; k > 0; k -= (k & -k)) {",
      "        res += dat[k];",
      "      }",
      "      return res;",
      "    }",
      "",
      "  public:",
      "    FenwickTree(int n_): n(n_ + 2), dat(n_ + 2, 0) {}",
      "",
      "    // i:0-indexed",
      "    void add(int i, T x) {",
      "      for (int k = ++i; k < n; k += (k & -k)) {",
      "        dat[k] += x;",
      "      }",
      "    }",
      "",
      "    T get(int k) {",
      "      return dat[++k];",
      "    }",
      "",
      "    // [l,r)",
      "    T sum(int l, int r) {",
      "      return sum(r) - sum(l);",
      "    }",
      "",
      "    // min({x | sum(x) >= w})",
      "    int lower_bound(T w) {",
      "      if (w <= 0)",
      "        return 0;",
      "      int x = 0, twopow = 1;",
      "      while (twopow < n) {",
      "        twopow <<= 1;",
      "      }",
      "      for (int sz = twopow; sz > 0; sz >>= 1) {",
      "        if (x + sz < n and dat[x + sz] < w) {",
      "          w -= dat[x + sz];",
      "          x += sz;",
      "        }",
      "      }",
      "      return x;",
      "    }",
      "",
      "    // min({x | sum(x) > w})",
      "    int upper_bound(T w) {",
      "      return lower_bound(w + 1);",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of fenwick_tree",
    "scope": "cpp"
  },
  "base.hpp": {
    "prefix": "cppbase",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}"
    ],
    "description": "Template of base",
    "scope": "cpp"
  },
  "mex-set.hpp": {
    "prefix": "cppmex_set",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <set>",
      "",
      "namespace data_structure_library {",
      "  // verify:hhkb2020_C",
      "  template <typename T = long long>",
      "  struct MexSet {",
      "    set<pair<T, T>> s;",
      "",
      "    T inf() {",
      "      return numeric_limits<T>::max() / 2;",
      "    }",
      "",
      "    MexSet() {",
      "      s.emplace(inf(), inf());",
      "      s.emplace(-inf(), -inf());",
      "    }",
      "",
      "    bool contains(T x) const {",
      "      auto [lower, upper] = *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      return lower <= x and x <= upper;",
      "    }",
      "",
      "    bool insert(T x) {",
      "      if (contains(x))",
      "        return false;",
      "      auto nit = s.lower_bound(pair(x + 1, x + 1));",
      "      auto it = prev(nit);",
      "      auto [l, u] = *it;",
      "      auto [nl, nu] = *nit;",
      "      if (u == x - 1) {",
      "        if (nl == x + 1) {",
      "          s.erase(it);",
      "          s.erase(nit);",
      "          s.emplace(l, nu);",
      "        } else {",
      "          s.erase(it);",
      "          s.emplace(l, x);",
      "        }",
      "      } else {",
      "        if (nl == x + 1) {",
      "          s.erase(nit);",
      "          s.emplace(x, nu);",
      "        } else {",
      "          s.emplace(x, x);",
      "        }",
      "      }",
      "      return true;",
      "    }",
      "",
      "    bool erase(T x) {",
      "      if (!contains(x))",
      "        return false;",
      "      auto it = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      auto [l, u] = *it;",
      "      s.erase(it);",
      "      if (x != l)",
      "        s.emplace(l, x - 1);",
      "      if (x != u)",
      "        s.emplace(x + 1, u);",
      "      return true;",
      "    }",
      "",
      "    T mex(T x = 0) const {",
      "      auto [l, u] = *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      if (l <= x and x <= u) {",
      "        return u + 1;",
      "      } else {",
      "        return x;",
      "      }",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of mex_set",
    "scope": "cpp"
  },
  "cumulative-sum-2d.hpp": {
    "prefix": "cppcumulative_sum_2d",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  template <typename T>",
      "  struct CumulativeSum2D {",
      "    vector<vector<T>> data;",
      "    CumulativeSum2D(int H, int W): data(H + 1, vector<T>(W + 1, 0)) {}",
      "    CumulativeSum2D(const vector<vector<T>> &vs): data(vs) {}",
      "",
      "    void set(int y, int x, T v) {",
      "      data[y + 1][x + 1] = v;",
      "    }",
      "",
      "    void build() {",
      "      for (int i = 1; i < static_cast<int>(data.size()); i++) {",
      "        for (int j = 1; j < static_cast<int>(data[i].size()); j++) {",
      "          data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
      "        }",
      "      }",
      "    }",
      "",
      "    // [ (sy,sx), (gy,gx) )",
      "    T query(int sy, int sx, int gy, int gx) {",
      "      return data[gy][gx] - data[gy][sx] - data[sy][gx] + data[sy][sx];",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of cumulative_sum_2d",
    "scope": "cpp"
  },
  "union-find.hpp": {
    "prefix": "cppunion_find",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  class UnionFind {",
      "    // number of vertices",
      "    int n_;",
      "",
      "    vector<int> sizes_, parents_;",
      "",
      "  public:",
      "    UnionFind(int n): n_(n), sizes_(n, 1), parents_(n) {",
      "      iota(parents_.begin(), parents_.end(), 0);",
      "    }",
      "",
      "    // 根（そのグループの識別番号）",
      "    int root(int x) {",
      "      if (x == parents_[x])",
      "        return x;",
      "      return parents_[x] = root(parents_[x]);",
      "    }",
      "",
      "    int size(int x) {",
      "      return sizes_[root(x)];",
      "    }",
      "",
      "    bool same(int x, int y) {",
      "      return root(x) == root(y);",
      "    }",
      "",
      "    // size(x) < size(y): -1",
      "    // not merged:         0",
      "    // size(x) > size(y): +1",
      "    int merge(int x, int y) {",
      "      x = root(x);",
      "      y = root(y);",
      "      if (x == y)",
      "        return 0;",
      "",
      "      int result = +1;",
      "      if (sizes_[x] < sizes_[y]) {",
      "        swap(x, y);",
      "        result = -1;",
      "      }",
      "",
      "      sizes_[x] += sizes_[y];",
      "      parents_[y] = x;",
      "",
      "      return result;",
      "    }",
      "",
      "    vector<vector<int>> groups() {",
      "      vector<vector<int>> grps(n_);",
      "      for (int i = 0; i < n_; i++) {",
      "        grps[root(i)].emplace_back(i);",
      "      }",
      "      vector<vector<int>> res;",
      "      for (int i = 0; i < n_; i++) {",
      "        if (grps[i].empty())",
      "          continue;",
      "        res.emplace_back(grps[i]);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of union_find",
    "scope": "cpp"
  },
  "fenwick-tree-2d.hpp": {
    "prefix": "cppfenwick_tree_2d",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  // 1-indexed",
      "  template <typename T>",
      "  class FenwickTree2D {",
      "  private:",
      "    int H, W;",
      "    vector<vector<T>> dat;",
      "",
      "    // 1<=i<=y 1<=j<=x",
      "    T internal_sum(int y, int x) {",
      "      T res = 0;",
      "      for (int i = y; i > 0; i -= (i & -i)) {",
      "        for (int j = x; j > 0; j -= (j & -j)) {",
      "          res += dat[i][j];",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "",
      "  public:",
      "    FenwickTree2D() {}",
      "    FenwickTree2D(int H_, int W_) {",
      "      init(H_, W_);",
      "    }",
      "    void init(int H_, int W_) {",
      "      H = H_ + 1;",
      "      W = W_ + 1;",
      "      dat.assign(H, vector<T>(W, 0));",
      "    }",
      "",
      "    // {h,w} += x",
      "    void add(int h, int w, T x) {",
      "      assert(1 <= h and h <= H and 1 <= w and w <= W);",
      "      for (int i = h; i < H; i += (i & -i)) {",
      "        for (int j = w; j < W; j += (j & -j)) {",
      "          dat[i][j] += x;",
      "        }",
      "      }",
      "    }",
      "",
      "    // [{sy,sx}, {gy,gx})",
      "    T sum(int sy, int sx, int gy, int gx) {",
      "      assert(1 <= sy and sy <= H and 1 <= sx and sx <= W and 2 <= gy and gy <= H + 1 and 2 <= gx and gx <= W + 1);",
      "      return internal_sum(gy - 1, gx - 1) - internal_sum(gy - 1, sx - 1) - internal_sum(sy - 1, gx - 1) + internal_sum(sy - 1, sx - 1);",
      "    }",
      "",
      "    T get(int y, int x) {",
      "      return sum(y, x, y + 1, x + 1);",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of fenwick_tree_2d",
    "scope": "cpp"
  },
  "dynamic-segment-tree.hpp": {
    "prefix": "cppdynamic_segment_tree",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <iostream>",
      "#include <string>",
      "",
      "namespace data_structure_library {",
      "  template <typename T, T (*op)(T, T), T (*e)()>",
      "  class DynamicSegmentTree {",
      "  private:",
      "    using ll = long long;",
      "    struct node {",
      "      node *left, *right;",
      "      T v;",
      "",
      "      node(): left(nullptr), right(nullptr), v(e()) {}",
      "    };",
      "",
      "    ll n;",
      "",
      "    T prod(ll a, ll b, node *now, ll l, ll r) {",
      "      if (a <= l and r <= b) {",
      "        return now->v;",
      "      }",
      "      if (r <= a or b <= l) {",
      "        return e();",
      "      }",
      "",
      "      T lv = e(), rv = e();",
      "      if (now->left)",
      "        lv = prod(a, b, now->left, l, (l + r) / 2);",
      "      if (now->right)",
      "        rv = prod(a, b, now->right, (l + r) / 2, r);",
      "      return op(lv, rv);",
      "    }",
      "",
      "    void debug_dfs(node *now, string spaces) {",
      "      if (now->right) {",
      "        debug_dfs(now->right, spaces + \"   \");",
      "      }",
      "      cerr << spaces << now->v << \"\\n\";",
      "      if (now->left) {",
      "        debug_dfs(now->left, spaces + \"   \");",
      "      }",
      "    }",
      "",
      "  public:",
      "    node *root;",
      "    DynamicSegmentTree(ll n_) {",
      "      n = 1;",
      "      while (n < n_) {",
      "        n *= 2;",
      "      }",
      "      root = new node();",
      "    }",
      "",
      "    void add(ll k, T x) {",
      "      node *now = root;",
      "      ll l = 0, r = n;",
      "      now->v = op(now->v, x);",
      "      while (r - l > 1) {",
      "        ll m = (l + r) / 2;",
      "        if (k < m) {",
      "          if (!now->left)",
      "            now->left = new node();",
      "          now = now->left;",
      "          r = m;",
      "        } else {",
      "          if (!now->right)",
      "            now->right = new node();",
      "          now = now->right;",
      "          l = m;",
      "        }",
      "        now->v = op(now->v, x);",
      "      }",
      "    }",
      "",
      "    void debug() {",
      "      debug_dfs(root, \"\");",
      "    }",
      "",
      "    T prod(ll l, ll r) {",
      "      return prod(l, r, root, 0, n);",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of dynamic_segment_tree",
    "scope": "cpp"
  },
  "interval-set.hpp": {
    "prefix": "cppinterval_set",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <set>",
      "",
      "namespace data_structure_library {",
      "  // verify:ABC228_D",
      "  template <typename T = long long>",
      "  struct IntervalSet {",
      "    set<pair<T, T>> s;",
      "",
      "    IntervalSet() {",
      "      s.emplace(-inf(), -inf());",
      "      s.emplace(inf(), inf());",
      "    }",
      "",
      "    T inf() const {",
      "      return numeric_limits<T>::max() / 2;",
      "    }",
      "",
      "    bool empty() const {",
      "      return static_cast<int>(s.size()) == 2;",
      "    }",
      "",
      "    bool contains(T x) const {",
      "      if (empty())",
      "        return false;",
      "      auto [lower, upper] = *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      return lower <= x and x <= upper;",
      "    }",
      "",
      "    // max({ (lower, upper) | lower <= x <= upper })",
      "    pair<T, T> get(T x) const {",
      "      assert(contains(x));",
      "      return *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "    }",
      "",
      "    bool insert(T x) {",
      "      if (contains(x))",
      "        return false;",
      "      auto nit = s.lower_bound(pair(x + 1, x + 1));",
      "      auto it = prev(nit);",
      "      auto [l, u] = *it;",
      "      auto [nl, nu] = *nit;",
      "      if (u == x - 1 and nl == x + 1) {",
      "        s.erase(it);",
      "        s.erase(nit);",
      "        s.emplace(l, nu);",
      "      } else if (u == x - 1 and nl != x + 1) {",
      "        s.erase(it);",
      "        s.emplace(l, x);",
      "      } else if (u != x - 1 and nl == x + 1) {",
      "        s.erase(nit);",
      "        s.emplace(x, nu);",
      "      } else if (u != x - 1 and nl != x + 1) {",
      "        s.emplace(x, x);",
      "      }",
      "      return true;",
      "    }",
      "",
      "    bool insert(T x, T y) {",
      "      if (x > y)",
      "        swap(x, y);",
      "      bool contains_x = contains(x);",
      "      bool contains_y = contains(y);",
      "      if (!contains_x and !contains_y) {",
      "        s.emplace(x, y);",
      "      } else if (!contains_x and contains_y) {",
      "        auto yit = prev(s.lower_bound(pair(y + 1, y + 1)));",
      "        auto [yl, yu] = *yit;",
      "        s.erase(yit);",
      "        s.emplace(x, yu);",
      "      } else if (contains_x and !contains_y) {",
      "        auto xit = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "        auto [xl, xu] = *xit;",
      "        s.erase(xit);",
      "        s.emplace(xl, y);",
      "      } else {",
      "        auto xit = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "        auto yit = prev(s.lower_bound(pair(y + 1, y + 1)));",
      "        if (xit == yit)",
      "          return false;",
      "        auto [xl, xu] = *xit;",
      "        auto [yl, yu] = *yit;",
      "        s.erase(xit);",
      "        s.erase(yit);",
      "        s.emplace(xl, yu);",
      "      }",
      "      return true;",
      "    }",
      "",
      "    bool insert(pair<T, T> p) {",
      "      return insert(p.first, p.second);",
      "    }",
      "",
      "    // { (l, u) | l <= x <= u } => { (l, x - 1), (x + 1, u) | l <= x <= u }",
      "    bool erase(T x) {",
      "      assert(x != -inf() and x != inf());",
      "      if (!contains(x))",
      "        return false;",
      "      auto it = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      auto [l, u] = *it;",
      "      s.erase(it);",
      "      if (x != l)",
      "        s.emplace(l, x - 1);",
      "      if (x != u)",
      "        s.emplace(x + 1, u);",
      "      return true;",
      "    }",
      "",
      "    // { (l, u) | l <= x <= u } => { (l, x), (x, u) | l <= x <= u }",
      "    bool cut(T x) {",
      "      assert(x != -inf() and x != inf());",
      "      if (!contains(x))",
      "        return false;",
      "      auto it = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      auto [l, u] = *it;",
      "      s.erase(it);",
      "      s.emplace(l, x);",
      "      s.emplace(x, u);",
      "      return true;",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of interval_set",
    "scope": "cpp"
  },
  "weighted-union-find.hpp": {
    "prefix": "cppweighted_union_find",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  template <typename T>",
      "  struct WeightedUnionFind {",
      "    vector<int> par;",
      "    vector<int> siz;",
      "    vector<T> w;",
      "    WeightedUnionFind(int N): par(N), siz(N, 1), w(N, 0) {",
      "      iota(par.begin(), par.end(), 0);",
      "    }",
      "",
      "    int size(int x) {",
      "      return siz[x];",
      "    }",
      "",
      "    T diff(int x, int y) {",
      "      return weight(y) - weight(x);",
      "    }",
      "",
      "    bool issame(int x, int y) {",
      "      return root(x) == root(y);",
      "    }",
      "",
      "    void unite(int x, int y, T z) {",
      "      z += weight(x);",
      "      z -= weight(y);",
      "      x = root(x);",
      "      y = root(y);",
      "      if (x == y)",
      "        return;",
      "      if (x < y) {",
      "        swap(x, y);",
      "        z = -z;",
      "      }",
      "      siz[x] += siz[y];",
      "      par[y] = x;",
      "      w[y] = z;",
      "    }",
      "",
      "    int root(int x) {",
      "      if (x == par[x])",
      "        return x;",
      "      int rx = root(par[x]);",
      "      w[x] += w[par[x]];",
      "      par[x] = rx;",
      "      return rx;",
      "    }",
      "",
      "    T weight(int x) {",
      "      root(x);",
      "      return w[x];",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of weighted_union_find",
    "scope": "cpp"
  },
  "cumulative-sum.hpp": {
    "prefix": "cppcumulative_sum",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  template <typename T>",
      "  struct CumulativeSum {",
      "    vector<T> data;",
      "    CumulativeSum(int n): data(n + 1, 0) {}",
      "    CumulativeSum(int n, T x): data(n + 1, x) {}",
      "",
      "    void set(int k, T x) {",
      "      data[k + 1] = x;",
      "    }",
      "",
      "    void add(int k, T x) {",
      "      data[k + 1] = x;",
      "    }",
      "",
      "    T get(int k) {",
      "      return data[k + 1];",
      "    }",
      "",
      "    void build() {",
      "      for (int i = 0; i < static_cast<int>(data.size()) - 1; i++) {",
      "        data[i + 1] += data[i];",
      "      }",
      "    }",
      "",
      "    // [l,r)",
      "    T query(int l, int r) {",
      "      return data[r] - data[l];",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of cumulative_sum",
    "scope": "cpp"
  },
  "splay-tree.hpp": {
    "prefix": "cppsplay_tree",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  template <typename T, T (*op)(T, T) = nullptr>",
      "  struct SplayTree {",
      "    struct node {",
      "      node *left, *right, *parent;",
      "      int size;",
      "      T calc_value, value;",
      "",
      "      node(): left(nullptr), right(nullptr), parent(nullptr), size(1) {}",
      "",
      "      // 回転",
      "      void rotate() {",
      "        node *pp, *p, *c;",
      "        p = this->parent;",
      "        pp = p->parent;",
      "",
      "        if (p->left == this) {",
      "          c = this->right;",
      "          this->right = p;",
      "          p->left = c;",
      "        } else {",
      "          c = this->left;",
      "          this->left = p;",
      "          p->right = c;",
      "        }",
      "",
      "        if (pp and pp->left == p)",
      "          pp->left = this;",
      "        if (pp and pp->right == p)",
      "          pp->right = this;",
      "        this->parent = pp;",
      "        p->parent = this;",
      "        if (c)",
      "          c->parent = p;",
      "",
      "        p->update();",
      "        this->update();",
      "      }",
      "",
      "      // 根:0, 左:1, 右:-1",
      "      int state() {",
      "        if (!this->parent)",
      "          return 0;",
      "        if (this->parent->left == this)",
      "          return 1;",
      "        if (this->parent->right == this)",
      "          return -1;",
      "        return 0;",
      "      }",
      "",
      "      // 根になるまで回転",
      "      void splay() {",
      "        while (this->state() != 0) {",
      "          // 親が根",
      "          if (this->parent->state() == 0) {",
      "            this->rotate();",
      "          } else if (this->state() == this->parent->state()) {",
      "            this->parent->rotate();",
      "            this->rotate();",
      "          } else {",
      "            this->rotate();",
      "            this->rotate();",
      "          }",
      "        }",
      "      }",
      "",
      "      // 左右の子に対して操作",
      "      void update() {",
      "        this->size = 1;",
      "        this->calc_value = value;",
      "        if (this->left) {",
      "          this->size += left->size;",
      "          if (op)",
      "            this->calc_value = op(this->calc_value, this->left->calc_value);",
      "        }",
      "        if (this->right) {",
      "          this->size += right->size;",
      "          if (op)",
      "            this->calc_value = op(this->calc_value, this->right->calc_value);",
      "        }",
      "      }",
      "    };",
      "",
      "    node *_root;",
      "    vector<node> nodes;",
      "    SplayTree(int n): nodes(n) {",
      "      for (int i = 0; i < n - 1; i++) {",
      "        nodes[i].parent = &nodes[i + 1];",
      "        nodes[i + 1].left = &nodes[i];",
      "        nodes[i + 1].update();",
      "      }",
      "      _root = &nodes[n - 1];",
      "    }",
      "",
      "    T &operator[](int idx) {",
      "      get(idx, _root);",
      "      _root->update();",
      "      return _root->value;",
      "    }",
      "",
      "    node *&root() {",
      "      return _root;",
      "    }",
      "",
      "    // rootの左からのidx番目の頂点を根にして返す",
      "    node *get(int idx, node *root) {",
      "      node *now = root;",
      "      while (true) {",
      "        int lsize = now->left ? now->left->size : 0;",
      "        if (idx < lsize)",
      "          now = now->left;",
      "        if (idx == lsize) {",
      "          now->splay();",
      "          break;",
      "        }",
      "        if (idx > lsize) {",
      "          now = now->right;",
      "          idx = idx - lsize - 1;",
      "        }",
      "      }",
      "      _root = now;",
      "      return now;",
      "    }",
      "",
      "    // lrootとrrootをマージ",
      "    node *merge(node *lroot, node *rroot) {",
      "      if (!lroot)",
      "        return rroot;",
      "      if (!rroot)",
      "        return lroot;",
      "      lroot = get(lroot->size - 1, lroot);",
      "      lroot->right = rroot;",
      "      rroot->parent = lroot;",
      "      lroot->update();",
      "      return lroot;",
      "    }",
      "",
      "    // [0,n) -> [0,idx),[idx,n)",
      "    pair<node *, node *> split(int idx, node *root) {",
      "      if (idx == 0)",
      "        return { nullptr, root };",
      "      if (idx == root->size)",
      "        return { root, nullptr };",
      "",
      "      root = get(idx, root);",
      "      node *lroot, *rroot;",
      "      lroot = root->left;",
      "      rroot = root;",
      "      rroot->left = nullptr;",
      "      lroot->parent = nullptr;",
      "      rroot->update();",
      "      return { lroot, rroot };",
      "    }",
      "",
      "    node *insert(int idx, node *tmp, node *root) {",
      "      auto trees = split(idx, root);",
      "      node *lroot = trees.first;",
      "      node *rroot = trees.second;",
      "      return merge(merge(lroot, tmp), rroot);",
      "    }",
      "",
      "    pair<node *, node *> erase(int idx, node *root) {",
      "      root = get(idx, root);",
      "      node *lroot = root->left;",
      "      node *rroot = root->right;",
      "      if (lroot)",
      "        lroot->parent = nullptr;",
      "      if (rroot)",
      "        rroot->parent = nullptr;",
      "      root->left = nullptr;",
      "      root->right = nullptr;",
      "      root->update();",
      "      return { merge(lroot, rroot), root };",
      "    }",
      "",
      "    node *shift(int l, int r, node *root) {",
      "      auto temp = erase(r, root);",
      "      root = temp.first;",
      "      node *node = temp.second;",
      "      return insert(l, node, root);",
      "    }",
      "",
      "    pair<node *, int> prod(int l, int r, node *root) {",
      "      node *lroot, *croot, *rroot;",
      "      auto temp = split(r + 1, root);",
      "      rroot = temp.second;",
      "      temp = split(l, temp.first);",
      "      lroot = temp.first;",
      "      croot = temp.second;",
      "      int ans = croot->calc_value;",
      "      return { merge(merge(lroot, croot), rroot), ans };",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of splay_tree",
    "scope": "cpp"
  },
  "interval-scheduling.hpp": {
    "prefix": "cppinterval_scheduling",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  // verify:https://atcoder.jp/contests/keyence2020/tasks/keyence2020_b",
      "  template <typename T>",
      "  class IntervalScheduling {",
      "    vector<pair<T, T>> intervals_;",
      "    vector<bool> used;",
      "",
      "  public:",
      "    IntervalScheduling() {}",
      "",
      "    void add_interval(T l, T r) {",
      "      intervals_.emplace_back(l, r);",
      "    }",
      "",
      "    int inf() {",
      "      return numeric_limits<int>::max() / 2;",
      "    }",
      "",
      "    void build() {",
      "      used.assign(intervals_.size(), false);",
      "",
      "      sort(intervals_.begin(), intervals_.end(), [](pair<T, T> a, pair<T, T> b) {",
      "        if (a.second != b.second)",
      "          return a.second < b.second;",
      "        return a.first < b.first;",
      "      });",
      "",
      "      int last = -inf();",
      "      for (size_t i = 0; i < intervals_.size(); i++) {",
      "        auto [l, r] = intervals_[i];",
      "",
      "        if (last <= l) {",
      "          used[i] = true;",
      "          last = r;",
      "        }",
      "      }",
      "    }",
      "",
      "    bool is_used(int k) {",
      "      return used[k];",
      "    }",
      "",
      "    vector<pair<T, T>> intervals() {",
      "      vector<pair<T, T>> res;",
      "      for (size_t i = 0; i < intervals_.size(); i++) {",
      "        if (!used[i])",
      "          continue;",
      "        res.emplace_back(intervals_[i]);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of interval_scheduling",
    "scope": "cpp"
  },
  "union-find-undo.hpp": {
    "prefix": "cppunion_find_undo",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <numeric>",
      "#include <stack>",
      "#include <tuple>",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  // 経路圧縮なし",
      "  class UnionFindUndo {",
      "  private:",
      "    // number of vertices",
      "    int n_;",
      "",
      "    vector<int> sizes_, parents_;",
      "",
      "    // <index, parent(index), size(index)>",
      "    stack<tuple<int, int, int>> history_;",
      "",
      "  public:",
      "    UnionFindUndo(int N): sizes_(N, 1), parents_(N) {",
      "      iota(parents_.begin(), parents_.end(), 0);",
      "    }",
      "",
      "    // 根（そのグループの識別番号）",
      "    int root(int x) {",
      "      if (x == parents_[x])",
      "        return x;",
      "      return root(parents_[x]);",
      "    }",
      "",
      "    int size(int x) {",
      "      return sizes_[root(x)];",
      "    }",
      "",
      "    bool same(int x, int y) {",
      "      return root(x) == root(y);",
      "    }",
      "",
      "    // size(x) < size(y): -1",
      "    // not merged:         0",
      "    // size(x) > size(y): +1",
      "    int merge(int x, int y) {",
      "      x = root(x);",
      "      y = root(y);",
      "      if (x == y)",
      "        return 0;",
      "",
      "      int result = +1;",
      "      if (sizes_[x] < sizes_[y]) {",
      "        swap(x, y);",
      "        result = -1;",
      "      }",
      "",
      "      history_.emplace(tuple(x, parents_[x], sizes_[x]));",
      "      history_.emplace(tuple(y, parents_[y], sizes_[y]));",
      "      sizes_[x] += sizes_[y];",
      "      parents_[y] = x;",
      "      return result;",
      "    }",
      "",
      "    bool undo() {",
      "      if (history_.empty())",
      "        return false;",
      "",
      "      auto [x, x_parent, x_size] = history_.top();",
      "      history_.pop();",
      "      auto [y, y_parent, y_size] = history_.top();",
      "      history_.pop();",
      "",
      "      parents_[x] = x_parent;",
      "      sizes_[x] = x_size;",
      "      parents_[y] = y_parent;",
      "      sizes_[y] = y_size;",
      "      return true;",
      "    }",
      "",
      "    void clear_history() {",
      "      while (not history_.empty()) {",
      "        history_.pop();",
      "      }",
      "    }",
      "",
      "    void all_undo() {",
      "      while (undo()) {}",
      "    }",
      "",
      "    // Θ(N log(N))",
      "    vector<vector<int>> groups() {",
      "      vector<vector<int>> grps(n_);",
      "      for (int i = 0; i < n_; i++) {",
      "        grps[root(i)].emplace_back(i);",
      "      }",
      "",
      "      vector<vector<int>> res;",
      "      for (int i = 0; i < n_; i++) {",
      "        if (grps[i].empty())",
      "          continue;",
      "        res.emplace_back(grps[i]);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure_library"
    ],
    "description": "Template of union_find_undo",
    "scope": "cpp"
  },
  "re-rooting-dp.hpp": {
    "prefix": "cppre_rooting_dp",
    "body": [
      "namespace dp_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <cassert>",
      "#include <stack>",
      "#include <vector>",
      "",
      "namespace dp_library {",
      "  // TODO verify:EDPC-V, ABC220-F, ABC160-F",
      "  // add_node: 自身の値を追加して親方向へ渡す関数 (T result, int index) |-> T",
      "  // op: 二項演算 (monoid)",
      "  // e: opに関する単位元",
      "  template <typename T, T (*add_node)(T, int), T (*op)(T, T), T (*e)()>",
      "  class ReRootingDP {",
      "    // order と parents の前計算",
      "    void dfs(int root) {",
      "      int index = 0;",
      "      stack<int> s;",
      "      s.push(root);",
      "      m_parents[root] = -1;",
      "",
      "      while (not s.empty()) {",
      "        int node = s.top();",
      "        s.pop();",
      "",
      "        m_order[index++] = node;",
      "        for (auto [adjacent, ignore]: m_tree[node]) {",
      "          if (adjacent == m_parents[node])",
      "            continue;",
      "          s.push(adjacent);",
      "          m_parents[adjacent] = node;",
      "        }",
      "      }",
      "    }",
      "",
      "    // 根の値を求めるために全頂点の子方向の値を帰りがけ順で求める",
      "    // child_subtree_results[node][i] (頂点nodeのi番目の子部分木の値) が求まる",
      "    // ただし、子方向を親としたときの child_subtree_results[node][i] は求まらない",
      "    void post_order(int root) {",
      "      vector<int> reversed_order = m_order;",
      "      reverse(reversed_order.begin(), reversed_order.end());",
      "",
      "      for (int node: reversed_order) {",
      "        if (node == root)",
      "          continue;",
      "",
      "        int parent = m_parents[node];",
      "        int parent_index = -1;",
      "        T result = e();",
      "",
      "        for (int i = 0; i < (int)m_tree[node].size(); i++) {",
      "          int to = m_tree[node][i].first;",
      "          if (to == parent) {",
      "            parent_index = i;",
      "            continue;",
      "          }",
      "",
      "          result = op(result, m_child_subtree_results[node][i]);",
      "        }",
      "",
      "        assert(parent_index != -1);",
      "        m_child_subtree_results[parent][m_index_for_adjacents[node][parent_index]] = add_node(result, node);",
      "      }",
      "    }",
      "",
      "    // 全頂点の親方向の値を両側累積を使って求める(行きがけ順)",
      "    // node_results[node] が求まる",
      "    void pre_order() {",
      "      for (int node: m_order) {",
      "        int size = m_tree[node].size();",
      "",
      "        if (size == 0)",
      "          continue;",
      "",
      "        vector<T> accums_front(size + 1, e()), accums_back(size, e());",
      "",
      "        for (int i = 0; i < size; i++) {",
      "          T child_subtree_result = m_child_subtree_results[node][i];",
      "          accums_front[i + 1] = op(accums_front[i], child_subtree_result);",
      "        }",
      "        for (int i = size - 1; i >= 1; i--) {",
      "          T child_subtree_result = m_child_subtree_results[node][i];",
      "          accums_back[i - 1] = op(accums_back[i], child_subtree_result);",
      "        }",
      "",
      "        for (int i = 0; i < size; i++) {",
      "          T result = add_node(op(accums_front[i], accums_back[i]), node);",
      "",
      "          int parent = m_tree[node][i].first;",
      "          int index_from_parent = m_index_for_adjacents[node][i];",
      "",
      "          m_child_subtree_results[parent][index_from_parent] = result;",
      "        }",
      "        T accum_child_subtree_result = accums_front.back();",
      "        m_node_results[node] = add_node(accum_child_subtree_result, node);",
      "      }",
      "    }",
      "",
      "  public:",
      "    using Edge = pair<int, T>;",
      "    vector<vector<Edge>> m_tree;",
      "    vector<vector<int>> m_index_for_adjacents;",
      "    vector<vector<T>> m_child_subtree_results;",
      "    vector<int> m_parents, m_order;",
      "    vector<T> m_node_results;",
      "",
      "    ReRootingDP(int n): m_tree(n), m_index_for_adjacents(n), m_parents(n), m_order(n), m_node_results(n, e()) {}",
      "",
      "    // Directed edge",
      "    void add_edge(int from, int to, T cost) {",
      "      m_tree[from].emplace_back(to, cost);",
      "      m_index_for_adjacents[to].emplace_back(m_tree[from].size() - 1);",
      "    }",
      "",
      "    void build() {",
      "      int size = m_tree.size();",
      "      assert(size != 0);",
      "      m_child_subtree_results.resize(size);",
      "      for (int i = 0; i < size; i++) {",
      "        m_child_subtree_results[i].assign(m_tree[i].size(), e());",
      "      }",
      "",
      "      dfs(/* root = */ 0);",
      "      post_order(/* root = */ 0);",
      "      pre_order();",
      "    }",
      "",
      "    T operator[](int node) {",
      "      return m_node_results[node];",
      "    }",
      "  };",
      "} // namespace dp_library"
    ],
    "description": "Template of re_rooting_dp",
    "scope": "cpp"
  },
  "longest-common-subsequence.hpp": {
    "prefix": "cpplongest_common_subsequence",
    "body": [
      "namespace dp_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace dp_library {",
      "  // verify:EDPC_F",
      "  template <typename T>",
      "  struct LongestCommonSubsequence {",
      "    vector<T> s, t;",
      "    int h, w;",
      "    vector<vector<int>> dp;",
      "    LongestCommonSubsequence(vector<T> _s, vector<T> _t): s(_s), t(_t) {",
      "      h = _s.size();",
      "      w = _t.size();",
      "    }",
      "    LongestCommonSubsequence(string _s, string _t) {",
      "      h = _s.size(), w = _t.size();",
      "      for (int i = 0; i < h; i++)",
      "        s.emplace_back(_s[i]);",
      "      for (int i = 0; i < w; i++)",
      "        t.emplace_back(_t[i]);",
      "    }",
      "",
      "    int build() {",
      "      dp.assign(h + 1, vector<int>(w + 1, 0));",
      "      for (int i = 0; i < h; i++) {",
      "        for (int j = 0; j < w; j++) {",
      "          if (s[i] == t[j]) {",
      "            dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 1);",
      "            continue;",
      "          }",
      "          dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);",
      "          dp[i][j + 1] = max(dp[i][j + 1], dp[i][j]);",
      "        }",
      "      }",
      "      return dp[h][w];",
      "    }",
      "",
      "    vector<T> restore() {",
      "      vector<T> res;",
      "      int i = h, j = w;",
      "      while (i > 0 and j > 0) {",
      "        if (s[i - 1] == t[j - 1]) {",
      "          res.emplace_back(s[i - 1]);",
      "          i--;",
      "          j--;",
      "          continue;",
      "        }",
      "        if (dp[i - 1][j] > dp[i][j - 1])",
      "          i--;",
      "        else",
      "          j--;",
      "      }",
      "      reverse(res.begin(), res.end());",
      "      return res;",
      "    }",
      "  };",
      "} // namespace dp_library"
    ],
    "description": "Template of longest_common_subsequence",
    "scope": "cpp"
  },
  "product.hpp": {
    "prefix": "cppproduct",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry_library {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS)",
      "      return -1;",
      "    if (a > +EPS)",
      "      return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) {",
      "    return sign(a - b) == 0;",
      "  }",
      "} // namespace geometry_library",
      "",
      "",
      "#include <complex>",
      "",
      "namespace geometry_library {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) {",
      "    return Point(p.real() * k, p.imag() * k);",
      "  }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) {",
      "    return equals(a.real(), b.real()) and equals(a.imag(), b.imag());",
      "  }",
      "} // namespace geometry_library",
      "",
      "namespace geometry_library {",
      "  Real cross(const Point &a, const Point &b) {",
      "    return a.real() * b.imag() - a.imag() * b.real();",
      "  }",
      "",
      "  Real dot(const Point &a, const Point &b) {",
      "    return a.real() * b.real() + a.imag() * b.imag();",
      "  }",
      "} // namespace geometry_library"
    ],
    "description": "Template of product",
    "scope": "cpp"
  },
  "projection.hpp": {
    "prefix": "cppprojection",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry_library {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS)",
      "      return -1;",
      "    if (a > +EPS)",
      "      return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) {",
      "    return sign(a - b) == 0;",
      "  }",
      "} // namespace geometry_library",
      "",
      "",
      "",
      "#include <complex>",
      "",
      "namespace geometry_library {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) {",
      "    return Point(p.real() * k, p.imag() * k);",
      "  }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) {",
      "    return equals(a.real(), b.real()) and equals(a.imag(), b.imag());",
      "  }",
      "} // namespace geometry_library",
      "",
      "namespace geometry_library {",
      "  struct Line {",
      "    Point a, b;",
      "",
      "    Line() = default;",
      "    Line(const Point &a, const Point &b): a(a), b(b) {}",
      "  };",
      "} // namespace geometry_library",
      "",
      "",
      "namespace geometry_library {",
      "  Real cross(const Point &a, const Point &b) {",
      "    return a.real() * b.imag() - a.imag() * b.real();",
      "  }",
      "",
      "  Real dot(const Point &a, const Point &b) {",
      "    return a.real() * b.real() + a.imag() * b.imag();",
      "  }",
      "} // namespace geometry_library",
      "",
      "namespace geometry_library {",
      "  Point projection(const Line &l, const Point &p) {",
      "    // Real",
      "  }",
      "} // namespace geometry_library"
    ],
    "description": "Template of projection",
    "scope": "cpp"
  },
  "point.hpp": {
    "prefix": "cpppoint",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry_library {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS)",
      "      return -1;",
      "    if (a > +EPS)",
      "      return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) {",
      "    return sign(a - b) == 0;",
      "  }",
      "} // namespace geometry_library",
      "",
      "#include <complex>",
      "",
      "namespace geometry_library {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) {",
      "    return Point(p.real() * k, p.imag() * k);",
      "  }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) {",
      "    return equals(a.real(), b.real()) and equals(a.imag(), b.imag());",
      "  }",
      "} // namespace geometry_library"
    ],
    "description": "Template of point",
    "scope": "cpp"
  },
  "line.hpp": {
    "prefix": "cppline",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry_library {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS)",
      "      return -1;",
      "    if (a > +EPS)",
      "      return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) {",
      "    return sign(a - b) == 0;",
      "  }",
      "} // namespace geometry_library",
      "",
      "#include <complex>",
      "",
      "namespace geometry_library {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) {",
      "    return Point(p.real() * k, p.imag() * k);",
      "  }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) {",
      "    return equals(a.real(), b.real()) and equals(a.imag(), b.imag());",
      "  }",
      "} // namespace geometry_library",
      "",
      "namespace geometry_library {",
      "  struct Line {",
      "    Point a, b;",
      "",
      "    Line() = default;",
      "    Line(const Point &a, const Point &b): a(a), b(b) {}",
      "  };",
      "} // namespace geometry_library"
    ],
    "description": "Template of line",
    "scope": "cpp"
  },
  "bellman-ford.hpp": {
    "prefix": "cppbellman_ford",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <algorithm>",
      "",
      "namespace graph_library {",
      "  template <typename Cost>",
      "  class BellmanFord {",
      "    WeightedGraph<Cost> graph_;",
      "    WeightedEdges<Cost> edges_;",
      "    vector<Cost> distances_;",
      "    vector<int> befores_;",
      "    int start_, goal_;",
      "    bool has_neg_cycle_, has_neg_cycle_to_goal_;",
      "",
      "  public:",
      "    BellmanFord(const WeightedGraph<Cost> &graph, int start, int goal = -1): graph_(graph), start_(start), goal_(goal), has_neg_cycle_(false), has_neg_cycle_to_goal_(false) {",
      "      int n = graph_.size();",
      "",
      "      if (goal_ == -1)",
      "        goal_ = n - 1;",
      "",
      "      edges_ = graph_.edges();",
      "",
      "      distances_.assign(n, inf());",
      "      befores_.assign(n, -1);",
      "",
      "      distances_.at(start) = 0;",
      "",
      "      for (int i = 0; i < 2 * n; i++) {",
      "        for (auto edge: edges_) {",
      "          int from = edge.from();",
      "          int to = edge.to();",
      "          Cost cost = edge.cost();",
      "",
      "          if (distances_.at(from) >= inf())",
      "            continue;",
      "",
      "          if (distances_.at(to) <= distances_.at(from) + cost)",
      "            continue;",
      "",
      "          distances_.at(to) = distances_.at(from) + cost;",
      "          befores_.at(from) = to;",
      "",
      "          if (i >= n - 1) {",
      "            distances_.at(to) = -inf();",
      "            has_neg_cycle_ = true;",
      "",
      "            if (to == goal_) {",
      "              has_neg_cycle_to_goal_ = true;",
      "              return;",
      "            }",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    static constexpr Cost inf() {",
      "      return numeric_limits<Cost>::max() / 2;",
      "    }",
      "",
      "    bool has_negative_cycle() const {",
      "      return has_neg_cycle_;",
      "    }",
      "",
      "    bool has_negative_cycle_to_goal_() const {",
      "      return has_neg_cycle_to_goal_;",
      "    }",
      "",
      "    Cost operator[](int k) {",
      "      return distances_.at(k);",
      "    }",
      "",
      "    vector<int> restore(int to) {",
      "      vector<int> path;",
      "      if (befores_.at(to) == -1) {",
      "        path.emplace_back(to);",
      "        return path;",
      "      }",
      "",
      "      while (befores_.at(to) != -1) {",
      "        path.emplace_back(to);",
      "        to = befores_.at(to);",
      "      }",
      "      reverse(path.begin(), path.end());",
      "      return path;",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of bellman_ford",
    "scope": "cpp"
  },
  "dijkstra.hpp": {
    "prefix": "cppdijkstra",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <algorithm>",
      "#include <limits>",
      "#include <queue>",
      "",
      "",
      "namespace graph_library {",
      "  template <typename Cost>",
      "  struct Dijkstra {",
      "    using Edge = WeightedEdge<Cost>;",
      "    vector<Cost> ds;",
      "    vector<int> bs;",
      "",
      "    static constexpr Cost inf() {",
      "      return numeric_limits<Cost>::max() / 2;",
      "    }",
      "",
      "    Dijkstra(WeightedGraph<Cost> g, int start): ds(g.size(), inf()), bs(g.size(), -1) {",
      "      assert(0 <= start and start < g.size());",
      "      auto G = g.graph();",
      "      priority_queue<Edge, vector<Edge>, greater<Edge>> Q;",
      "      ds[start] = 0;",
      "      Q.emplace(start, ds[start]);",
      "",
      "      while (!Q.empty()) {",
      "        Edge p = Q.top();",
      "        int v = p.to();",
      "        Q.pop();",
      "",
      "        if (ds[v] < p.cost())",
      "          continue;",
      "",
      "        for (Edge e: G[v]) {",
      "          int to = e.to();",
      "          Cost cost = e.cost();",
      "          if (ds[to] > ds[v] + cost) {",
      "            ds[to] = ds[v] + cost;",
      "            bs[to] = v;",
      "            Q.emplace(to, ds[to]);",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    Cost operator[](int k) {",
      "      return ds.at(k);",
      "    }",
      "",
      "    vector<int> restore(int to) {",
      "      vector<int> res;",
      "      if (bs[to] == -1) {",
      "        res.emplace_back(to);",
      "        return res;",
      "      }",
      "      while (to != -1) {",
      "        res.emplace_back(to);",
      "        to = bs[to];",
      "      }",
      "      reverse(res.begin(), res.end());",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of dijkstra",
    "scope": "cpp"
  },
  "reverse-edges.hpp": {
    "prefix": "cppreverse_edges",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "namespace graph_library {",
      "  // want to use concept",
      "",
      "  template <class Graph>",
      "  Graph reverse_edges(const Graph &g) {",
      "    const auto &edges = g.edges();",
      "    Graph rg(g.size());",
      "",
      "    for (auto edge: edges) {",
      "      swap(edge.from(), edge.to());",
      "      rg.add_edge(edge);",
      "    }",
      "",
      "    return rg;",
      "  }",
      "} // namespace graph_library"
    ],
    "description": "Template of reverse_edges",
    "scope": "cpp"
  },
  "convert-graph.hpp": {
    "prefix": "cppconvert_graph",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <string>",
      "",
      "namespace graph_library {",
      "  // grid graph -> UnWeightedGraph",
      "  UnWeightedGraph convert_graph(const vector<string> &s, const string &wall = \"#\") {",
      "    int h = s.size(), w = s[0].size();",
      "    constexpr int dy[] = { 1, 0, -1, 0 }, dx[] = { 0, 1, 0, -1 };",
      "    UnWeightedGraph graph(h * w);",
      "",
      "    for (int i = 0; i < h; i++) {",
      "      for (int j = 0; j < w; j++) {",
      "        int from = i * w + j;",
      "",
      "        for (int k = 0; k < 4; k++) {",
      "          int ny = i + dy[k], nx = j + dx[k];",
      "",
      "          if (ny < 0 or nx < 0 or ny >= h or nx >= w)",
      "            continue;",
      "",
      "          if (wall.find(s[ny][nx]) != string::npos)",
      "            continue;",
      "",
      "          int to = ny * w + nx;",
      "          graph.add_edge(UnWeightedEdge(from, to));",
      "        }",
      "      }",
      "    }",
      "    return graph;",
      "  }",
      "} // namespace graph_library"
    ],
    "description": "Template of convert_graph",
    "scope": "cpp"
  },
  "strongly-connected-component.hpp": {
    "prefix": "cppstrongly_connected_component",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "",
      "namespace graph_library {",
      "  // want to use concept",
      "",
      "  template <class Graph>",
      "  Graph reverse_edges(const Graph &g) {",
      "    const auto &edges = g.edges();",
      "    Graph rg(g.size());",
      "",
      "    for (auto edge: edges) {",
      "      swap(edge.from(), edge.to());",
      "      rg.add_edge(edge);",
      "    }",
      "",
      "    return rg;",
      "  }",
      "} // namespace graph_library",
      "",
      "namespace graph_library {",
      "  template <typename Graph>",
      "  class StronglyConnectedComponent {",
      "    Graph scc_graph_;",
      "    vector<vector<int>> scc_;",
      "    vector<bool> used_;",
      "    vector<int> post_order_, group_;",
      "",
      "  public:",
      "    StronglyConnectedComponent(const Graph &graph) {",
      "      int n = graph.size();",
      "",
      "      // get post order",
      "      used_.assign(n, false);",
      "      auto adj_list = graph.graph();",
      "",
      "      for (int i = 0; i < n; i++) {",
      "        if (used_[i])",
      "          continue;",
      "",
      "        dfs(adj_list, i);",
      "      }",
      "",
      "      int scc_cnt = 0;",
      "      group_.assign(n, 0);",
      "      used_.assign(n, false);",
      "",
      "      Graph rgraph = reverse_edges(graph);",
      "      auto radj_list = rgraph.graph();",
      "",
      "      // scc grouping",
      "      for (int i = n - 1; i >= 0; i--) {",
      "        int idx = post_order_[i];",
      "        if (used_[idx])",
      "          continue;",
      "",
      "        rdfs(radj_list, idx, scc_cnt);",
      "        scc_cnt++;",
      "      }",
      "",
      "      scc_.assign(scc_cnt, vector<int>(0));",
      "      scc_graph_ = Graph(scc_cnt);",
      "",
      "      for (int i = 0; i < n; i++) {",
      "        // build scc",
      "        scc_[group_[i]].push_back(i);",
      "",
      "        // build scc graph",
      "        for (auto e: adj_list[i]) {",
      "          bool is_same_scc = group_[i] == group_[e.to()];",
      "          if (is_same_scc)",
      "            continue;",
      "",
      "          if constexpr (is_same_v<Graph, UnWeightedGraph>) {",
      "            scc_graph_.add_edge(UnWeightedEdge(group_[i], group_[e.to()]));",
      "          } else {",
      "            scc_graph_.add_edge(WeightedEdge(group_[i], group_[e.to()], e.cost()));",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    vector<int> group() const {",
      "      return group_;",
      "    }",
      "",
      "    vector<vector<int>> scc() const {",
      "      return scc_;",
      "    }",
      "",
      "    Graph scc_graph() const {",
      "      return scc_graph_;",
      "    }",
      "",
      "  private:",
      "    template <typename Edges>",
      "    void dfs(const vector<Edges> &adj_list, int idx) {",
      "      used_[idx] = true;",
      "      for (const auto &e: adj_list[idx]) {",
      "        const int &to = e.to();",
      "        if (used_[to])",
      "          continue;",
      "",
      "        dfs(adj_list, to);",
      "      }",
      "      post_order_.emplace_back(idx);",
      "    }",
      "",
      "    template <typename Edges>",
      "    void rdfs(const vector<Edges> &adj_list, int idx, int group_id) {",
      "      used_[idx] = true;",
      "      group_[idx] = group_id;",
      "      for (const auto &e: adj_list[idx]) {",
      "        const int &to = e.to();",
      "        if (used_[to])",
      "          continue;",
      "",
      "        rdfs(adj_list, to, group_id);",
      "      }",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of strongly_connected_component",
    "scope": "cpp"
  },
  "lowest-common-ancestor.hpp": {
    "prefix": "cpplowest_common_ancestor",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <stack>",
      "#include <tuple>",
      "",
      "namespace graph_library {",
      "  class LowestCommonAncestor {",
      "    UnWeightedGraph graph_;",
      "    int height_, root_;",
      "    vector<vector<int>> doubling_parents_;",
      "    vector<int> depths_;",
      "",
      "  public:",
      "    LowestCommonAncestor(const UnWeightedGraph &graph, int root = 0): graph_(graph), root_(root) {",
      "      int n = graph_.size();",
      "",
      "      height_ = 1;",
      "      while ((1 << height_) <= n) {",
      "        height_++;",
      "      }",
      "",
      "      doubling_parents_.assign(height_, vector<int>(n, -1));",
      "      depths_.assign(n, 0);",
      "",
      "      vector<UnWeightedEdges> adj_list = graph_.graph();",
      "      // <v, par, dep>",
      "      stack<tuple<int, int, int>> st;",
      "      st.emplace(root, -1, 0);",
      "      while (not st.empty()) {",
      "        auto [v, par, dep] = st.top();",
      "        st.pop();",
      "",
      "        doubling_parents_.at(0).at(v) = par;",
      "        depths_.at(v) = dep;",
      "        for (UnWeightedEdge e: adj_list.at(v)) {",
      "          int to = e.to();",
      "          if (to != par) {",
      "            st.emplace(to, v, dep + 1);",
      "          }",
      "        }",
      "      }",
      "",
      "      for (int k = 0; k + 1 < height_; k++) {",
      "        for (int v = 0; v < n; v++) {",
      "          if (doubling_parents_.at(k).at(v) != -1) {",
      "            int kth_pow_par = doubling_parents_.at(k).at(v);",
      "            doubling_parents_.at(k + 1).at(v) = doubling_parents_.at(k).at(kth_pow_par);",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    int query(int u, int v) {",
      "      if (depths_.at(u) > depths_.at(v))",
      "        swap(u, v);",
      "      for (int k = 0; k < height_; k++)",
      "        if ((depths_.at(v) - depths_.at(u)) >> k & 1)",
      "          v = doubling_parents_.at(k).at(v);",
      "",
      "      if (u == v)",
      "        return u;",
      "",
      "      for (int k = height_ - 1; k >= 0; k--)",
      "        if (doubling_parents_.at(k).at(u) != doubling_parents_.at(k).at(v))",
      "          u = doubling_parents_.at(k).at(u), v = doubling_parents_.at(k).at(v);",
      "",
      "      return doubling_parents_.at(0).at(u);",
      "    }",
      "",
      "    int distance(int u, int v) {",
      "      return depths_.at(u) + depths_.at(v) - depths_[query(u, v)] * 2;",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of lowest_common_ancestor",
    "scope": "cpp"
  },
  "minimum-spanning-tree.hpp": {
    "prefix": "cppminimum_spanning_tree",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  class UnionFind {",
      "    // number of vertices",
      "    int n_;",
      "",
      "    vector<int> sizes_, parents_;",
      "",
      "  public:",
      "    UnionFind(int n): n_(n), sizes_(n, 1), parents_(n) {",
      "      iota(parents_.begin(), parents_.end(), 0);",
      "    }",
      "",
      "    // 根（そのグループの識別番号）",
      "    int root(int x) {",
      "      if (x == parents_[x])",
      "        return x;",
      "      return parents_[x] = root(parents_[x]);",
      "    }",
      "",
      "    int size(int x) {",
      "      return sizes_[root(x)];",
      "    }",
      "",
      "    bool same(int x, int y) {",
      "      return root(x) == root(y);",
      "    }",
      "",
      "    // size(x) < size(y): -1",
      "    // not merged:         0",
      "    // size(x) > size(y): +1",
      "    int merge(int x, int y) {",
      "      x = root(x);",
      "      y = root(y);",
      "      if (x == y)",
      "        return 0;",
      "",
      "      int result = +1;",
      "      if (sizes_[x] < sizes_[y]) {",
      "        swap(x, y);",
      "        result = -1;",
      "      }",
      "",
      "      sizes_[x] += sizes_[y];",
      "      parents_[y] = x;",
      "",
      "      return result;",
      "    }",
      "",
      "    vector<vector<int>> groups() {",
      "      vector<vector<int>> grps(n_);",
      "      for (int i = 0; i < n_; i++) {",
      "        grps[root(i)].emplace_back(i);",
      "      }",
      "      vector<vector<int>> res;",
      "      for (int i = 0; i < n_; i++) {",
      "        if (grps[i].empty())",
      "          continue;",
      "        res.emplace_back(grps[i]);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure_library",
      "",
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <queue>",
      "",
      "namespace graph_library {",
      "",
      "  template <typename Cost>",
      "  struct MinimumSpanningTree {",
      "    WeightedGraph<Cost> graph_;",
      "    WeightedGraph<Cost> mst_;",
      "    MinimumSpanningTree(const WeightedGraph<Cost> &graph): graph_(graph) {}",
      "",
      "    Cost kruskal() {",
      "      mst_ = WeightedGraph<Cost>(graph_.size()); // init",
      "      if (graph_.size() == 0) {",
      "        return Cost(0);",
      "      }",
      "",
      "      vector<WeightedEdge<Cost>> edges = graph_.edges();",
      "      sort(edges.begin(), edges.end());",
      "",
      "      data_structure_library::UnionFind uf(graph_.size());",
      "",
      "      Cost sum = 0;",
      "",
      "      for (auto edge: edges) {",
      "        int from = edge.from();",
      "        int to = edge.to();",
      "",
      "        if (uf.same(from, to))",
      "          continue;",
      "",
      "        uf.merge(from, to);",
      "        sum += edge.cost();",
      "        mst_.add_edge(edge);",
      "      }",
      "",
      "      return sum;",
      "    }",
      "",
      "    Cost prim() {",
      "      mst_ = WeightedGraph<Cost>(graph_.size()); // init",
      "      if (graph_.size() == 0) {",
      "        return Cost(0);",
      "      }",
      "",
      "      priority_queue<WeightedEdge<Cost>, vector<WeightedEdge<Cost>>, greater<WeightedEdge<Cost>>> pq;",
      "      pq.emplace(/*from=*/0, /*to=*/0, Cost(0));",
      "",
      "      vector<vector<WeightedEdge<Cost>>> adj_list = graph_.graph();",
      "      vector<bool> used(graph_.size(), false);",
      "",
      "      Cost sum = 0;",
      "",
      "      while (not pq.empty()) {",
      "        auto e = pq.top();",
      "        pq.pop();",
      "",
      "        int v = e.to();",
      "",
      "        if (used[v])",
      "          continue;",
      "",
      "        sum += e.cost();",
      "        used[v] = true;",
      "        mst_.add_edge(e);",
      "",
      "        for (auto edge: adj_list[v]) {",
      "          int to = edge.to();",
      "",
      "          if (used[to])",
      "            continue;",
      "",
      "          pq.push(edge);",
      "        }",
      "      }",
      "",
      "      return sum;",
      "    }",
      "  };",
      "",
      "} // namespace graph_library"
    ],
    "description": "Template of minimum_spanning_tree",
    "scope": "cpp"
  },
  "to-weighted.hpp": {
    "prefix": "cppto_weighted",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "namespace graph_library {",
      "  template <typename Cost>",
      "  WeightedGraph<Cost> to_weighted(const UnWeightedGraph &graph, const Cost &init) {",
      "    WeightedGraph<Cost> res(graph.size());",
      "",
      "    const UnWeightedEdges &edges = graph.edges();",
      "    for (const UnWeightedEdge &edge: edges) {",
      "      WeightedEdge<Cost> weighted_edge(edge.from(), edge.to(), init);",
      "      res.add_edge(weighted_edge);",
      "    }",
      "",
      "    return res;",
      "  }",
      "} // namespace graph_library"
    ],
    "description": "Template of to_weighted",
    "scope": "cpp"
  },
  "shortest-hamiltonian-path.hpp": {
    "prefix": "cppshortest_hamiltonian_path",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <limits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  // 全頂点を1度だけ訪問したときの最短経路距離",
      "  // buildでinfが帰ってきたらそのような経路はない",
      "  template <typename T>",
      "  struct ShortestHamiltonianPath {",
      "    struct edge {",
      "      int to;",
      "      T cost;",
      "      edge(int to, T cost): to(to), cost(cost) {}",
      "    };",
      "",
      "    int V;",
      "    vector<vector<edge>> G;",
      "    vector<vector<T>> dp;",
      "",
      "    ShortestHamiltonianPath(int V_): V(V_), G(V_) {}",
      "",
      "    T inf() {",
      "      return numeric_limits<T>::max() / 2;",
      "    }",
      "",
      "    void add_edge(int from, int to, T cost) {",
      "      G[from].emplace_back(to, cost);",
      "    }",
      "",
      "    T build() {",
      "      T res = inf();",
      "      dp.assign(V, vector<T>(1 << V, -1));",
      "      for (int sv = 0; sv < V; sv++) {",
      "        res = min(res, dfs(sv, 1 << sv));",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // private method",
      "    T dfs(int v, int Set) {",
      "      T &res = dp[v][Set];",
      "      if (Set + 1 == 1 << V)",
      "        res = 0;",
      "      if (res != -1)",
      "        return res;",
      "      res = inf();",
      "      for (auto [to, cost]: G[v]) {",
      "        int bit = 1 << to;",
      "        if (Set & bit)",
      "          continue;",
      "        res = min(res, dfs(to, Set | bit) + cost);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of shortest_hamiltonian_path",
    "scope": "cpp"
  },
  "to-unweighted.hpp": {
    "prefix": "cppto_unweighted",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "namespace graph_library {",
      "  template <typename Cost>",
      "  UnWeightedGraph to_unweighted(const WeightedGraph<Cost> &graph) {",
      "    UnWeightedGraph res(graph.size());",
      "",
      "    const WeightedEdges<Cost> &edges = graph.edges();",
      "    for (const WeightedEdge<Cost> &edge: edges) {",
      "      UnWeightedEdge unweighted_edge(edge.from(), edge.to());",
      "      res.add_edge(unweighted_edge);",
      "    }",
      "",
      "    return res;",
      "  }",
      "} // namespace graph_library"
    ],
    "description": "Template of to_unweighted",
    "scope": "cpp"
  },
  "topological-sort.hpp": {
    "prefix": "cpptopological_sort",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <queue>",
      "",
      "namespace graph_library {",
      "  // if graph is not DAG, return {}",
      "  vector<int> topological_sort(const UnWeightedGraph &graph) {",
      "    int n = graph.size();",
      "    vector<int> in_degree(n, 0);",
      "",
      "    auto edges = graph.edges();",
      "    for (auto e: edges) {",
      "      in_degree[e.to()]++;",
      "    }",
      "",
      "    vector<UnWeightedEdges> adj_list = graph.graph();",
      "",
      "    queue<int> q;",
      "    for (int i = 0; i < n; i++) {",
      "      if (in_degree[i] == 0)",
      "        q.push(i);",
      "    }",
      "",
      "    vector<int> sorted_indexes;",
      "    while (not q.empty()) {",
      "      int v = q.front();",
      "      q.pop();",
      "",
      "      sorted_indexes.emplace_back(v);",
      "      for (auto e: adj_list[v]) {",
      "        int to = e.to();",
      "",
      "        in_degree[to]--;",
      "        if (in_degree[to] == 0)",
      "          q.push(to);",
      "      }",
      "    }",
      "",
      "    bool has_cycle = int(sorted_indexes.size()) < n;",
      "    if (has_cycle) {",
      "      return {};",
      "    }",
      "    return sorted_indexes;",
      "  }",
      "} // namespace graph_library"
    ],
    "description": "Template of topological_sort",
    "scope": "cpp"
  },
  "reachable.hpp": {
    "prefix": "cppreachable",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <stack>",
      "",
      "namespace graph_library {",
      "  // s,t : 0-indexed.",
      "  // reachable s -> t",
      "  template <class Graph>",
      "  bool reachable(const Graph &g, int s, int t) {",
      "    const auto &graph = g.graph();",
      "",
      "    stack<int> st;",
      "    st.push(s);",
      "    vector<char> used(g.size(), 0);",
      "",
      "    while (not st.empty()) {",
      "      int v = st.top();",
      "      st.pop();",
      "",
      "      used[v] = true;",
      "      if (v == t)",
      "        return true;",
      "",
      "      for (const auto &edge: graph[v]) {",
      "        const int &to = edge.to();",
      "        if (used[to])",
      "          continue;",
      "",
      "        st.push(to);",
      "      }",
      "    }",
      "",
      "    return false;",
      "  }",
      "} // namespace graph_library"
    ],
    "description": "Template of reachable",
    "scope": "cpp"
  },
  "graph-type.hpp": {
    "prefix": "cppgraph_type",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library"
    ],
    "description": "Template of graph_type",
    "scope": "cpp"
  },
  "grid-bfs.hpp": {
    "prefix": "cppgrid_bfs",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <queue>",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  vector<vector<int>> grid_bfs(vector<string> &s, char start, const string &wall = \"#\") {",
      "    constexpr int dy[] = { 0, 1, 0, -1 }, dx[] = { 1, 0, -1, 0 };",
      "    int h = s.size(), w = s[0].size();",
      "    vector<vector<int>> res(h, vector<int>(w, -1));",
      "    queue<pair<int, int>> q;",
      "    for (int i = 0; i < h; i++) {",
      "      for (int j = 0; j < w; j++) {",
      "        if (s[i][j] == start) {",
      "          q.emplace(i, j);",
      "          res[i][j] = 0;",
      "        }",
      "      }",
      "    }",
      "    while (!q.empty()) {",
      "      auto p = q.front();",
      "      q.pop();",
      "      for (int i = 0; i < 4; i++) {",
      "        int ny = p.first + dy[i], nx = p.second + dx[i];",
      "        if (ny < 0 or nx < 0 or ny >= h or nx >= w)",
      "          continue;",
      "        if (res[ny][nx] != -1)",
      "          continue;",
      "        if (wall.find(s[ny][nx]) != string::npos)",
      "          continue;",
      "        res[ny][nx] = res[p.first][p.second] + 1;",
      "        q.emplace(ny, nx);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "} // namespace graph_library"
    ],
    "description": "Template of grid_bfs",
    "scope": "cpp"
  },
  "euler-tour.hpp": {
    "prefix": "cppeuler_tour",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "namespace graph_library {",
      "  class EulerTour {",
      "    vector<int> in_time_, out_time_, depths_, parents_, edge_table_;",
      "",
      "    void dfs(const vector<UnWeightedEdges> &adj_list, int v, int &time, int d) {",
      "      in_time_.at(v) = time;",
      "      depths_.at(v) = d;",
      "      edge_table_.at(time) = v;",
      "      time++;",
      "",
      "      for (auto e: adj_list.at(v)) {",
      "        int to = e.to();",
      "",
      "        if (in_time_.at(to) != -1)",
      "          continue;",
      "",
      "        parents_.at(to) = v;",
      "        dfs(adj_list, to, time, d + 1);",
      "      }",
      "      out_time_.at(v) = time;",
      "      edge_table_.at(time) = -v;",
      "      time++;",
      "    }",
      "",
      "  public:",
      "    EulerTour(const UnWeightedGraph &graph, int root) {",
      "      int n = graph.size();",
      "      in_time_.assign(n, -1);",
      "      out_time_.assign(n, -1);",
      "      depths_.assign(n, -1);",
      "      parents_.assign(n, -1);",
      "      edge_table_.assign(2 * n, -1);",
      "",
      "      vector<UnWeightedEdges> adj_list = graph.graph();",
      "",
      "      int time = 0;",
      "      dfs(adj_list, root, time, 0);",
      "    }",
      "",
      "    int in(int v) {",
      "      return in_time_.at(v);",
      "    }",
      "    int out(int v) {",
      "      return out_time_.at(v);",
      "    }",
      "    int depth(int v) {",
      "      return depths_.at(v);",
      "    }",
      "    int parent(int v) {",
      "      return parents_.at(v);",
      "    }",
      "    vector<int> edge_table() {",
      "      return edge_table_;",
      "    }",
      "",
      "    // edge_table: [first, second], vertex_table:[first, second)",
      "    pair<int, int> subtree(int v) {",
      "      return pair(in_time_.at(v), out_time_.at(v));",
      "    }",
      "",
      "    vector<int> vertex_table() {",
      "      vector<int> res = edge_table_;",
      "      for (auto &v: res) {",
      "        if (v < 0)",
      "          v = parents_.at(-v);",
      "      }",
      "      // 半開区間->閉区間の誤差",
      "      res.pop_back();",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of euler_tour",
    "scope": "cpp"
  },
  "tree.hpp": {
    "prefix": "cpptree",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "// WIP",
      "",
      "namespace graph_library {",
      "  // path_query    : op,e,inv",
      "  // subtree_query : op,e",
      "  // op   : T, T -> T (operation)",
      "  // e    : void -> T (identity element)",
      "  // inv  : T    -> T (inverse element)",
      "  // T is weight type and value type",
      "  template <typename T, T (*op)(T, T), T (*e)(), T (*inv)(T)>",
      "  class WeightedTree {",
      "  private:",
      "    struct SparseTable {",
      "      vector<vector<pair<int, int>>> st;",
      "      vector<int> lookup;",
      "",
      "      SparseTable() {}",
      "",
      "      void build(const vector<pair<int, int>> &v) {",
      "        int b = 0;",
      "        while ((1 << b) <= static_cast<int>(v.size()))",
      "          ++b;",
      "        st.assign(b, vector<pair<int, int>>(1 << b));",
      "        for (int i = 0; i < static_cast<int>(v.size()); i++) {",
      "          st[0][i] = v[i];",
      "        }",
      "        for (int i = 1; i < b; i++) {",
      "          for (int j = 0; j + (1 << i) <= (1 << b); j++) {",
      "            st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);",
      "          }",
      "        }",
      "        lookup.resize(v.size() + 1);",
      "        for (int i = 2; i < static_cast<int>(lookup.size()); i++) {",
      "          lookup[i] = lookup[i >> 1] + 1;",
      "        }",
      "      }",
      "",
      "      inline pair<int, int> query(int l, int r) {",
      "        int b = lookup[r - l];",
      "        return min(st[b][l], st[b][r - (1 << b)]);",
      "      }",
      "    };",
      "",
      "    class SegmentTree {",
      "    private:",
      "      int n;",
      "      vector<T> data;",
      "",
      "      T search(int l, int r) {",
      "        T vl = e(), vr = e();",
      "        l += n, r += n;",
      "        while (l < r) {",
      "          if (l & 1)",
      "            vl = op(vl, data[l++]);",
      "          if (r & 1)",
      "            vr = op(vr, data[--r]);",
      "          l >>= 1, r >>= 1;",
      "        }",
      "        return op(vl, vr);",
      "      }",
      "",
      "    public:",
      "      SegmentTree() {}",
      "",
      "      void assign(int _n) {",
      "        n = 1;",
      "        while (n < _n) {",
      "          n <<= 1;",
      "        }",
      "        data.assign(2 * n, e());",
      "      }",
      "",
      "      T get(int i) {",
      "        return data[i + n];",
      "      }",
      "",
      "      void set(int i, T key) {",
      "        i += n;",
      "        data[i] = key;",
      "        while (i > 0) {",
      "          i >>= 1;",
      "          data[i] = op(data[i << 1 | 0], data[i << 1 | 1]);",
      "        }",
      "      }",
      "",
      "      void add(int i, T key) {",
      "        set(i, get(i) + key);",
      "      }",
      "",
      "      T prod(int l, int r) {",
      "        return search(l, r);",
      "      }",
      "",
      "      T all_prod() {",
      "        return n != 0 ? data[0] : e();",
      "      }",
      "    };",
      "",
      "    SparseTable min_dep_idx;",
      "    SegmentTree data;",
      "    vector<int> in, out, dep, par, dia_to, edge_table;",
      "    pair<T, int> dia;",
      "    vector<vector<int>> doubling_par;",
      "    vector<vector<pair<int, T>>> G;",
      "    vector<T> data;",
      "    const int LOG;",
      "",
      "    void dfs(int v, int &time, int depth) {",
      "      in[v] = time;",
      "      dep[time] = depth;",
      "      edge_table[time++] = v;",
      "      for (auto to: G[v]) {",
      "        if (in[to] != -1)",
      "          continue;",
      "        par[to] = v;",
      "        dfs(to, time, depth + 1);",
      "      }",
      "      out[v] = time;",
      "      dep[time] = depth - 1;",
      "      edge_table[time++] = -v;",
      "    }",
      "",
      "    pair<T, int> dfs_diameter(int v, int p) {",
      "      pair<T, int> res(0, v);",
      "      for (auto [to, cost]: G[v]) {",
      "        if (to == par)",
      "          continue;",
      "        auto [ncost, u] = dfs_diameter(to, v);",
      "        if (res < make_pair(ncost + cost, u)) {",
      "          res = make_pair(ncost + cost);",
      "          dia_to[v] = to;",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // min({ x | 2^x > n })",
      "    int log_two(int n) {",
      "      int x = 1;",
      "      while ((1 << x) <= n) {",
      "        x++;",
      "      }",
      "      return x;",
      "    }",
      "",
      "  public:",
      "    WeightedTree(int n): G(n), data(n), LOG(log_two(n)), dia(-1) {",
      "      data.assign(n);",
      "    }",
      "",
      "    void add_edge(int from, int to, T cost = 1) {",
      "      G[from].emplace_back(to, cost);",
      "    }",
      "",
      "    T path_query(int v) {",
      "      return data.prod(0, in[v] + 1);",
      "    }",
      "",
      "    // O(log N)",
      "    T path_query(int u, int v) {",
      "      T res = op(path_query(u), path_query(v));",
      "      res = op(res, inv(path_query(lca(u, v))));",
      "      res = op(res, inv(path_query(lca(u, v))));",
      "      return res;",
      "    }",
      "",
      "    // O(log N)",
      "    T subtree_query(int v) {",
      "      return data.prod(in[v], out[v]);",
      "    }",
      "",
      "    // O(Nlog N)",
      "    void build(int s) {",
      "      int n = G.size();",
      "",
      "      dia_to.assign(n, -1);",
      "      dia = dfs_diameter(dfs_diameter(s, -1).second, -1);",
      "",
      "      in.assign(n, -1);",
      "      out.assign(n, -1);",
      "      par.assign(n, 0);",
      "      dep.assign(2 * n, 0);",
      "      edge_table.assign(2 * n, -1);",
      "      int time = 0;",
      "      dfs(s, time, 0);",
      "      dep.back() = s;",
      "",
      "      // build doubling parent",
      "      doubling_par.assign(LOG, vector<int>(n, -1));",
      "      for (int i = 0; i < n; i++) {",
      "        doubling_par[0][i] = par[i];",
      "      }",
      "      for (int k = 0; k < LOG - 1; k++) {",
      "        for (int i = 0; i < n; i++) {",
      "          if (doubling_par[k][i] == -1) {",
      "            doubling_par[k + 1][i] = -1;",
      "            continue;",
      "          }",
      "          doubling_par[k + 1][i] = doubling_par[k][doubling_par[k][i]];",
      "        }",
      "      }",
      "",
      "      // build sparse table",
      "      vector<pair<int, int>> dep_idx(dep.size());",
      "      for (int i = 0; i < static_cast<int>(dep.size()); i++) {",
      "        auto &[depth, idx] = dep_idx[i];",
      "        depth = dep[i];",
      "        idx = i;",
      "      }",
      "      min_dep_idx.build(dep_idx);",
      "    }",
      "",
      "    // O(1)",
      "    T diameter() {",
      "      return dia.first;",
      "    }",
      "",
      "    // O(N)",
      "    vector<int> diameter_path() {",
      "      int v = dia.second;",
      "      vector<int> path;",
      "      path.reserve(dia.first);",
      "      while (v != -1) {",
      "        path.emplace_back(v);",
      "        v = dia_to[v];",
      "      }",
      "      return path;",
      "    }",
      "",
      "    // O(1)",
      "    bool in_subtree(int subroot, int v) {",
      "      return in[subroot] < in[v] and out[v] < out[subroot];",
      "    }",
      "",
      "    // O(1) : lowest common ancestor",
      "    int lca(int u, int v) {",
      "      int idx = min_dep_idx.query(min(in[u], in[v]), max(in[u], in[v]) + 1).second;",
      "      int res = edge_table[idx];",
      "      if (res < 0)",
      "        res = par[-res];",
      "      return res;",
      "    }",
      "",
      "    // O(log N) : level ancestor",
      "    int la(int v, int depth) {",
      "      int anc = v;",
      "      for (int i = 0; i < LOG; i++) {",
      "        if (depth >> i & 1)",
      "          anc = doubling_par[i][anc];",
      "      }",
      "      return anc;",
      "    }",
      "",
      "    // O(1)",
      "    int depth(int v) {",
      "      return dep[in[v]];",
      "    }",
      "",
      "    // O(1)",
      "    int distance(int u, int v) {",
      "      return depth(u) + depth(v) - 2 * depth(lca(u, v));",
      "    }",
      "",
      "    // O(1) : from v to root move k step",
      "    int up(int v, int k) {",
      "      return la(v, depth(v) - k);",
      "    }",
      "",
      "    // O(1) : from u to v move k step",
      "    int next(int u, int v, int k = 1) {",
      "      if (k <= distance(u, lca(u, v)))",
      "        return up(u, k);",
      "      return up(v, distance(v, lca(u, v)) - k);",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of tree",
    "scope": "cpp"
  },
  "low-link.hpp": {
    "prefix": "cpplow_link",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <algorithm>",
      "",
      "namespace graph_library {",
      "  class LowLink {",
      "    UnWeightedGraph graph_;",
      "    vector<UnWeightedEdges> adj_list_;",
      "    vector<int> order_, lowlink_;",
      "    vector<int> articulations_;",
      "    vector<UnWeightedEdge> bridges_;",
      "",
      "  public:",
      "    LowLink(const UnWeightedGraph &graph): graph_(graph) {",
      "      adj_list_ = graph_.graph();",
      "",
      "      int n = graph_.size();",
      "      order_.assign(n, -1);",
      "      lowlink_.assign(n, 0);",
      "",
      "      int k = 0;",
      "      for (int i = 0; i < n; i++) {",
      "        if (order_[i] == -1)",
      "          dfs(i, k, -1);",
      "      }",
      "      sort(articulations_.begin(), articulations_.end());",
      "      sort(bridges_.begin(), bridges_.end());",
      "    }",
      "",
      "    vector<int> articulations() const {",
      "      return articulations_;",
      "    }",
      "",
      "    vector<UnWeightedEdge> bridges() const {",
      "      return bridges_;",
      "    }",
      "",
      "  private:",
      "    void dfs(int idx, int &k, int parent) {",
      "      order_[idx] = lowlink_[idx] = k;",
      "      k++;",
      "",
      "      bool is_articulation = false;",
      "      int child_cnt = 0;",
      "",
      "      for (auto edge: adj_list_[idx]) {",
      "        int to = edge.to();",
      "",
      "        if (order_[to] == -1) {",
      "          child_cnt++;",
      "          dfs(to, k, idx);",
      "",
      "          lowlink_[idx] = min(lowlink_[idx], lowlink_[to]);",
      "          if (parent != -1 and order_[idx] <= lowlink_[to])",
      "            is_articulation = true;",
      "          if (order_[idx] < lowlink_[to])",
      "            bridges_.emplace_back(min(idx, to), max(idx, to));",
      "        } else if (to != parent) {",
      "          lowlink_[idx] = min(lowlink_[idx], order_[to]);",
      "        }",
      "      }",
      "",
      "      if (parent == -1 and child_cnt >= 2)",
      "        is_articulation = true;",
      "      if (is_articulation)",
      "        articulations_.emplace_back(idx);",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of low_link",
    "scope": "cpp"
  },
  "warshall-floyd.hpp": {
    "prefix": "cppwarshall_floyd",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "#include <limits>",
      "",
      "namespace graph_library {",
      "  template <typename Cost>",
      "  class WarshallFloyd {",
      "    WeightedGraph<Cost> graph_;",
      "    vector<vector<Cost>> distances_;",
      "    vector<vector<int>> nexts_;",
      "    bool has_neg_cycle_;",
      "",
      "  public:",
      "    WarshallFloyd(const WeightedGraph<Cost> &graph): graph_(graph), has_neg_cycle_(false) {",
      "      int n = graph_.size();",
      "      distances_.assign(n, vector<Cost>(n, inf()));",
      "      for (int i = 0; i < n; i++) {",
      "        distances_[i][i] = 0;",
      "      }",
      "",
      "      nexts_.assign(n, vector<int>(n, 0));",
      "      for (int i = 0; i < n; i++) {",
      "        for (int j = 0; j < n; j++) {",
      "          nexts_[i][j] = j;",
      "        }",
      "      }",
      "",
      "      auto edges = graph_.edges();",
      "      for (auto edge: edges) {",
      "        int from = edge.from();",
      "        int to = edge.to();",
      "        Cost cost = edge.cost();",
      "",
      "        // if there are multiple edges, use the minimum cost edge.",
      "        distances_.at(from).at(to) = min(distances_.at(from).at(to), cost);",
      "      }",
      "",
      "      for (int k = 0; k < n; k++) {",
      "        for (int i = 0; i < n; i++) {",
      "          for (int j = 0; j < n; j++) {",
      "            if (distances_[i][k] == inf() or distances_[k][j] == inf()) {",
      "              continue;",
      "            }",
      "",
      "            if (distances_[i][j] > distances_[i][k] + distances_[k][j]) {",
      "              distances_[i][j] = distances_[i][k] + distances_[k][j];",
      "              nexts_[i][j] = nexts_[i][k];",
      "            }",
      "          }",
      "        }",
      "      }",
      "",
      "      for (int i = 0; i < n; i++) {",
      "        if (distances_[i][i] < 0) {",
      "          has_neg_cycle_ = true;",
      "          break;",
      "        }",
      "      }",
      "    }",
      "",
      "    static constexpr Cost inf() {",
      "      return numeric_limits<Cost>::max() / 2;",
      "    }",
      "",
      "    vector<Cost> &operator[](int k) {",
      "      return distances_.at(k);",
      "    }",
      "",
      "    bool has_negative_cycle() const {",
      "      return has_neg_cycle_;",
      "    }",
      "",
      "    vector<int> restore(int s, int g) {",
      "      vector<int> path;",
      "      for (int v = s; v != g; v = nexts_.at(v).at(g)) {",
      "        path.emplace_back(v);",
      "      }",
      "      path.emplace_back(g);",
      "      return path;",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of warshall_floyd",
    "scope": "cpp"
  },
  "shortest-hamiltonian-cycle.hpp": {
    "prefix": "cppshortest_hamiltonian_cycle",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <limits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  // verify:AOJ_DPL_2_A",
      "  // sから始めて1度だけ訪問し、sに戻ってきた閉路の最短経路距離",
      "  // buildでinfinity()が帰ってきたらそのような経路はない",
      "  template <typename T>",
      "  struct ShortestHamiltonianCycle {",
      "    struct edge {",
      "      int to;",
      "      T cost;",
      "      edge(int to, T cost): to(to), cost(cost) {}",
      "    };",
      "",
      "    int V;",
      "    int start;",
      "    vector<vector<edge>> G;",
      "    vector<vector<T>> dp;",
      "",
      "    ShortestHamiltonianCycle(int V_): V(V_), G(V_) {}",
      "",
      "    T inf() {",
      "      return numeric_limits<T>::max() / 2;",
      "    }",
      "",
      "    void add_edge(int from, int to, T cost) {",
      "      G[from].emplace_back(to, cost);",
      "    }",
      "",
      "    T build(int s) {",
      "      start = s;",
      "      dp.assign(V, vector<T>(1 << V, -1));",
      "      return dfs(s, 0);",
      "    }",
      "",
      "    // private method",
      "    T dfs(int v, int Set) {",
      "      T &res = dp[v][Set];",
      "      if (Set + 1 == 1 << V and v == start)",
      "        res = 0;",
      "      if (res != -1)",
      "        return res;",
      "      res = inf();",
      "      for (auto [to, cost]: G[v]) {",
      "        int bit = 1 << to;",
      "        if (Set & bit)",
      "          continue;",
      "        res = min(res, dfs(to, Set | bit) + cost);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph_library"
    ],
    "description": "Template of shortest_hamiltonian_cycle",
    "scope": "cpp"
  },
  "logarithm.hpp": {
    "prefix": "cpplogarithm",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <cassert>",
      "",
      "namespace math_library {",
      "  constexpr int logarithm(ll base, ll n) {",
      "    assert(base != 0);",
      "    int cnt = 0;",
      "    while (n % base == 0) {",
      "      n /= base;",
      "      cnt++;",
      "    }",
      "    return cnt;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of logarithm",
    "scope": "cpp"
  },
  "divisor.hpp": {
    "prefix": "cppdivisor",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  vector<ll> divisor(ll n) {",
      "    vector<ll> res;",
      "    for (ll i = 1; i * i <= n; i++) {",
      "      if (n % i == 0) {",
      "        res.emplace_back(i);",
      "        if (i * i != n)",
      "          res.emplace_back(n / i);",
      "      }",
      "    }",
      "    sort(res.begin(), res.end());",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of divisor",
    "scope": "cpp"
  },
  "eratosthenes-sieve.hpp": {
    "prefix": "cpperatosthenes_sieve",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  struct EratosthenesSieve {",
      "    vector<bool> prime_table;",
      "",
      "    EratosthenesSieve() {}",
      "    EratosthenesSieve(int N): prime_table(N + 1, true) {",
      "      prime_table[0] = prime_table[1] = false;",
      "    }",
      "",
      "    void build() {",
      "      int n = prime_table.size();",
      "      for (ll i = 2; i * i < n; i++) {",
      "        if (!prime_table[i])",
      "          continue;",
      "        for (ll j = i * i; j < n; j += i) {",
      "          prime_table[j] = false;",
      "        }",
      "      }",
      "    }",
      "",
      "    bool operator[](int k) {",
      "      return prime_table[k];",
      "    }",
      "  };",
      "} // namespace math_library"
    ],
    "description": "Template of eratosthenes_sieve",
    "scope": "cpp"
  },
  "count-factor.hpp": {
    "prefix": "cppcount_factor",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <cstdint>",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  vector<int> count_factor(int N) {",
      "    constexpr int INF = INT32_MAX / 2;",
      "    vector<int> table(N + 1, 0);",
      "",
      "    for (int i = 2; i <= N; i++) {",
      "      if (table[i])",
      "        continue;",
      "      table[i] = 1;",
      "      for (int j = 2 * i; j <= N; j += i) {",
      "        if (j % (i * i) == 0)",
      "          table[j] = -INF;",
      "        else",
      "          table[j]++;",
      "      }",
      "    }",
      "    return table;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of count_factor",
    "scope": "cpp"
  },
  "mod-inv.hpp": {
    "prefix": "cppmod_inv",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "",
      "namespace math_library {",
      "  constexpr ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "    if (b == 0) {",
      "      x = 1;",
      "      y = 0;",
      "      return a;",
      "    }",
      "    ll d = extgcd(b, a % b, y, x);",
      "    y = y - (a / b) * x;",
      "    return d;",
      "  }",
      "} // namespace math_library",
      "",
      "namespace math_library {",
      "  constexpr ll modinv(ll n, ll mod) {",
      "    ll x = 0, y = 0;",
      "    extgcd(n, mod, x, y);",
      "    return (x % mod + mod) % mod;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of mod_inv",
    "scope": "cpp"
  },
  "fast-factorize.hpp": {
    "prefix": "cppfast_factorize",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <atcoder/modint>",
      "#include <cstdint>",
      "#include <cstdlib>",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  namespace inner {",
      "    using u32 = uint32_t;",
      "    using u64 = uint64_t;",
      "    using i64 = int64_t;",
      "    using u128 = __uint128_t;",
      "",
      "    u64 gcd_impl(u64 n, u64 m) {",
      "      constexpr u64 K = 5;",
      "      for (int i = 0; i < 80; ++i) {",
      "        u64 t = n - m;",
      "        u64 s = n - m * K;",
      "        bool q = t < m;",
      "        bool p = t < m * K;",
      "        n = q ? m : t;",
      "        m = q ? t : m;",
      "        if (m == 0)",
      "          return n;",
      "        n = p ? n : s;",
      "      }",
      "      return gcd_impl(m, n % m);",
      "    }",
      "",
      "    u64 gcd_pre(u64 n, u64 m) {",
      "      for (int i = 0; i < 4; ++i) {",
      "        u64 t = n - m;",
      "        bool q = t < m;",
      "        n = q ? m : t;",
      "        m = q ? t : m;",
      "        if (m == 0)",
      "          return n;",
      "      }",
      "      return gcd_impl(n, m);",
      "    }",
      "",
      "    u64 gcd_fast(u64 n, u64 m) {",
      "      return n > m ? gcd_pre(n, m) : gcd_pre(m, n);",
      "    }",
      "",
      "    struct modint64 {",
      "      using u64 = uint64_t;",
      "",
      "    public:",
      "      static u64 mod;",
      "      static u64 r, n2;",
      "      static void set_mod(u64 m) {",
      "        mod = m;",
      "        n2 = -u128(m) % m;",
      "        r = get_r();",
      "        assert(r * mod == 1);",
      "      }",
      "      modint64(): a(0) {}",
      "      modint64(const i64 &b): a(reduce((u128(b) + mod) * n2)) {}",
      "",
      "      modint64 &operator+=(const modint64 &b) {",
      "        if (i64(a += b.a - 2 * mod) < 0)",
      "          a += 2 * mod;",
      "        return *this;",
      "      }",
      "",
      "      modint64 &operator-=(const modint64 &b) {",
      "        if (i64(a -= b.a) < 0)",
      "          a += 2 * mod;",
      "        return *this;",
      "      }",
      "",
      "      modint64 &operator*=(const modint64 &b) {",
      "        a = reduce(u128(a) * b.a);",
      "        return *this;",
      "      }",
      "",
      "      modint64 &operator/=(const modint64 &b) {",
      "        *this *= b.inverse();",
      "        return *this;",
      "      }",
      "",
      "      modint64 operator+(const modint64 &b) const {",
      "        return modint64(*this) += b;",
      "      }",
      "      modint64 operator-(const modint64 &b) const {",
      "        return modint64(*this) -= b;",
      "      }",
      "      modint64 operator*(const modint64 &b) const {",
      "        return modint64(*this) *= b;",
      "      }",
      "      modint64 operator/(const modint64 &b) const {",
      "        return modint64(*this) /= b;",
      "      }",
      "",
      "      modint64 pow(u128 n) const {",
      "        modint64 ret(1), mul(*this);",
      "        while (n > 0) {",
      "          if (n & 1)",
      "            ret *= mul;",
      "          mul *= mul;",
      "          n >>= 1;",
      "        }",
      "        return ret;",
      "      }",
      "",
      "      modint64 inverse() const {",
      "        return pow(mod - 2);",
      "      }",
      "",
      "      u64 val() const {",
      "        u64 ret = reduce(a);",
      "        return ret >= mod ? ret - mod : ret;",
      "      }",
      "",
      "      static u64 get_mod() {",
      "        return mod;",
      "      }",
      "",
      "    private:",
      "      u64 a;",
      "",
      "      static u64 get_r() {",
      "        u64 ret = mod;",
      "        for (int i = 0; i < 5; i++)",
      "          ret *= 2 - mod * ret;",
      "        return ret;",
      "      }",
      "",
      "      static u64 reduce(const u128 &b) {",
      "        return (b + u128(u64(b) * u64(-r)) * mod) >> 64;",
      "      }",
      "    };",
      "    typename modint64::u64 modint64::mod, modint64::r, modint64::n2;",
      "",
      "    u64 rnd() {",
      "      static u64 x = 10150724397891781847ull;",
      "      x ^= x << 7;",
      "      return x ^= x >> 9;",
      "    }",
      "",
      "    bool is_prime(const u64 n) {",
      "      if (~n & 1)",
      "        return n == 2;",
      "      if (n < (1ll << 30))",
      "        return atcoder::internal::is_prime_constexpr(n);",
      "      u64 d = n - 1;",
      "      while (~d & 1)",
      "        d >>= 1;",
      "      if (modint64::get_mod() != n)",
      "        modint64::set_mod(n);",
      "      for (const u64 a: { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 }) {",
      "        if (n <= a)",
      "          break;",
      "        modint64 t = d, y = modint64(a).pow(d);",
      "        while (t.val() != n - 1 and y.val() != 1 and y.val() != n - 1) {",
      "          y *= y;",
      "          t *= 2;",
      "        }",
      "        if (y.val() != n - 1 and ~t.val() & 1)",
      "          return false;",
      "      }",
      "      return true;",
      "    }",
      "",
      "    u64 pollard_rho(const u64 n) {",
      "      if (~n & 1)",
      "        return 2;",
      "      if (is_prime(n))",
      "        return n;",
      "      if (modint64::get_mod() != n)",
      "        modint64::set_mod(n);",
      "      modint64 R, one = 1;",
      "      auto f = [&](modint64 x) {",
      "        return x * x + R;",
      "      };",
      "      auto rng = [&]() {",
      "        return rnd() % (n - 2) + 2;",
      "      };",
      "      for (;;) {",
      "        modint64 x, y(rng()), ys, q = one;",
      "        R = rng();",
      "        u64 g = 1;",
      "        constexpr int m = 128;",
      "        for (int r = 1; g == 1; r <<= 1) {",
      "          x = y;",
      "          for (int i = 0; i < r; i++)",
      "            y = f(y);",
      "          for (int k = 0; g == 1 and k < r; k += m) {",
      "            ys = y;",
      "            for (int i = 0; i < m and i < r - k; i++)",
      "              q *= x - (y = f(y));",
      "            g = gcd_fast(q.val(), n);",
      "          }",
      "        }",
      "        if (g == n)",
      "          do",
      "            g = gcd_fast((x - (ys = f(ys))).val(), n);",
      "          while (g == 1);",
      "        if (g != n)",
      "          return g;",
      "      }",
      "      exit(1);",
      "    }",
      "",
      "    std::vector<u64> factorize(const u64 n) {",
      "      if (n == 1)",
      "        return {};",
      "      if (is_prime(n))",
      "        return { n };",
      "      auto d = pollard_rho(n);",
      "      auto res = factorize(d);",
      "      auto sub = factorize(n / d);",
      "      std::copy(sub.begin(), sub.end(), std::back_inserter(res));",
      "      return res;",
      "    }",
      "",
      "  }; // namespace inner",
      "  using inner::is_prime;",
      "",
      "  template <typename ll>",
      "  std::vector<ll> fast_factorize(const ll n) {",
      "    auto tmp = inner::factorize(n);",
      "    std::vector<ll> res{ tmp.begin(), tmp.end() };",
      "    std::sort(res.begin(), res.end());",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of fast_factorize",
    "scope": "cpp"
  },
  "divisor-table.hpp": {
    "prefix": "cppdivisor_table",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  struct DivisorTable {",
      "    vector<int> smallest_ps;",
      "    DivisorTable(int N): smallest_ps(N + 1, 1) {}",
      "",
      "    void build() {",
      "      int N = smallest_ps.size();",
      "      for (long long i = 2; i <= N; i++) {",
      "        if (smallest_ps[i] != 1)",
      "          continue;",
      "        smallest_ps[i] = i;",
      "        for (long long j = i * i; j <= N; j += i) {",
      "          if (smallest_ps[j] != 1)",
      "            continue;",
      "          smallest_ps[j] = i;",
      "        }",
      "      }",
      "    }",
      "",
      "    // M := count({ p = prime, p|x })",
      "    // O(M2^M log x)",
      "    vector<int> divisor(int x) {",
      "      vector<int> ps;",
      "      while (smallest_ps[x] != 1) {",
      "        ps.push_back(smallest_ps[x]);",
      "        x /= smallest_ps[x];",
      "      }",
      "      int m = ps.size();",
      "      vector<int> ds(1 << m);",
      "      for (int i = 0; i < (1 << m); i++) {",
      "        int prod = 1;",
      "        for (int j = 0; j < m; j++) {",
      "          if (i >> j & 1)",
      "            prod *= ps[j];",
      "        }",
      "        ds[i] = prod;",
      "      }",
      "      return ds;",
      "    }",
      "",
      "    bool is_prime(int k) {",
      "      if (k <= 1)",
      "        return false;",
      "      return smallest_ps[k] == k;",
      "    }",
      "",
      "    int operator[](int i) {",
      "      return smallest_ps[i];",
      "    }",
      "  };",
      "} // namespace math_library"
    ],
    "description": "Template of divisor_table",
    "scope": "cpp"
  },
  "alternative-totient-table.hpp": {
    "prefix": "cppalternative_totient_table",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "",
      "#include <cstdint>",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  vector<int> count_factor(int N) {",
      "    constexpr int INF = INT32_MAX / 2;",
      "    vector<int> table(N + 1, 0);",
      "",
      "    for (int i = 2; i <= N; i++) {",
      "      if (table[i])",
      "        continue;",
      "      table[i] = 1;",
      "      for (int j = 2 * i; j <= N; j += i) {",
      "        if (j % (i * i) == 0)",
      "          table[j] = -INF;",
      "        else",
      "          table[j]++;",
      "      }",
      "    }",
      "    return table;",
      "  }",
      "} // namespace math_library",
      "",
      "",
      "namespace math_library {",
      "  // Θ(NloglogN)",
      "  vector<int> alternative_totient_table(int N) {",
      "    vector<int> table = count_factor(N);",
      "",
      "    vector<int> alt(N + 1, 0);",
      "    alt[1] = N;",
      "    for (int i = 2; i <= N; i++) {",
      "      alt[i] = N - i;",
      "    }",
      "",
      "    for (int i = 2; i <= N; i++) {",
      "      if (table[i] < 0)",
      "        continue;",
      "",
      "      for (int j = i; j < N; j += i) {",
      "        if (table[i] % 2) {",
      "          alt[j] -= (N - j) / i;",
      "        } else {",
      "          alt[j] += (N - j) / i;",
      "        }",
      "      }",
      "    }",
      "    return alt;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of alternative_totient_table",
    "scope": "cpp"
  },
  "ceil-div.hpp": {
    "prefix": "cppceil_div",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <cassert>",
      "",
      "namespace math_library {",
      "  constexpr ll ceil_div(ll n, ll d) {",
      "    assert(d != 0);",
      "    return n / d + (((n ^ d) >= 0) and (n % d));",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of ceil_div",
    "scope": "cpp"
  },
  "factorize-table.hpp": {
    "prefix": "cppfactorize_table",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  struct FactorizeTable {",
      "    vector<int> ps;",
      "    FactorizeTable(int N): ps(N + 1, 1) {}",
      "",
      "    void build() {",
      "      int N = ps.size();",
      "      for (ll i = 2; i <= N; i++) {",
      "        if (ps[i] != 1)",
      "          continue;",
      "        ps[i] = i;",
      "        for (ll j = i * i; j <= N; j += i) {",
      "          if (ps[j] != 1)",
      "            continue;",
      "          ps[j] = i;",
      "        }",
      "      }",
      "    }",
      "",
      "    vector<int> factorize(int x) {",
      "      vector<int> res;",
      "      while (ps[x] != 1) {",
      "        res.push_back(ps[x]);",
      "        x /= ps[x];",
      "      }",
      "      return res;",
      "    }",
      "",
      "    bool is_prime(int k) {",
      "      if (k <= 1)",
      "        return false;",
      "      return ps[k] == k;",
      "    }",
      "",
      "    int operator[](int i) {",
      "      return ps[i];",
      "    }",
      "  };",
      "} // namespace math_library"
    ],
    "description": "Template of factorize_table",
    "scope": "cpp"
  },
  "mod-factorial.hpp": {
    "prefix": "cppmod_factorial",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  using mint = atcoder::modint1000000007;",
      "  template <typename ModInt = mint>",
      "  class ModFactorial {",
      "    vector<ModInt> fact, invfact;",
      "",
      "    int min_pow2_greater_equal_than(int k) {",
      "      int pow2 = 1;",
      "      while (pow2 < k) {",
      "        pow2 <<= 1;",
      "      }",
      "      return pow2;",
      "    }",
      "",
      "  public:",
      "    ModFactorial(): fact(1, 1), invfact(1, 1) {}",
      "",
      "    ModInt factorial(int k) {",
      "      if (k < 0)",
      "        return 0;",
      "      if (k < static_cast<int>(fact.size()))",
      "        return fact[k];",
      "",
      "      int pow2 = min_pow2_greater_equal_than(k);",
      "      int old_size = fact.size();",
      "      fact.resize(pow2 + 1);",
      "",
      "      for (int i = old_size - 1; i < pow2; i++) {",
      "        fact[i + 1] = fact[i] * ModInt(i + 1);",
      "      }",
      "      return fact[k];",
      "    }",
      "",
      "    ModInt inv_factorial(int k) {",
      "      if (k < 0)",
      "        return 0;",
      "      if (k < static_cast<int>(invfact.size()))",
      "        return invfact[k];",
      "",
      "      int pow2 = min_pow2_greater_equal_than(k);",
      "      int old_size = fact.size();",
      "      invfact.resize(pow2 + 1);",
      "",
      "      invfact[pow2] = ModInt(1) / factorial(pow2);",
      "      for (int i = pow2; i > old_size; i--) {",
      "        invfact[i - 1] = invfact[i] * ModInt(i);",
      "      }",
      "      return invfact[k];",
      "    }",
      "",
      "    ModInt inv(int k) {",
      "      return ModInt(1) / ModInt(k);",
      "    }",
      "",
      "    ModInt permutation(int n, int k) {",
      "      return factorial(n) * inv_factorial(n - k);",
      "    }",
      "    ModInt combination(int n, int k) {",
      "      return factorial(n) * inv_factorial(k) * inv_factorial(n - k);",
      "    }",
      "    ModInt homogeneous(int n, int k) {",
      "      return combination(n + k - 1, k);",
      "    }",
      "  };",
      "} // namespace math_library"
    ],
    "description": "Template of mod_factorial",
    "scope": "cpp"
  },
  "partition-table.hpp": {
    "prefix": "cpppartition_table",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  template <typename T>",
      "  vector<vector<T>> PartitionTable(int n, int k) {",
      "    vector<vector<T>> dp(n + 1, vector<T>(k + 1));",
      "    dp[0][0] = 1;",
      "    for (int i = 0; i <= n; i++) {",
      "      for (int j = 1; j <= k; j++) {",
      "        if (i - j >= 0)",
      "          dp[i][j] = dp[i][j - 1] + dp[i - j][j];",
      "        else",
      "          dp[i][j] = dp[i][j - 1];",
      "      }",
      "    }",
      "    return dp;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of partition_table",
    "scope": "cpp"
  },
  "lucas-combination.hpp": {
    "prefix": "cpplucas_combination",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  struct LucasCombination {",
      "    vector<vector<ll>> data;",
      "    int MOD;",
      "    LucasCombination(int MOD_) {",
      "      MOD = MOD_;",
      "      data.assign(MOD + 1, vector<ll>(MOD + 1, 0));",
      "      data[0][0] = 1;",
      "      for (int i = 0; i < MOD; i++) {",
      "        for (int j = 0; j <= i; j++) {",
      "          data[i + 1][j] += data[i][j];",
      "          data[i + 1][j] %= MOD;",
      "          data[i + 1][j + 1] += data[i][j];",
      "          data[i + 1][j + 1] %= MOD;",
      "        }",
      "      }",
      "    }",
      "",
      "    ll query(int n, int r) {",
      "      ll res = 1;",
      "      while (n > 0) {",
      "        int ni = n % MOD;",
      "        int ri = r % MOD;",
      "        res *= data[ni][ri];",
      "        res %= MOD;",
      "        n /= MOD;",
      "        r /= MOD;",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace math_library"
    ],
    "description": "Template of lucas_combination",
    "scope": "cpp"
  },
  "convert-base.hpp": {
    "prefix": "cppconvert_base",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  // from-ary n -> to-ary n",
      "  template <typename T>",
      "  vector<T> convert_base(vector<T> n, T from, T to) {",
      "    auto to_base = [&](T n, T b) {",
      "      if (n == 0 or b <= 1)",
      "        return vector<T>{ 0 };",
      "      vector<T> res;",
      "      for (; n > 0; n /= b) {",
      "        res.emplace_back(n % b);",
      "      }",
      "      reverse(res.begin(), res.end());",
      "      return res;",
      "    };",
      "",
      "    auto to_decimal = [&](vector<T> n, T b) {",
      "      T res = 0, x = 1;",
      "      for (int i = n.size() - 1; i >= 0; i--, x *= b) {",
      "        res += x * (n[i]);",
      "      }",
      "      return res;",
      "    };",
      "",
      "    T temp = to_decimal(n, from);",
      "    return to_base(temp, to);",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of convert_base",
    "scope": "cpp"
  },
  "totient-table.hpp": {
    "prefix": "cpptotient_table",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  vector<int> totient_table(int n) {",
      "    vector<int> euler(n + 1);",
      "    for (int i = 0; i <= n; i++) {",
      "      euler[i] = i;",
      "    }",
      "    for (int i = 2; i <= n; i++) {",
      "      if (euler[i] == i) {",
      "        for (int j = i; j <= n; j += i) {",
      "          euler[j] = euler[j] / i * (i - 1);",
      "        }",
      "      }",
      "    }",
      "    return euler;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of totient_table",
    "scope": "cpp"
  },
  "is-prime.hpp": {
    "prefix": "cppis_prime",
    "body": [
      "namespace math_library {",
      "  constexpr bool is_prime(int n) {",
      "    if (n <= 1)",
      "      return false;",
      "    for (int i = 2; i * i <= n; i++) {",
      "      if (n % i == 0)",
      "        return false;",
      "    }",
      "    return true;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of is_prime",
    "scope": "cpp"
  },
  "fibonacci.hpp": {
    "prefix": "cppfibonacci",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "// WIP",
      "",
      "namespace math_library {",
      "  template <typename T>",
      "  struct matrix {",
      "    vector<vector<T>> dat;",
      "",
      "    matrix(int r, int c): dat(r, vector<T>(c, 0)) {}",
      "    matrix(vector<vector<T>> _dat): dat(_dat) {}",
      "",
      "    size_t size() const {",
      "      return dat.size();",
      "    }",
      "    bool empty() const {",
      "      return dat.empty();",
      "    }",
      "  };",
      "",
      "  long long fibonacci(long long n) {",
      "    long long f0 = 1, f1 = 1;",
      "    // {(1,1),(1,0)}",
      "",
      "",
      "    // if ( p <= 1 ) return 0;",
      "    // if ( p == 0 ) p = numeric_limits<T>::max();",
      "    // T res = 1;",
      "    // while ( e > 0 ) {",
      "    //   if ( e & 1 ) res = (res * a) % p;",
      "    //   a = (a * a) % p;",
      "    //   e >>= 1;",
      "    // }",
      "    // return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of fibonacci",
    "scope": "cpp"
  },
  "binomial.hpp": {
    "prefix": "cppbinomial",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "namespace math_library {",
      "  constexpr ll binomial(ll n, ll r) {",
      "    ll res = 1;",
      "    for (ll i = 0; i < r; i++) {",
      "      res *= n - i;",
      "      res /= i + 1;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of binomial",
    "scope": "cpp"
  },
  "segment-sieve.hpp": {
    "prefix": "cppsegment_sieve",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <cassert>",
      "#include <cmath>",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  class SegmentSieve {",
      "    ll l, r, sqrt_r;",
      "    vector<int> small_sieve;",
      "    vector<vector<ll>> large_sieve;",
      "    vector<ll> aux; // aux[i] := large_sieve[i] の素因数の積",
      "",
      "  public:",
      "    SegmentSieve(ll l, ll r): l(l), r(r), sqrt_r(sqrt(r) + 1) {",
      "      small_sieve.resize(sqrt_r);",
      "      iota(small_sieve.begin(), small_sieve.end(), 0);",
      "      large_sieve.resize(r - l);",
      "      aux.assign(r - l, 1);",
      "",
      "      for (ll i = 2; i * i < r; i++) {",
      "        if (small_sieve[i] < i)",
      "          continue;",
      "",
      "        small_sieve[i] = i;",
      "        for (ll j = i * i; j < sqrt_r; j += i) {",
      "          if (small_sieve[j] == j)",
      "            small_sieve[j] = i;",
      "        }",
      "",
      "        ll begin = (l + i - 1) / i * i;",
      "",
      "        for (ll j = begin; j < r; j += i) {",
      "          ll k = j;",
      "          do {",
      "            // aux[j - l] > sqrt_r ?",
      "            if (aux[j - l] * aux[j - l] > r)",
      "              break;",
      "",
      "            large_sieve[j - l].push_back(i);",
      "            aux[j - l] *= i;",
      "            k /= i;",
      "          } while (k % i == 0);",
      "        }",
      "      }",
      "    }",
      "",
      "    vector<ll> factor(ll n) {",
      "      assert(l <= n and n < r);",
      "",
      "      vector<ll> res = large_sieve[n - l];",
      "      n /= aux[n - l];",
      "",
      "      if (n >= sqrt_r) {",
      "        res.push_back(n);",
      "        return res;",
      "      }",
      "",
      "      while (n > 1) {",
      "        res.push_back(small_sieve[n]);",
      "        n /= small_sieve[n];",
      "      }",
      "",
      "      return res;",
      "    }",
      "  };",
      "}; // namespace math_library"
    ],
    "description": "Template of segment_sieve",
    "scope": "cpp"
  },
  "to-base.hpp": {
    "prefix": "cppto_base",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  // decimal n -> b-ary",
      "  template <typename T>",
      "  vector<T> to_base(T n, T b) {",
      "    if (n == 0 or b <= 1)",
      "      return vector<T>{ 0 };",
      "    vector<T> res;",
      "    for (; n > 0; n /= b) {",
      "      res.emplace_back(n % b);",
      "    }",
      "    reverse(res.begin(), res.end());",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of to_base",
    "scope": "cpp"
  },
  "totient.hpp": {
    "prefix": "cpptotient",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "namespace math_library {",
      "  constexpr ll totient(ll n) {",
      "    ll res = n;",
      "    for (ll i = 2; i * i <= n; i++) {",
      "      if (n % i == 0) {",
      "        res -= res / i;",
      "        while (n % i == 0)",
      "          n /= i;",
      "      }",
      "    }",
      "    if (n > 1)",
      "      res -= res / n;",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of totient",
    "scope": "cpp"
  },
  "matrix.hpp": {
    "prefix": "cppmatrix",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <cassert>",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  template <typename T>",
      "  class Matrix {",
      "    int row_, column_;",
      "    vector<vector<T>> matrix_;",
      "",
      "  public:",
      "    Matrix() = default;",
      "    Matrix(const vector<vector<T>> &matrix): matrix_(matrix) {",
      "      if (matrix.empty()) {",
      "        row_ = 0;",
      "        column_ = 0;",
      "        return;",
      "      }",
      "",
      "      row_ = matrix_.size();",
      "      column_ = matrix.at(0).size();",
      "",
      "      for (const vector<T> &line: matrix) {",
      "        int col = line.size();",
      "        assert(col == column_);",
      "      }",
      "    }",
      "",
      "    int row() const {",
      "      return row_;",
      "    }",
      "",
      "    int column() const {",
      "      return column_;",
      "    }",
      "",
      "    constexpr Matrix pow(long long n) const {",
      "      assert(n >= 0);",
      "",
      "      Matrix x = /* base = */ *this;",
      "      Matrix res(vector<vector<T>>(row_, vector<T>(column_, /*product identity element=*/T(1))));",
      "",
      "      while (n) {",
      "        if (n & 1) {",
      "          res *= x;",
      "        }",
      "        x *= x;",
      "        n >>= 1;",
      "      }",
      "      return res;",
      "    }",
      "",
      "    vector<vector<T>> matrix() const {",
      "      return matrix_;",
      "    }",
      "",
      "    constexpr Matrix &operator+=(const Matrix &rhs) {",
      "      assert(row_ == rhs.row_);",
      "      assert(column_ == rhs.column_);",
      "",
      "      for (int i = 0; i < row_; i++) {",
      "        for (int j = 0; j < column_; j++) {",
      "          matrix_.at(i).at(j) += rhs.matrix_.at(i).at(j);",
      "        }",
      "      }",
      "      return matrix_;",
      "    }",
      "",
      "    constexpr Matrix &operator-=(const Matrix &rhs) {",
      "      assert(row_ == rhs.row_);",
      "      assert(column_ == rhs.column_);",
      "",
      "      for (int i = 0; i < row_; i++) {",
      "        for (int j = 0; j < column_; j++) {",
      "          matrix_.at(i).at(j) -= rhs.matrix_.at(i).at(j);",
      "        }",
      "      }",
      "      return matrix_;",
      "    }",
      "",
      "    constexpr Matrix &operator*=(const Matrix &rhs) {",
      "      assert(column_ == rhs.row_);",
      "",
      "      vector<vector<T>> prod(row_, vector<T>(rhs.column_, /*additive identity element=*/T(0)));",
      "",
      "      // https://qiita.com/ageprocpp/items/7bda728d109c953ece3c",
      "      for (int i = 0; i < row_; i++) {",
      "        for (int k = 0; k < column_; k++) {",
      "          for (int j = 0; j < rhs.column_; j++) {",
      "            prod.at(i).at(j) += matrix_.at(i).at(k) * rhs.matrix_.at(k).at(j);",
      "          }",
      "        }",
      "      }",
      "",
      "      return matrix_ = prod;",
      "    }",
      "",
      "    const Matrix &operator*=(const T &scalar) {",
      "      for (int i = 0; i < row_; i++) {",
      "        for (int j = 0; j < column_; j++) {",
      "          matrix_.at(i).at(j) *= scalar;",
      "        }",
      "      }",
      "      return matrix_;",
      "    }",
      "",
      "    constexpr Matrix operator+() const {",
      "      return *this;",
      "    }",
      "",
      "    constexpr Matrix operator-() const {",
      "      return Matrix(this->matrix_) - *this;",
      "    }",
      "",
      "    constexpr friend Matrix operator+(const Matrix &lhs, const Matrix &rhs) {",
      "      return Matrix(lhs) += rhs;",
      "    }",
      "",
      "    constexpr friend Matrix operator-(const Matrix &lhs, const Matrix &rhs) {",
      "      return Matrix(lhs) -= rhs;",
      "    }",
      "",
      "    constexpr friend Matrix operator*(const Matrix &lhs, const Matrix &rhs) {",
      "      return Matrix(lhs) *= rhs;",
      "    }",
      "",
      "    constexpr friend bool operator==(const Matrix &lhs, const Matrix &rhs) {",
      "      return lhs.matrix_ == rhs.matrix_;",
      "    }",
      "",
      "    constexpr friend bool operator!=(const Matrix &lhs, const Matrix &rhs) {",
      "      return lhs.matrix_ != rhs.matrix_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const Matrix &rhs) {",
      "      for (int i = 0; i < rhs.row_; i++) {",
      "        for (int j = 0; j < rhs.column_; j++) {",
      "          os << rhs.matrix_.at(i).at(j);",
      "          os << (j == rhs.column_ - 1 ? \"\\n\" : \" \");",
      "        }",
      "      }",
      "      return os;",
      "    }",
      "  };",
      "} // namespace math_library"
    ],
    "description": "Template of matrix",
    "scope": "cpp"
  },
  "floor-div.hpp": {
    "prefix": "cppfloor_div",
    "body": [
      "namespace math_library {",
      "  template <typename T>",
      "  constexpr T floor_div(T n, T d) {",
      "    assert(d != 0);",
      "    return n / d - (((n ^ d) < 0) and (n % d));",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of floor_div",
    "scope": "cpp"
  },
  "power.hpp": {
    "prefix": "cpppower",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "",
      "namespace math_library {",
      "  constexpr ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "    if (b == 0) {",
      "      x = 1;",
      "      y = 0;",
      "      return a;",
      "    }",
      "    ll d = extgcd(b, a % b, y, x);",
      "    y = y - (a / b) * x;",
      "    return d;",
      "  }",
      "} // namespace math_library",
      "",
      "#include <cassert>",
      "#include <numeric>",
      "",
      "namespace math_library {",
      "  // verify:AOJ_NTL_1_B",
      "  constexpr ll power(ll a, ll e, ll p = -1) {",
      "    assert(p != 0);",
      "    assert(p >= -1);",
      "",
      "    if (e < 0) {",
      "      assert(p != -1 and gcd(a, p) == 1);",
      "      ll x, y;",
      "      extgcd(a, p, x, y);",
      "      a = (x % p + p) % p;",
      "      e *= -1;",
      "    }",
      "",
      "    ll res = 1;",
      "    while (e > 0) {",
      "      if (e & 1) {",
      "        res *= a;",
      "        if (p != -1)",
      "          res %= p;",
      "      }",
      "      a *= a;",
      "      if (p != -1)",
      "        a %= p;",
      "      e >>= 1;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of power",
    "scope": "cpp"
  },
  "binomial-table.hpp": {
    "prefix": "cppbinomial_table",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  template <typename T>",
      "  struct BinomialTable {",
      "    vector<vector<T>> data;",
      "    BinomialTable(int N) {",
      "      data.assign(N + 1, vector<T>(N + 1, 0));",
      "      data[0][0] = 1;",
      "      for (int i = 0; i < N; i++) {",
      "        for (int j = 0; j <= i; j++) {",
      "          data[i + 1][j] += data[i][j];",
      "          data[i + 1][j + 1] += data[i][j];",
      "        }",
      "      }",
      "    }",
      "",
      "    T query(int n, int r) {",
      "      return data[n][r];",
      "    }",
      "  };",
      "} // namespace math_library"
    ],
    "description": "Template of binomial_table",
    "scope": "cpp"
  },
  "factorize.hpp": {
    "prefix": "cppfactorize",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  vector<ll> factorize(ll n) {",
      "    vector<ll> res;",
      "    for (ll i = 2; i * i <= n; i++) {",
      "      while (n % i == 0) {",
      "        res.emplace_back(i);",
      "        n /= i;",
      "      }",
      "    }",
      "    if (n > 1)",
      "      res.emplace_back(n);",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of factorize",
    "scope": "cpp"
  },
  "alternative-totient.hpp": {
    "prefix": "cppalternative_totient",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "#include <vector>",
      "",
      "namespace math_library {",
      "  vector<ll> factorize(ll n) {",
      "    vector<ll> res;",
      "    for (ll i = 2; i * i <= n; i++) {",
      "      while (n % i == 0) {",
      "        res.emplace_back(i);",
      "        n /= i;",
      "      }",
      "    }",
      "    if (n > 1)",
      "      res.emplace_back(n);",
      "    return res;",
      "  }",
      "} // namespace math_library",
      "",
      "#include <algorithm>",
      "",
      "namespace math_library {",
      "  long long alternative_totient(long long x, long long n) {",
      "    if (x == 1)",
      "      return n;",
      "    auto ps = factorize(x);",
      "    ps.erase(unique(ps.begin(), ps.end()), ps.end());",
      "    int k = ps.size();",
      "    long long res = n - x;",
      "    for (int i = 1; i < (1 << k); i++) {",
      "      long long prod = 1;",
      "      int cnt = 0;",
      "      for (int j = 0; j < k; j++) {",
      "        if (i >> j & 1) {",
      "          prod *= ps[j];",
      "          cnt++;",
      "        }",
      "      }",
      "      if (cnt % 2) {",
      "        res += (n - x) / prod;",
      "      } else {",
      "        res -= (n - x) / prod;",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of alternative_totient",
    "scope": "cpp"
  },
  "extgcd.hpp": {
    "prefix": "cppextgcd",
    "body": [
      "namespace math_library {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math_library",
      "",
      "namespace math_library {",
      "  constexpr ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "    if (b == 0) {",
      "      x = 1;",
      "      y = 0;",
      "      return a;",
      "    }",
      "    ll d = extgcd(b, a % b, y, x);",
      "    y = y - (a / b) * x;",
      "    return d;",
      "  }",
      "} // namespace math_library"
    ],
    "description": "Template of extgcd",
    "scope": "cpp"
  },
  "rolling-hash.hpp": {
    "prefix": "cpprolling_hash",
    "body": [],
    "description": "Template of rolling_hash",
    "scope": "cpp"
  },
  "substr.hpp": {
    "prefix": "cppsubstr",
    "body": [
      "namespace string_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "",
      "namespace string_library {",
      "  string substr(const string &s, int l, int r) {",
      "    string res = \"\";",
      "    for (int i = l; i < r; i++) {",
      "      res += s[i];",
      "    }",
      "    return res;",
      "  }",
      "} // namespace string_library"
    ],
    "description": "Template of substr",
    "scope": "cpp"
  },
  "rolling-hash-2d.hpp": {
    "prefix": "cpprolling_hash_2d",
    "body": [
      "namespace string_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace string_library {",
      "  // verify:AOJ_ALDS1_14_C",
      "  // recomend:{ MOD:2^61-1, base1,base2:random }",
      "  struct RollingHash2D {",
      "    using i128 = __int128_t;",
      "    using ll = long long;",
      "    ll mod, base1, base2;",
      "    struct CumulativeSum2D {",
      "      vector<vector<ll>> data;",
      "      CumulativeSum2D() {}",
      "",
      "      void set(int y, int x, ll v) {",
      "        data[y + 1][x + 1] = v;",
      "      }",
      "",
      "      void build(ll mod) {",
      "        for (int i = 1; i < static_cast<int>(data.size()); i++) {",
      "          for (int j = 1; j < static_cast<int>(data[i].size()); j++) {",
      "            data[i][j] += (data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1]) % mod;",
      "            if (data[i][j] < 0)",
      "              data[i][j] += mod;",
      "          }",
      "        }",
      "      }",
      "",
      "      // [ (sy,sx), (gy,gx) )",
      "      ll query(int sy, int sx, int gy, int gx, ll mod) {",
      "        ll res = (data[gy][gx] - data[gy][sx] - data[sy][gx] + data[sy][sx]) % mod;",
      "        if (res < 0)",
      "          res += mod;",
      "        return res;",
      "      }",
      "    };",
      "",
      "    CumulativeSum2D sum;",
      "    vector<vector<ll>> dat, inv;",
      "    RollingHash2D(const vector<vector<ll>> &vs, ll B1 = (int)1e9 + 7, ll B2 = (int)1e8 + 7, ll MOD = (1LL << 61) - 1): dat(vs) {",
      "      set_base(B1, B2);",
      "      set_mod(MOD);",
      "    }",
      "    RollingHash2D(const vector<string> &s, ll B1 = (int)1e9 + 7, ll B2 = (int)1e8 + 7, ll MOD = (1LL << 61) - 1) {",
      "      set_base(B1, B2);",
      "      set_mod(MOD);",
      "      dat.resize(s.size());",
      "      for (int i = 0; i < static_cast<int>(s.size()); i++) {",
      "        for (char c: s[i]) {",
      "          dat[i].emplace_back(c);",
      "        }",
      "      }",
      "    }",
      "",
      "    void set_mod(ll M) {",
      "      mod = M;",
      "    }",
      "    void set_base(ll B1, ll B2) {",
      "      base1 = B1, base2 = B2;",
      "    }",
      "",
      "    // mod multiprecation",
      "    ll mod_mul(ll a, ll b) {",
      "      i128 res = a;",
      "      res *= b;",
      "      res = (res >> 61) + (res & mod);",
      "      if (res >= mod)",
      "        res -= mod;",
      "      return (ll)res;",
      "    }",
      "",
      "    ll pow(ll a, i128 e) {",
      "      if (e == 0)",
      "        return 1;",
      "      if (e % 2 == 0) {",
      "        ll res = pow(a, e / 2);",
      "        return mod_mul(res, res);",
      "      }",
      "      return mod_mul(pow(a, e - 1), a);",
      "    }",
      "",
      "    void build() {",
      "      int h = dat.size(), w = dat[0].size();",
      "      inv.assign(h + 1, vector<ll>(w + 1, 0));",
      "      sum.data.assign(h + 1, vector<ll>(w + 1, 0));",
      "      vector<ll> pow_table1(h + 1), pow_table2(w + 1);",
      "",
      "      i128 e = mod - 2;",
      "      inv[h][w] = mod_mul(pow(base1, h * e), pow(base2, w * e));",
      "      pow_table1[0] = 1;",
      "      pow_table2[0] = 1;",
      "",
      "      for (int i = h - 1; i >= 0; i--) {",
      "        pow_table1[h - i] = mod_mul(base1, pow_table1[h - i - 1]);",
      "        inv[i][w] = mod_mul(base1, inv[i + 1][w]);",
      "      }",
      "      for (int j = w - 1; j >= 0; j--) {",
      "        pow_table2[w - j] = mod_mul(base2, pow_table2[w - j - 1]);",
      "        inv[h][j] = mod_mul(base2, inv[h][j + 1]);",
      "      }",
      "      for (int i = h - 1; i >= 0; i--) {",
      "        for (int j = w - 1; j >= 0; j--) {",
      "          inv[i][j] = mod_mul(inv[i + 1][j + 1], base1);",
      "          inv[i][j] = mod_mul(inv[i][j], base2);",
      "        }",
      "      }",
      "      for (int i = 0; i < h; i++) {",
      "        for (int j = 0; j < w; j++) {",
      "          ll val = mod_mul(dat[i][j], pow_table1[i]);",
      "          val = mod_mul(val, pow_table2[j]);",
      "          sum.set(i, j, val);",
      "        }",
      "      }",
      "      sum.build(mod);",
      "    }",
      "",
      "    ll find(int sy, int sx, int gy, int gx) {",
      "      return mod_mul(sum.query(sy, sx, gy, gx, mod), inv[sy][sx]);",
      "    }",
      "  };",
      "} // namespace string_library"
    ],
    "description": "Template of rolling_hash_2d",
    "scope": "cpp"
  },
  "split.hpp": {
    "prefix": "cppsplit",
    "body": [
      "namespace string_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace string_library {",
      "  vector<string> split(const string &str, const string &sep, const int &max_split = INT32_MAX) {",
      "    vector<string> res;",
      "    string t = \"\";",
      "    int cnt_split = 0;",
      "    for (auto c: str) {",
      "      if (sep.find(c) == string::npos or cnt_split >= max_split) {",
      "        t += c;",
      "        continue;",
      "      }",
      "      res.emplace_back(t);",
      "      t = \"\";",
      "      cnt_split++;",
      "    }",
      "    if (t != \"\")",
      "      res.emplace_back(t);",
      "    return res;",
      "  }",
      "} // namespace string_library"
    ],
    "description": "Template of split",
    "scope": "cpp"
  },
  "join.hpp": {
    "prefix": "cppjoin",
    "body": [
      "namespace string_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace string_library {",
      "  string join(const vector<string> &strs, const string &sep) {",
      "    string res = \"\";",
      "    for (int i = 0; i < static_cast<int>(strs.size()); i++) {",
      "      if (i)",
      "        res += sep;",
      "      res += strs[i];",
      "    }",
      "    return res;",
      "  }",
      "} // namespace string_library"
    ],
    "description": "Template of join",
    "scope": "cpp"
  },
  "huffman.hpp": {
    "prefix": "cpphuffman",
    "body": [
      "namespace graph_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace graph_library {",
      "  template <class T>",
      "  class EdgeInterface {",
      "    // TODO: Do implement constructor",
      "    // UnWeightedEdge(from, to)",
      "    // WeightedEdge  (from, to, cost)",
      "  public:",
      "    int &from() {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    const int &from() const {",
      "      return static_cast<T &>(this)->from();",
      "    }",
      "",
      "    int &to() {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "",
      "    const int &to() const {",
      "      return static_cast<T &>(this)->to();",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  class WeightedEdge: public EdgeInterface<WeightedEdge<Cost>> {",
      "  private:",
      "    int from_, to_;",
      "    Cost cost_;",
      "",
      "  public:",
      "    WeightedEdge() = default;",
      "    WeightedEdge(int to): to_(to) {}",
      "    WeightedEdge(int to, Cost cost): to_(to), cost_(cost) {}",
      "    WeightedEdge(int from, int to, Cost cost): from_(from), to_(to), cost_(cost) {}",
      "",
      "    bool operator<(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ < rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ <= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ > rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const WeightedEdge<Cost> &rhs) const {",
      "      if (cost_ != rhs.cost_)",
      "        return cost_ >= rhs.cost_;",
      "",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const WeightedEdge<Cost> &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_ or cost_ != rhs.cost_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    Cost &cost() {",
      "      return cost_;",
      "    }",
      "",
      "    const Cost &cost() const {",
      "      return cost_;",
      "    }",
      "",
      "    template <typename T>",
      "    friend ostream &operator<<(ostream &os, const WeightedEdge<T> &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_ << ' ' << rhs.cost_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  class UnWeightedEdge: public EdgeInterface<UnWeightedEdge> {",
      "  private:",
      "    int from_, to_;",
      "",
      "  public:",
      "    UnWeightedEdge() = default;",
      "    UnWeightedEdge(int to_): to_(to_) {}",
      "    UnWeightedEdge(int from_, int to_): from_(from_), to_(to_) {}",
      "",
      "    bool operator<(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ < rhs.from_;",
      "",
      "      return to_ < rhs.to_;",
      "    }",
      "",
      "    bool operator<=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ <= rhs.from_;",
      "",
      "      return to_ <= rhs.to_;",
      "    }",
      "",
      "    bool operator>(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ > rhs.from_;",
      "",
      "      return to_ > rhs.to_;",
      "    }",
      "",
      "    bool operator>=(const UnWeightedEdge &rhs) const {",
      "      if (from_ != rhs.from_)",
      "        return from_ >= rhs.from_;",
      "",
      "      return to_ >= rhs.to_;",
      "    }",
      "",
      "    bool operator!=(const UnWeightedEdge &rhs) const {",
      "      return from_ != rhs.from_ or to_ != rhs.to_;",
      "    }",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const UnWeightedEdge &rhs) {",
      "      os << rhs.from_ << ' ' << rhs.to_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedEdges = vector<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedEdges = vector<UnWeightedEdge>;",
      "",
      "",
      "  template <class Edge, bool is_extended_edge = is_base_of_v<EdgeInterface<Edge>, Edge>>",
      "  class Graph {",
      "    static_assert(is_extended_edge, \"Edge is not extended edge interface class.\");",
      "  };",
      "",
      "  template <class Edge>",
      "  class Graph<Edge, true> {",
      "  public:",
      "    using Edges = vector<Edge>;",
      "",
      "  private:",
      "    Edges edges_;",
      "    vector<Edges> graph_;",
      "    int size_;",
      "",
      "  public:",
      "    Graph() = default;",
      "    Graph(int N): graph_(N), size_(N) {}",
      "",
      "    int size() const {",
      "      return size_;",
      "    }",
      "",
      "    void add_edge(const Edge &edge) {",
      "      const int &from = edge.from();",
      "      graph_.at(from).push_back(edge);",
      "      edges_.push_back(edge);",
      "    }",
      "",
      "    Edge get_edge(int k) const {",
      "      return edges_.at(k);",
      "    }",
      "",
      "    Edges edges() const {",
      "      return edges_;",
      "    }",
      "",
      "    void pop_back_edge() {",
      "      assert(not edges_.empty());",
      "",
      "      const Edge e = edges_.back();",
      "      edges_.pop_back();",
      "      graph_.at(e.from()).pop_back();",
      "    }",
      "",
      "    vector<Edges> graph() const {",
      "      return graph_;",
      "    }",
      "  };",
      "",
      "  template <typename Cost>",
      "  using WeightedGraph = Graph<WeightedEdge<Cost>>;",
      "",
      "  using UnWeightedGraph = Graph<UnWeightedEdge>;",
      "} // namespace graph_library",
      "",
      "namespace string_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <cstdint>",
      "#include <queue>",
      "#include <string>",
      "#include <unordered_map>",
      "#include <utility>",
      "",
      "namespace string_library {",
      "  class HuffmanEdge: public graph_library::EdgeInterface<HuffmanEdge> {",
      "    int from_, to_, bit_;",
      "",
      "  public:",
      "    HuffmanEdge() = default;",
      "    HuffmanEdge(int to): to_(to) {}",
      "    HuffmanEdge(int from, int to): from_(from), to_(to) {}",
      "    HuffmanEdge(int from, int to, int bit): from_(from), to_(to), bit_(bit) {}",
      "",
      "    int &from() {",
      "      return from_;",
      "    }",
      "",
      "    const int &from() const {",
      "      return from_;",
      "    }",
      "",
      "    int &to() {",
      "      return to_;",
      "    }",
      "",
      "    const int &to() const {",
      "      return to_;",
      "    }",
      "",
      "    int &bit() {",
      "      return bit_;",
      "    }",
      "",
      "    const int &bit() const {",
      "      return bit_;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const HuffmanEdge &rhs) {",
      "      os << \"from:\" << rhs.from_ << \" to:\" << rhs.to_ << \" bit:\" << rhs.bit_;",
      "      return os;",
      "    }",
      "  };",
      "",
      "",
      "  class HuffmanCoding {",
      "    graph_library::Graph<HuffmanEdge> binary_tree_;",
      "    unordered_map<int, vector<bool>> huffman_code_;",
      "    unordered_map<char, int> ch_to_idx_, frequency_;",
      "    unordered_map<int, char> idx_to_ch_;",
      "    string unique_s_;",
      "",
      "    void dfs(const vector<vector<HuffmanEdge>> &adj_list, int v, int pre) {",
      "      for (const auto &e: adj_list[v]) {",
      "        const int &to = e.to();",
      "        if (to == pre)",
      "          continue;",
      "",
      "        huffman_code_[to] = huffman_code_[v];",
      "        huffman_code_[to].push_back(bool(e.bit()));",
      "",
      "        dfs(adj_list, to, v);",
      "      }",
      "    }",
      "",
      "  public:",
      "    HuffmanCoding(const string &s) {",
      "      for (const char &ch: s) {",
      "        frequency_[ch]++;",
      "      }",
      "",
      "      unique_s_ = s;",
      "      sort(unique_s_.begin(), unique_s_.end());",
      "      unique_s_.erase(unique(unique_s_.begin(), unique_s_.end()), unique_s_.end());",
      "",
      "      for (int i = 0; i < int(unique_s_.size()); i++) {",
      "        const char &ch = unique_s_[i];",
      "        ch_to_idx_[ch] = i;",
      "        idx_to_ch_[i] = ch;",
      "      }",
      "",
      "      // count, index",
      "      using pic = pair<int, int>;",
      "      priority_queue<pic, vector<pic>, greater<pic>> pq;",
      "",
      "      for (const auto &[ch, cnt]: frequency_) {",
      "        pq.emplace(cnt, ch_to_idx_.at(ch));",
      "      }",
      "",
      "      int idx = unique_s_.size();",
      "      const int nodes_count = idx + idx + 1;",
      "",
      "      if (int(pq.size()) == 1) {",
      "        pq.emplace(/*count=*/0, nodes_count /*to 0-indexed*/ - 1);",
      "      }",
      "",
      "      binary_tree_ = graph_library::Graph<HuffmanEdge>(nodes_count);",
      "",
      "      constexpr int LEFT_BIT = 0;",
      "      constexpr int RIGHT_BIT = 1;",
      "",
      "      while (int(pq.size()) >= 2) {",
      "        const auto [cnt_left, idx_left] = pq.top();",
      "        pq.pop();",
      "",
      "        const auto [cnt_right, idx_right] = pq.top();",
      "        pq.pop();",
      "",
      "        binary_tree_.add_edge(HuffmanEdge(idx_left, idx, LEFT_BIT));",
      "        binary_tree_.add_edge(HuffmanEdge(idx, idx_left, LEFT_BIT));",
      "",
      "        binary_tree_.add_edge(HuffmanEdge(idx_right, idx, RIGHT_BIT));",
      "        binary_tree_.add_edge(HuffmanEdge(idx, idx_right, RIGHT_BIT));",
      "        pq.emplace(cnt_left + cnt_right, idx);",
      "        idx++;",
      "      }",
      "",
      "      dfs(binary_tree_.graph(), /*root=*/idx - 1, /*not exist node=*/-1);",
      "    }",
      "",
      "    graph_library::Graph<HuffmanEdge> binary_tree() const {",
      "      return binary_tree_;",
      "    }",
      "",
      "    char index_to_char(int idx) const {",
      "      return idx_to_ch_.at(idx);",
      "    }",
      "",
      "    int char_to_index(char ch) const {",
      "      return ch_to_idx_.at(ch);",
      "    }",
      "",
      "    string unique_string() const {",
      "      return unique_s_;",
      "    }",
      "",
      "    vector<bool> code(char ch) const {",
      "      int idx = ch_to_idx_.at(ch);",
      "      return huffman_code_.at(idx);",
      "    }",
      "",
      "    unordered_map<char, int> frequency() const {",
      "      return frequency_;",
      "    }",
      "  };",
      "} // namespace string_library"
    ],
    "description": "Template of huffman",
    "scope": "cpp"
  },
  "sorted-index.hpp": {
    "prefix": "cppsorted_index",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  template <typename Iterator>",
      "  vector<int> sorted_index(Iterator first, Iterator last) {",
      "    using T = remove_reference_t<decltype(*first)>;",
      "    vector<T> a(first, last);",
      "    vector<int> res(a.size());",
      "    iota(res.begin(), res.end(), 0);",
      "    stable_sort(res.begin(), res.end(), [&](int i, int j) {",
      "      return a[i] < a[j];",
      "    });",
      "    return res;",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of sorted_index",
    "scope": "cpp"
  },
  "reversed.hpp": {
    "prefix": "cppreversed",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <array>",
      "#include <deque>",
      "#include <forward_list>",
      "#include <list>",
      "#include <map>",
      "#include <queue>",
      "#include <set>",
      "#include <stack>",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "#include <vector>",
      "",
      "",
      "namespace tools_library {",
      "",
      "  namespace traits_helper {",
      "    template <template <typename...> typename Container, typename Type>",
      "    struct IsTemplate: false_type {};",
      "",
      "    template <template <typename...> typename Container, typename... Args>",
      "    struct IsTemplate<Container, Container<Args...>>: true_type {};",
      "  } // namespace traits_helper",
      "",
      "  // Sequence containers",
      "  template <typename T>",
      "  struct IsArray: false_type {};",
      "",
      "  template <typename T, size_t Size>",
      "  struct IsArray<array<T, Size>>: true_type {};",
      "",
      "  template <typename... Args>",
      "  inline constexpr bool is_array_v = IsArray<Args...>::value;",
      "",
      "  template <typename T>",
      "  using IsVector = traits_helper::IsTemplate<vector, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_vector_v = IsVector<T>::value;",
      "",
      "  template <typename T>",
      "  using IsDeque = traits_helper::IsTemplate<deque, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_deque_v = IsDeque<T>::value;",
      "",
      "  template <typename T>",
      "  using IsForwardList = traits_helper::IsTemplate<forward_list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_forward_list_v = IsForwardList<T>::value;",
      "",
      "  template <typename T>",
      "  using IsList = traits_helper::IsTemplate<list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_list_v = IsList<T>::value;",
      "",
      "  // Associative containers",
      "  template <typename T>",
      "  using IsSet = traits_helper::IsTemplate<set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_set_v = IsSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMap = traits_helper::IsTemplate<map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_map_v = IsMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultiset = traits_helper::IsTemplate<multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multiset_v = IsMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultimap = traits_helper::IsTemplate<multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multimap_v = IsMultimap<T>::value;",
      "",
      "  // Unordered associative containers",
      "  template <typename T>",
      "  using IsUnorderedSet = traits_helper::IsTemplate<unordered_set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_set_v = IsUnorderedSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMap = traits_helper::IsTemplate<unordered_map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_map_v = IsUnorderedMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultiset = traits_helper::IsTemplate<unordered_multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multiset_v = IsUnorderedMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultimap = traits_helper::IsTemplate<unordered_multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multimap_v = IsUnorderedMultimap<T>::value;",
      "",
      "  // Container adaptors",
      "  template <typename T>",
      "  using IsQueue = traits_helper::IsTemplate<queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_queue_v = IsQueue<T>::value;",
      "",
      "  template <typename T>",
      "  using IsStack = traits_helper::IsTemplate<stack, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_stack_v = IsStack<T>::value;",
      "",
      "  template <typename T>",
      "  using IsPriorityQueue = traits_helper::IsTemplate<priority_queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_priority_queue_v = IsPriorityQueue<T>::value;",
      "",
      "  // Container types",
      "  template <typename T>",
      "  using IsSequenceContainer = disjunction<IsArray<T>, IsVector<T>, IsDeque<T>, IsForwardList<T>, IsList<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_sequence_container_v = IsSequenceContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsAssociativeContainer = disjunction<IsSet<T>, IsMap<T>, IsMultiset<T>, IsMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_associative_container_v = IsAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedAssociativeContainer = disjunction<IsUnorderedSet<T>, IsUnorderedMap<T>, IsUnorderedMultiset<T>, IsUnorderedMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_associative_container_v = IsUnorderedAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainerAdaptor = disjunction<IsQueue<T>, IsStack<T>, IsPriorityQueue<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_adaptor_v = IsContainerAdaptor<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainer = disjunction<IsSequenceContainer<T>, IsAssociativeContainer<T>, IsUnorderedAssociativeContainer<T>, IsContainerAdaptor<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_v = IsContainer<T>::value;",
      "",
      "} // namespace tools_library",
      "",
      "#include <algorithm>",
      "#include <type_traits>",
      "",
      "namespace tools_library {",
      "  // array or vector or deque or string",
      "  template <typename Container>",
      "  constexpr Container reversed(const Container &c) {",
      "    Container res = c;",
      "    reverse(res.begin(), res.end());",
      "    return res;",
      "  }",
      "",
      "  // list or forward_list",
      "  template <template <typename T> typename Container, typename T, enable_if_t<(is_forward_list_v<Container<T>> or is_list_v<Container<T>>)> * = nullptr>",
      "  constexpr auto reversed(const Container<T> &ls) {",
      "    Container<T> res = ls;",
      "    res.reverse();",
      "    return res;",
      "  }",
      "",
      "  // set or multiset",
      "  template <template <typename T, typename Compare> typename Container, typename T, typename Compare, enable_if_t<(is_set_v<Container<T, Compare>> or is_multiset_v<Container<T, Compare>>)> * = nullptr>",
      "  constexpr auto reversed(const Container<T, Compare> &st) {",
      "    if constexpr (is_same_v<Compare, less<T>>) {",
      "      Container<T, greater<T>> res;",
      "      for (const auto &v: st) {",
      "        res.emplace_hint(res.begin(), v);",
      "      }",
      "      return res;",
      "    } else {",
      "      Container<T, less<T>> res;",
      "      for (const auto &v: st) {",
      "        res.emplace_hint(res.begin(), v);",
      "      }",
      "      return res;",
      "    }",
      "  }",
      "",
      "  // map or multimap",
      "  template <template <typename T1, typename T2, typename Compare> typename Container,",
      "            typename T1,",
      "            typename T2,",
      "            typename Compare,",
      "            enable_if_t<(is_map_v<Container<T1, T2, Compare>> or is_multimap_v<Container<T1, T2, Compare>>)> * = nullptr>",
      "  constexpr auto reversed(const Container<T1, T2, Compare> &mp) {",
      "    if constexpr (is_same_v<Compare, less<T1>>) {",
      "      Container<T1, T2, greater<T1>> res;",
      "      for (const auto &p: mp) {",
      "        res.emplace_hint(res.begin(), p);",
      "      }",
      "      return res;",
      "    } else {",
      "      Container<T1, T2, less<T1>> res;",
      "      for (const auto &p: mp) {",
      "        res.emplace_hint(res.begin(), p);",
      "      }",
      "      return res;",
      "    }",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of reversed",
    "scope": "cpp"
  },
  "has-find.hpp": {
    "prefix": "cpphas_find",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "",
      "namespace tools_library {",
      "  template <typename T>",
      "  class HasIterator {",
      "    template <typename Container>",
      "    static true_type check(typename Container::iterator *);",
      "",
      "    template <typename Container>",
      "    static false_type check(...);",
      "",
      "  public:",
      "    static const bool value = decltype(check<T>(0))::value;",
      "  };",
      "",
      "  template <typename T>",
      "  using has_iterator_t = enable_if_t<HasIterator<T>::value, typename T::iterator>;",
      "} // namespace tools_library",
      "",
      "#include <cstddef>",
      "",
      "namespace tools_library {",
      "  template <typename Container, typename T>",
      "  class HasFind {",
      "    static false_type check(...);",
      "",
      "    template <typename C, enable_if_t<(static_cast<has_iterator_t<C> (C::*)(const T &)>(&C::find), true), nullptr_t> = nullptr>",
      "    static true_type check(C *);",
      "",
      "    static Container *container;",
      "",
      "  public:",
      "    static constexpr bool value = decltype(check(container))::value;",
      "  };",
      "",
      "  template <typename Container, typename T>",
      "  static constexpr bool has_find_v = HasFind<Container, T>::value;",
      "} // namespace tools_library"
    ],
    "description": "Template of has_find",
    "scope": "cpp"
  },
  "sliced.hpp": {
    "prefix": "cppsliced",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <cstdint>",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  struct Sliced {",
      "    static constexpr int init = INT32_MAX;",
      "    Sliced() {}",
      "",
      "    template <typename T>",
      "    vector<T> operator()(const vector<T> &v, int l, int r = init, int stride = init) {",
      "      assert(stride != 0);",
      "      if (r == init)",
      "        r = v.size();",
      "      if (stride == init)",
      "        stride = 1;",
      "      vector<T> res;",
      "      int start = (stride > 0 ? l : r - 1);",
      "      for (int i = start; (stride > 0 ? i < r : i >= l); i += stride) {",
      "        if (i >= 0) {",
      "          res.emplace_back(v[i]);",
      "        } else {",
      "          res.emplace_back(v.end()[i]);",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "",
      "    string operator()(const string &s, int l, int r = init, int stride = init) {",
      "      assert(stride != 0);",
      "      if (r == init)",
      "        r = s.size();",
      "      if (stride == init)",
      "        stride = 1;",
      "      string res;",
      "      int start = (stride > 0 ? l : r - 1);",
      "      for (int i = start; (stride > 0 ? i < r : i >= l); i += stride) {",
      "        if (i >= 0) {",
      "          res.push_back(s[i]);",
      "        } else {",
      "          res.push_back(s.end()[i]);",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace tools_library"
    ],
    "description": "Template of sliced",
    "scope": "cpp"
  },
  "to-array.hpp": {
    "prefix": "cppto_array",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <array>",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  template <typename T, size_t length>",
      "  array<T, length> to_array(const vector<T> &vs) {",
      "    array<T, length> res;",
      "    for (int i = 0; i < (int)length; i++) {",
      "      res[i] = vs[i];",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of to_array",
    "scope": "cpp"
  },
  "cppint.hpp": {
    "prefix": "cppcppint",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <boost/multiprecision/cpp_int.hpp>",
      "#include <cassert>",
      "#include <string>",
      "",
      "namespace tools_library {",
      "  namespace cpp_int_helper {",
      "    namespace mp = boost::multiprecision;",
      "",
      "    string to_string(mp::cpp_int a) {",
      "      string res = \"\";",
      "      if (a < 0) {",
      "        a *= -1;",
      "        res += \"-\";",
      "      }",
      "",
      "      while (a) {",
      "        res += static_cast<char>(a % 10 + '0');",
      "        a /= 10;",
      "      }",
      "      return res;",
      "    }",
      "",
      "    mp::cpp_int gcd(mp::cpp_int a, mp::cpp_int b) {",
      "      mp::cpp_int tmp;",
      "      while (b > 0) {",
      "        tmp = a;",
      "        a = b;",
      "        b = tmp % b;",
      "      }",
      "      return a;",
      "    }",
      "",
      "    mp::cpp_int lcm(mp::cpp_int a, mp::cpp_int b) {",
      "      return a * b / gcd(a, b);",
      "    }",
      "",
      "    namespace power_helper {",
      "",
      "      mp::cpp_int extgcd(mp::cpp_int a, mp::cpp_int b, mp::cpp_int &x, mp::cpp_int &y) {",
      "        if (b == 0) {",
      "          x = 1;",
      "          y = 0;",
      "          return a;",
      "        }",
      "        mp::cpp_int d = extgcd(b, a % b, y, x);",
      "        y = y - (a / b) * x;",
      "        return d;",
      "      }",
      "",
      "    } // namespace power_helper",
      "",
      "    mp::cpp_int power(mp::cpp_int a, mp::cpp_int e, mp::cpp_int p = -1) {",
      "      assert(p != 0);",
      "      assert(p >= -1);",
      "",
      "      if (e < 0) {",
      "        assert(p != -1 and gcd(a, p) == 1);",
      "        mp::cpp_int x, y;",
      "        power_helper::extgcd(a, p, x, y);",
      "        a = (x % p + p) % p;",
      "        e *= -1;",
      "      }",
      "",
      "      mp::cpp_int res = 1;",
      "      while (e > 0) {",
      "        if (e & 1) {",
      "          res *= a;",
      "          if (p != -1)",
      "            res %= p;",
      "        }",
      "        a *= a;",
      "        if (p != -1)",
      "          a %= p;",
      "        e >>= 1;",
      "      }",
      "      return res;",
      "    }",
      "",
      "  } // namespace cpp_int_helper",
      "  using namespace cpp_int_helper;",
      "  using cint = boost::multiprecision::cpp_int;",
      "} // namespace tools_library"
    ],
    "description": "Template of cppint",
    "scope": "cpp"
  },
  "counter.hpp": {
    "prefix": "cppcounter",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <map>",
      "",
      "namespace tools_library {",
      "  template <typename Iterator>",
      "  auto counter(Iterator first, Iterator last) {",
      "    using T = remove_reference_t<decltype(*first)>;",
      "    map<T, int> res;",
      "    for (auto it = first; it != last; it++) {",
      "      T value = *it;",
      "      res[value]++;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of counter",
    "scope": "cpp"
  },
  "function-measure.hpp": {
    "prefix": "cppfunction_measure",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <chrono>",
      "#include <functional>",
      "#include <iomanip>",
      "#include <ios>",
      "#include <iostream>",
      "",
      "namespace tools_library {",
      "  struct FunctionMeasure {",
      "    chrono::system_clock::time_point start, end;",
      "",
      "    template <auto f, typename... Args>",
      "    void measure(Args... args) {",
      "      start = chrono::system_clock::now();",
      "",
      "      f(args...);",
      "",
      "      end = chrono::system_clock::now();",
      "    }",
      "",
      "    // bias:1000 -> [ms]",
      "    double time(double bias = 1000.0) {",
      "      return static_cast<double>(chrono::duration_cast<chrono::microseconds>(end - start).count() / bias);",
      "    }",
      "",
      "    void print(double bias = 1000.0) {",
      "      cout << fixed << setprecision(10);",
      "      cout << time(bias) << \"\\n\";",
      "    }",
      "  };",
      "} // namespace tools_library"
    ],
    "description": "Template of function_measure",
    "scope": "cpp"
  },
  "rotate-2d.hpp": {
    "prefix": "cpprotate_2d",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  template <typename ArrayType>",
      "  vector<ArrayType> rotate_cw(const vector<ArrayType> &s) {",
      "    int h = s.size(), w = s[0].size();",
      "    vector<ArrayType> res(w);",
      "    for (int i = 0; i < w; i++) {",
      "      for (int j = 0; j < h; j++) {",
      "        res[i].push_back(s[h - 1 - j][i]);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "",
      "  template <typename ArrayType>",
      "  vector<ArrayType> rotate_ccw(const vector<ArrayType> &s) {",
      "    int h = s.size(), w = s[0].size();",
      "    vector<ArrayType> res(w);",
      "    for (int i = 0; i < w; i++) {",
      "      for (int j = 0; j < h; j++) {",
      "        res[i].push_back(s[j][w - 1 - i]);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of rotate_2d",
    "scope": "cpp"
  },
  "contains.hpp": {
    "prefix": "cppcontains",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "",
      "namespace tools_library {",
      "  template <typename T>",
      "  class HasIterator {",
      "    template <typename Container>",
      "    static true_type check(typename Container::iterator *);",
      "",
      "    template <typename Container>",
      "    static false_type check(...);",
      "",
      "  public:",
      "    static const bool value = decltype(check<T>(0))::value;",
      "  };",
      "",
      "  template <typename T>",
      "  using has_iterator_t = enable_if_t<HasIterator<T>::value, typename T::iterator>;",
      "} // namespace tools_library",
      "",
      "#include <cstddef>",
      "",
      "namespace tools_library {",
      "  template <typename Container, typename T>",
      "  class HasFind {",
      "    static false_type check(...);",
      "",
      "    template <typename C, enable_if_t<(static_cast<has_iterator_t<C> (C::*)(const T &)>(&C::find), true), nullptr_t> = nullptr>",
      "    static true_type check(C *);",
      "",
      "    static Container *container;",
      "",
      "  public:",
      "    static constexpr bool value = decltype(check(container))::value;",
      "  };",
      "",
      "  template <typename Container, typename T>",
      "  static constexpr bool has_find_v = HasFind<Container, T>::value;",
      "} // namespace tools_library",
      "",
      "#include <algorithm>",
      "#include <iterator>",
      "",
      "namespace tools_library {",
      "  template <typename Container, typename T>",
      "  bool contains(const Container &container, const T &x) {",
      "    if constexpr (has_find_v<Container, T>) {",
      "      return container.find(x) != end(container);",
      "    } else {",
      "      return find(begin(container), end(container), x) != end(container);",
      "    }",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of contains",
    "scope": "cpp"
  },
  "fix-point.hpp": {
    "prefix": "cppfix_point",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <utility>",
      "",
      "namespace tools_library {",
      "  template <typename F>",
      "  struct FixPoint: F {",
      "    FixPoint(F &&f) noexcept: F{ forward<F>(f) } {}",
      "",
      "    template <typename... Args>",
      "    decltype(auto) operator()(Args &&...args) const {",
      "      return F::operator()(*this, forward<Args>(args)...);",
      "    }",
      "  };",
      "",
      "  template <typename F>",
      "  inline decltype(auto) make_fix_point(F &&f) {",
      "    return FixPoint<F>{ forward<F>(f) };",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of fix_point",
    "scope": "cpp"
  },
  "i128.hpp": {
    "prefix": "cppi128",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <string>",
      "",
      "namespace tools_library {",
      "  namespace int128 {",
      "    __int128_t parse(const string &s) {",
      "      __int128_t res = 0;",
      "      for (char c: s) {",
      "        if (isdigit(c))",
      "          res = res * 10 + (c - '0');",
      "      }",
      "      if (s[0] == '-')",
      "        res *= -1;",
      "      return res;",
      "    }",
      "",
      "    istream &operator>>(istream &is, __int128_t &v) {",
      "      string s;",
      "      is >> s;",
      "      v = parse(s);",
      "      return is;",
      "    }",
      "",
      "    ostream &operator<<(ostream &os, const __int128_t &v) {",
      "      if (!ostream::sentry(os))",
      "        return os;",
      "      char buf[64];",
      "      char *d = end(buf);",
      "      __uint128_t tmp = (v < 0 ? -v : v);",
      "",
      "      do {",
      "        d--;",
      "        *d = char(tmp % 10 + '0');",
      "        tmp /= 10;",
      "      } while (tmp);",
      "      if (v < 0) {",
      "        d--;",
      "        *d = '-';",
      "      }",
      "      int len = end(buf) - d;",
      "      if (os.rdbuf()->sputn(d, len) != len) {",
      "        os.setstate(ios_base::badbit);",
      "      }",
      "      return os;",
      "    }",
      "",
      "    __int128_t gcd(__int128_t a, __int128_t b) {",
      "      __int128_t tmp;",
      "      while (b > 0) {",
      "        tmp = a;",
      "        a = b;",
      "        b = tmp % b;",
      "      }",
      "      return a;",
      "    }",
      "",
      "    __int128_t lcm(__int128_t a, __int128_t b) {",
      "      return a * b / gcd(a, b);",
      "    }",
      "",
      "",
      "    namespace template_internal_math {",
      "",
      "      __int128_t extgcd(__int128_t a, __int128_t b, __int128_t &x, __int128_t &y) {",
      "        if (b == 0) {",
      "          x = 1;",
      "          y = 0;",
      "          return a;",
      "        }",
      "        __int128_t d = extgcd(b, a % b, y, x);",
      "        y = y - (a / b) * x;",
      "        return d;",
      "      }",
      "",
      "    } // namespace template_internal_math",
      "",
      "    __int128_t power(__int128_t a, __int128_t e, __int128_t p = -1) {",
      "      assert(p != 0);",
      "      assert(p >= -1);",
      "",
      "      if (e < 0) {",
      "        assert(p != -1 and gcd(a, p) == 1);",
      "        __int128_t x, y;",
      "        template_internal_math::extgcd(a, p, x, y);",
      "        a = (x % p + p) % p;",
      "        e *= -1;",
      "      }",
      "",
      "      __int128_t res = 1;",
      "      while (e > 0) {",
      "        if (e & 1) {",
      "          res *= a;",
      "          if (p != -1)",
      "            res %= p;",
      "        }",
      "        a *= a;",
      "        if (p != -1)",
      "          a %= p;",
      "        e >>= 1;",
      "      }",
      "      return res;",
      "    }",
      "  } // namespace int128",
      "  using namespace int128;",
      "  using i128 = __int128_t;",
      "} // namespace tools_library"
    ],
    "description": "Template of i128",
    "scope": "cpp"
  },
  "stopwatch.hpp": {
    "prefix": "cppstopwatch",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <chrono>",
      "",
      "namespace tools_library {",
      "  struct Stopwatch {",
      "    chrono::high_resolution_clock::time_point start;",
      "",
      "    Stopwatch() {",
      "      restart();",
      "    }",
      "",
      "    void restart() {",
      "      start = chrono::high_resolution_clock::now();",
      "    }",
      "",
      "    chrono::milliseconds::rep elapsed() {",
      "      auto end = chrono::high_resolution_clock::now();",
      "      return chrono::duration_cast<chrono::milliseconds>(end - start).count();",
      "    }",
      "  };",
      "} // namespace tools_library"
    ],
    "description": "Template of stopwatch",
    "scope": "cpp"
  },
  "mod-int.hpp": {
    "prefix": "cppmod_int",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <optional>",
      "#include <utility>",
      "",
      "namespace tools_library {",
      "  template <int m>",
      "  class ModInt {",
      "    using ll = long long;",
      "    using ull = unsigned long long;",
      "    static_assert(1 <= m);",
      "",
      "    unsigned int v_;",
      "    bool has_nullval_;",
      "",
      "    static constexpr unsigned int umod() {",
      "      return m;",
      "    }",
      "",
      "    constexpr ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "      if (b == 0) {",
      "        x = 1;",
      "        y = 0;",
      "        return a;",
      "      }",
      "      ll d = extgcd(b, a % b, y, x);",
      "      y -= a / b * x;",
      "      return d;",
      "    }",
      "",
      "    // gcd_inv:()|-> pair(g, x). g := gcd(v, umod()). vx = g (mod umod())",
      "    constexpr pair<ll, ll> gcd_inv() const {",
      "      ll x = 0, y = 0;",
      "      ll d = extgcd(v_, umod(), x, y);",
      "      return pair(d, x);",
      "    }",
      "",
      "  public:",
      "    using nullval_t = nullopt_t;",
      "    static constexpr nullval_t nullval = nullopt;",
      "",
      "    constexpr ModInt() noexcept: v_(0), has_nullval_(false) {}",
      "    constexpr ModInt(nullval_t x): v_(0), has_nullval_(true) {}",
      "    ModInt(ll x): has_nullval_(false) {",
      "      if (abs(x) >= umod())",
      "        x %= umod();",
      "",
      "      if (x < 0)",
      "        x += umod();",
      "",
      "      v_ = x;",
      "    }",
      "",
      "    constexpr bool has_nullval() const noexcept {",
      "      return has_nullval_;",
      "    }",
      "",
      "    constexpr unsigned int val() const noexcept {",
      "      return v_;",
      "    }",
      "",
      "    constexpr ModInt &operator++() noexcept {",
      "      v_++;",
      "      if (v_ == umod())",
      "        v_ = 0;",
      "      return *this;",
      "    }",
      "",
      "    constexpr ModInt &operator--() noexcept {",
      "      if (v_ == 0)",
      "        v_ = umod();",
      "      v_--;",
      "      return *this;",
      "    }",
      "",
      "    constexpr ModInt operator++([[maybe_unused]] int unused) noexcept {",
      "      ModInt old = *this;",
      "      ++*this;",
      "      return old;",
      "    }",
      "",
      "    constexpr ModInt operator--([[maybe_unused]] int unused) noexcept {",
      "      ModInt old = *this;",
      "      --*this;",
      "      return old;",
      "    }",
      "",
      "    constexpr ModInt &operator+=(const ModInt &rhs) noexcept {",
      "      v_ += rhs.v_;",
      "      if (v_ >= umod())",
      "        v_ -= umod();",
      "      return *this;",
      "    }",
      "",
      "    constexpr ModInt &operator-=(const ModInt &rhs) noexcept {",
      "      v_ -= rhs.v_;",
      "      if (v_ < 0)",
      "        v_ += umod();",
      "      return *this;",
      "    }",
      "",
      "    constexpr ModInt &operator*=(const ModInt &rhs) noexcept {",
      "      ull z = v_;",
      "      z *= rhs.v_;",
      "      v_ = z % umod();",
      "      return *this;",
      "    }",
      "",
      "    constexpr ModInt operator/=(const ModInt &rhs) {",
      "      assert(rhs.v_ != 0);",
      "      return *this = *this * rhs.inv();",
      "    }",
      "",
      "    constexpr ModInt operator+() const noexcept {",
      "      return *this;",
      "    }",
      "    constexpr ModInt operator-() const noexcept {",
      "      return ModInt() - *this;",
      "    }",
      "",
      "    constexpr ModInt pow(ll n) const {",
      "      // x = base の 2べき乗",
      "      ModInt x = /* base = */ *this, res = 1;",
      "      if (n < 0) {",
      "        const auto &[gcd, inverse] = gcd_inv();",
      "        assert(gcd == 1);",
      "        x = inverse;",
      "        n *= -1;",
      "      }",
      "      while (n) {",
      "        if (n & 1)",
      "          res *= x;",
      "        x *= x;",
      "        n >>= 1;",
      "      }",
      "      return res;",
      "    }",
      "",
      "    constexpr ModInt inv() const {",
      "      const auto &[gcd, inverse] = gcd_inv();",
      "      assert(gcd == 1);",
      "      return inverse;",
      "    }",
      "",
      "    constexpr friend ModInt operator+(const ModInt &lhs, const ModInt &rhs) noexcept {",
      "      return ModInt(lhs) += rhs;",
      "    }",
      "",
      "    constexpr friend ModInt operator-(const ModInt &lhs, const ModInt &rhs) noexcept {",
      "      return ModInt(lhs) -= rhs;",
      "    }",
      "",
      "    constexpr friend ModInt operator*(const ModInt &lhs, const ModInt &rhs) noexcept {",
      "      return ModInt(lhs) *= rhs;",
      "    }",
      "",
      "    constexpr friend ModInt operator/(const ModInt &lhs, const ModInt &rhs) {",
      "      return ModInt(lhs) /= rhs;",
      "    }",
      "",
      "    constexpr friend bool operator==(const ModInt &lhs, const ModInt &rhs) noexcept {",
      "      return lhs.v_ == rhs.v_;",
      "    }",
      "",
      "    constexpr friend bool operator!=(const ModInt &lhs, const ModInt &rhs) noexcept {",
      "      return lhs.v_ != rhs.v_;",
      "    }",
      "",
      "    friend istream &operator>>(istream &is, ModInt &rhs) {",
      "      ll temp;",
      "      is >> temp;",
      "      rhs = ModInt(temp);",
      "      return is;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const ModInt &rhs) {",
      "      os << rhs.val();",
      "      return os;",
      "    }",
      "  };",
      "",
      "  using ModInt1000000007 = ModInt<1000000007>;",
      "  using ModInt998244353 = ModInt<998244353>;",
      "} // namespace tools_library"
    ],
    "description": "Template of mod_int",
    "scope": "cpp"
  },
  "inversion.hpp": {
    "prefix": "cppinversion",
    "body": [
      "namespace data_structure_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure_library {",
      "  // verify:ARC033_C",
      "  template <typename T>",
      "  class FenwickTree {",
      "  private:",
      "    int n;",
      "    vector<T> dat;",
      "",
      "    // [1,r]",
      "    T sum(int r) {",
      "      T res = 0;",
      "      for (int k = r; k > 0; k -= (k & -k)) {",
      "        res += dat[k];",
      "      }",
      "      return res;",
      "    }",
      "",
      "  public:",
      "    FenwickTree(int n_): n(n_ + 2), dat(n_ + 2, 0) {}",
      "",
      "    // i:0-indexed",
      "    void add(int i, T x) {",
      "      for (int k = ++i; k < n; k += (k & -k)) {",
      "        dat[k] += x;",
      "      }",
      "    }",
      "",
      "    T get(int k) {",
      "      return dat[++k];",
      "    }",
      "",
      "    // [l,r)",
      "    T sum(int l, int r) {",
      "      return sum(r) - sum(l);",
      "    }",
      "",
      "    // min({x | sum(x) >= w})",
      "    int lower_bound(T w) {",
      "      if (w <= 0)",
      "        return 0;",
      "      int x = 0, twopow = 1;",
      "      while (twopow < n) {",
      "        twopow <<= 1;",
      "      }",
      "      for (int sz = twopow; sz > 0; sz >>= 1) {",
      "        if (x + sz < n and dat[x + sz] < w) {",
      "          w -= dat[x + sz];",
      "          x += sz;",
      "        }",
      "      }",
      "      return x;",
      "    }",
      "",
      "    // min({x | sum(x) > w})",
      "    int upper_bound(T w) {",
      "      return lower_bound(w + 1);",
      "    }",
      "  };",
      "} // namespace data_structure_library",
      "",
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "",
      "namespace tools_library {",
      "  // verify:AOJ_ALDS1_5_D",
      "  template <typename T>",
      "  long long inversion(vector<T> vs) {",
      "    auto uni = vs;",
      "    sort(uni.begin(), uni.end());",
      "    uni.erase(unique(uni.begin(), uni.end()), uni.end());",
      "    for (T &v: vs) {",
      "      v = lower_bound(uni.begin(), uni.end(), v) - uni.begin();",
      "    }",
      "",
      "    int n = vs.size();",
      "    data_structure::FenwickTree<long long> ft(n + 1);",
      "    long long res = 0;",
      "    for (T v: vs) {",
      "      res += ft.sum(v + 1, n);",
      "      ft.add(v, 1);",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of inversion",
    "scope": "cpp"
  },
  "container-traits.hpp": {
    "prefix": "cppcontainer_traits",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <array>",
      "#include <deque>",
      "#include <forward_list>",
      "#include <list>",
      "#include <map>",
      "#include <queue>",
      "#include <set>",
      "#include <stack>",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "#include <vector>",
      "",
      "",
      "namespace tools_library {",
      "",
      "  namespace traits_helper {",
      "    template <template <typename...> typename Container, typename Type>",
      "    struct IsTemplate: false_type {};",
      "",
      "    template <template <typename...> typename Container, typename... Args>",
      "    struct IsTemplate<Container, Container<Args...>>: true_type {};",
      "  } // namespace traits_helper",
      "",
      "  // Sequence containers",
      "  template <typename T>",
      "  struct IsArray: false_type {};",
      "",
      "  template <typename T, size_t Size>",
      "  struct IsArray<array<T, Size>>: true_type {};",
      "",
      "  template <typename... Args>",
      "  inline constexpr bool is_array_v = IsArray<Args...>::value;",
      "",
      "  template <typename T>",
      "  using IsVector = traits_helper::IsTemplate<vector, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_vector_v = IsVector<T>::value;",
      "",
      "  template <typename T>",
      "  using IsDeque = traits_helper::IsTemplate<deque, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_deque_v = IsDeque<T>::value;",
      "",
      "  template <typename T>",
      "  using IsForwardList = traits_helper::IsTemplate<forward_list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_forward_list_v = IsForwardList<T>::value;",
      "",
      "  template <typename T>",
      "  using IsList = traits_helper::IsTemplate<list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_list_v = IsList<T>::value;",
      "",
      "  // Associative containers",
      "  template <typename T>",
      "  using IsSet = traits_helper::IsTemplate<set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_set_v = IsSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMap = traits_helper::IsTemplate<map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_map_v = IsMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultiset = traits_helper::IsTemplate<multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multiset_v = IsMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultimap = traits_helper::IsTemplate<multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multimap_v = IsMultimap<T>::value;",
      "",
      "  // Unordered associative containers",
      "  template <typename T>",
      "  using IsUnorderedSet = traits_helper::IsTemplate<unordered_set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_set_v = IsUnorderedSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMap = traits_helper::IsTemplate<unordered_map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_map_v = IsUnorderedMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultiset = traits_helper::IsTemplate<unordered_multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multiset_v = IsUnorderedMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultimap = traits_helper::IsTemplate<unordered_multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multimap_v = IsUnorderedMultimap<T>::value;",
      "",
      "  // Container adaptors",
      "  template <typename T>",
      "  using IsQueue = traits_helper::IsTemplate<queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_queue_v = IsQueue<T>::value;",
      "",
      "  template <typename T>",
      "  using IsStack = traits_helper::IsTemplate<stack, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_stack_v = IsStack<T>::value;",
      "",
      "  template <typename T>",
      "  using IsPriorityQueue = traits_helper::IsTemplate<priority_queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_priority_queue_v = IsPriorityQueue<T>::value;",
      "",
      "  // Container types",
      "  template <typename T>",
      "  using IsSequenceContainer = disjunction<IsArray<T>, IsVector<T>, IsDeque<T>, IsForwardList<T>, IsList<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_sequence_container_v = IsSequenceContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsAssociativeContainer = disjunction<IsSet<T>, IsMap<T>, IsMultiset<T>, IsMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_associative_container_v = IsAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedAssociativeContainer = disjunction<IsUnorderedSet<T>, IsUnorderedMap<T>, IsUnorderedMultiset<T>, IsUnorderedMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_associative_container_v = IsUnorderedAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainerAdaptor = disjunction<IsQueue<T>, IsStack<T>, IsPriorityQueue<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_adaptor_v = IsContainerAdaptor<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainer = disjunction<IsSequenceContainer<T>, IsAssociativeContainer<T>, IsUnorderedAssociativeContainer<T>, IsContainerAdaptor<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_v = IsContainer<T>::value;",
      "",
      "} // namespace tools_library"
    ],
    "description": "Template of container_traits",
    "scope": "cpp"
  },
  "debug.hpp": {
    "prefix": "cppdebug",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "",
      "namespace tools_library {",
      "#define debug(...) debug_function(#__VA_ARGS__, __VA_ARGS__)",
      "",
      "  int find_comma_not_bracketed(string_view s) {",
      "    stack<char> bs;",
      "    string lbs = \"({[\", rbs = \")}]\";",
      "    for (size_t i = 0; i < s.size(); i++) {",
      "      if (lbs.find(s[i]) != string::npos)",
      "        bs.push(s[i]);",
      "      if (rbs.find(s[i]) != string::npos and !bs.empty())",
      "        bs.pop();",
      "      if (s[i] == ',' and bs.empty())",
      "        return i;",
      "    }",
      "    return s.size();",
      "  }",
      "",
      "  template <typename T, typename... Ts>",
      "  void debug_function(string_view name, const T &a, Ts &&...rest) {",
      "    int end = find_comma_not_bracketed(name);",
      "    cerr << name.substr(0, end) << \":\" << a;",
      "    if constexpr (sizeof...(rest) == 0) {",
      "      cerr << '\\n';",
      "    } else {",
      "      cerr << ' ';",
      "      debug_function(name.substr(name.find_first_not_of(' ', end + 1)), forward<Ts>(rest)...);",
      "    }",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of debug",
    "scope": "cpp"
  },
  "runlength.hpp": {
    "prefix": "cpprunlength",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  template <typename Iterator>",
      "  auto runlength(Iterator first, Iterator last) {",
      "    vector<pair<remove_reference_t<decltype(*first)>, int>> res;",
      "    for (auto it = first; it != last; it++) {",
      "      if (res.empty() or res.back().first != *it)",
      "        res.emplace_back(*it, 0);",
      "      res.back().second++;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of runlength",
    "scope": "cpp"
  },
  "template.cpp": {
    "prefix": "cpptemplate",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "// {{{ Templates",
      "",
      "// clang-format off",
      "",
      "// Macros",
      "#define over_load_(_1,_2,_3,_4,NAME,...) NAME",
      "#define rep(...) over_load_(__VA_ARGS__, rep4, rep3, rep2)(__VA_ARGS__)",
      "#define rep2(i, r) for ( int i = 0; i < static_cast<int>(r); (i) += 1)",
      "#define rep3(i, l, r) for ( int i = static_cast<int>(l); i < static_cast<int>(r); (i) += 1)",
      "#define rep4(i, l, r, stride) for ( int i = static_cast<int>(l); i < static_cast<int>(r); (i) += (stride))",
      "#define rrep(...) over_load_(__VA_ARGS__, rrep4, rrep3, rrep2)(__VA_ARGS__)",
      "#define rrep2(i, r) for ( int i = static_cast<int>(r) - 1; i >= 0; (i) -= 1)",
      "#define rrep3(i, l, r) for ( int i = static_cast<int>(r) - 1; i >= static_cast<int>(l); (i) -= 1)",
      "#define rrep4(i, l, r, stride) for ( int i = static_cast<int>(r) - 1; i >= static_cast<int>(l); (i) -= (stride))",
      "#define len(x) (static_cast<int>((x).size()))",
      "#define whole(f, x, ...) ([&](decltype((x)) container) { return (f)( begin(container), end(container), ## __VA_ARGS__); })(x)",
      "#define rwhole(f, x, ...) ([&](decltype((x)) container) { return (f)( rbegin(container), rend(container), ## __VA_ARGS__); })(x)",
      "#define debug(...) debug_function(#__VA_ARGS__, __VA_ARGS__)",
      "",
      "// Operators",
      "template <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }",
      "template <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &v) { bool is_first = true; for (auto x: v) { os << (is_first ? \"\" : \" \") << x; is_first = false; } return os; }",
      "template <typename T> ostream &operator<<(ostream &os, queue<T> v) { bool is_first = true; while (!v.empty()) { os << (is_first?\"\":\" \")<<v.front(); v.pop(); is_first = false; } return os; }",
      "template <typename T> ostream &operator<<(ostream &os, stack<T> v) { bool is_first = true; while (!v.empty()) { os << (is_first?\"\":\" \") << v.top(); v.pop(); is_first=false; } return os; }",
      "template <typename T> ostream &operator<<(ostream &os, const vector<T> &v) { rep (i, len(v)) os << v[i] << (i == len(v) - 1 ? \"\" : \" \"); return os; }",
      "template <typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { for (const auto &vec: v) { os << vec << '\\n'; } return os; }",
      "template <typename T> ostream &operator<<(ostream &os, const deque<T> &v) { rep (i, len(v)) os << v[i] << (i == len(v) - 1 ? \"\" : \" \"); return os; }",
      "template <typename T> ostream &operator<<(ostream &os, const set<T> &v) { bool is_first = true; for (T x: v) { os << (is_first ? \"\" : \" \") << x; is_first = false; } return os; }",
      "template <typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &in: v) { is >> in; } return is; }",
      "",
      "// For debug macro",
      "int find_comma_not_bracketed(string_view s){ stack<char> bs; string lbs = \"({[\", rbs = \")}]\"; for (size_t i = 0; i < s.size(); i++) { if (lbs.find(s[i]) != string::npos) bs.push(s[i]); if (rbs.find(s[i]) != string::npos and !bs.empty()) bs.pop(); if (s[i] == ',' and bs.empty()) return i; } return s.size(); }",
      "template <typename T, typename... Ts> void debug_function(string_view name, const T &a, Ts &&...rest) { int end = find_comma_not_bracketed(name); cerr << name.substr(0, end) << \":\" << a; if constexpr (sizeof...(rest) == 0) { cerr << '\\n'; } else { cerr << ' '; debug_function(name.substr(name.find_first_not_of(' ', end + 1)), forward<Ts>(rest)...); } }",
      "",
      "// Functions",
      "template <typename T> vector<T> make_vector(size_t a, T b) { return vector<T>(a, b); }",
      "template <typename... Ts> auto make_vector(size_t a, Ts... ts) { return vector<decltype(make_vector(ts...))>(a, make_vector(ts...)); }",
      "template <typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b and (a = b, true); }",
      "template <typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b and (a = b, true); }",
      "",
      "// Structs",
      "struct IoSetup { IoSetup(int x = 15) { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(x); cerr << fixed << setprecision(x); } } iosetup;",
      "",
      "// Type aliases",
      "using ull = unsigned long long;",
      "using ll = long long;",
      "using pll = pair<ll, ll>;",
      "using pii = pair<int, int>;",
      "",
      "// Literals",
      "constexpr ll INF64 = INT64_MAX / 2;",
      "constexpr int INF32 = INT32_MAX / 2;",
      "constexpr int dy[] = { 0, 1, -1, 0, -1, 1, -1, 1 };",
      "constexpr int dx[] = { 1, 0, 0, -1, -1, -1, 1, 1 };",
      "constexpr int mod998244353 = 998244353;",
      "constexpr int mod1000000007 = static_cast<int>(1e9) + 7;",
      "constexpr char newl = '\\n';",
      "",
      "// clang-format on",
      "",
      "// }}} Templates",
      "",
      "",
      "",
      "int main() {",
      "  int n;",
      "  cin>>n;",
      "}"
    ],
    "description": "Template of template",
    "scope": "cpp"
  },
  "compress.hpp": {
    "prefix": "cppcompress",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  // verify:ABC036_C",
      "  template <typename T>",
      "  struct Compress {",
      "    vector<T> xs;",
      "    Compress() {}",
      "    Compress(int N): xs(N, 0) {}",
      "    Compress(const vector<T> &vs): xs(vs) {}",
      "",
      "    void set(int i, T x) {",
      "      xs[i] = x;",
      "    }",
      "",
      "    void set(const vector<T> &vs) {",
      "      for (int i = 0; i < min<int>(xs.size(), vs.size()); i++) {",
      "        xs[i] = vs[i];",
      "      }",
      "    }",
      "",
      "    void add(T x) {",
      "      xs.emplace_back(x);",
      "    }",
      "",
      "    void add(const vector<T> &vs) {",
      "      for (const T &x: vs) {",
      "        xs.emplace_back(x);",
      "      }",
      "    }",
      "",
      "    Compress<T> build() {",
      "      sort(xs.begin(), xs.end());",
      "      xs.erase(unique(xs.begin(), xs.end()), xs.end());",
      "      return *this;",
      "    }",
      "",
      "    vector<T> get(const vector<T> &vs) const {",
      "      vector<T> res = vs;",
      "      for (T &x: res) {",
      "        x = lower_bound(xs.begin(), xs.end(), x) - xs.begin();",
      "      }",
      "      return res;",
      "    }",
      "",
      "    int get(T k) const {",
      "      return lower_bound(xs.begin(), xs.end(), k) - xs.begin();",
      "    }",
      "",
      "    const T &operator[](int k) const {",
      "      return xs[k];",
      "    }",
      "  };",
      "} // namespace tools_library"
    ],
    "description": "Template of compress",
    "scope": "cpp"
  },
  "has-iterator.hpp": {
    "prefix": "cpphas_iterator",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "",
      "namespace tools_library {",
      "  template <typename T>",
      "  class HasIterator {",
      "    template <typename Container>",
      "    static true_type check(typename Container::iterator *);",
      "",
      "    template <typename Container>",
      "    static false_type check(...);",
      "",
      "  public:",
      "    static const bool value = decltype(check<T>(0))::value;",
      "  };",
      "",
      "  template <typename T>",
      "  using has_iterator_t = enable_if_t<HasIterator<T>::value, typename T::iterator>;",
      "} // namespace tools_library"
    ],
    "description": "Template of has_iterator",
    "scope": "cpp"
  },
  "vector-to-string.hpp": {
    "prefix": "cppvector_to_string",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  template <typename T>",
      "  string vector_to_string(const vector<T> &vs, const string &sep = \" \") {",
      "    stringstream ss;",
      "    for (int i = 0; i < static_cast<int>(vs.size()); i++) {",
      "      if (i)",
      "        ss << sep;",
      "      ss << vs[i];",
      "    }",
      "    return ss.str();",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of vector_to_string",
    "scope": "cpp"
  },
  "range.hpp": {
    "prefix": "cpprange",
    "body": [
      "namespace tools_library {",
      "  using namespace std;",
      "}",
      "",
      "#include <iterator>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace tools_library {",
      "  // begin,endを持つ構造体",
      "  template <typename Iterator>",
      "  class Range {",
      "    const Iterator begin_;",
      "    const Iterator end_;",
      "",
      "  public:",
      "    Range(Iterator &&b, Iterator &&e) noexcept: begin_(forward<Iterator>(b)), end_(forward<Iterator>(e)) {}",
      "",
      "    Iterator begin() const noexcept {",
      "      return begin_;",
      "    }",
      "",
      "    Iterator end() const noexcept {",
      "      return end_;",
      "    }",
      "  }; // class Range",
      "",
      "  template <typename Iterator>",
      "  Range<Iterator> make_range(Iterator &&begin, Iterator &&end) noexcept {",
      "    return Range<Iterator>{ forward<Iterator>(begin), forward<Iterator>(end) };",
      "  }",
      "",
      "  // initiaizer_list用",
      "  template <typename T>",
      "  decltype(auto) make_reversed_range(const initializer_list<T> &init_list) noexcept {",
      "    return make_range(rbegin(init_list), rend(init_list));",
      "  }",
      "",
      "  // rbegin,rendを持っている方",
      "  template <typename T>",
      "  decltype(auto) make_reversed_range(T &&container) noexcept {",
      "    return make_range(rbegin(container), rend(container));",
      "  }",
      "} // namespace tools_library"
    ],
    "description": "Template of range",
    "scope": "cpp"
  }
}