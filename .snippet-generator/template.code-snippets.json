{
  "cumulative-sum-2d.hpp": {
    "prefix": "cppcumulative_sum_2d",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T>",
      "  struct CumulativeSum2D {",
      "    vector<vector<T>> data;",
      "    CumulativeSum2D(int H, int W): data(H + 1, vector<T>(W + 1, 0)) {}",
      "    CumulativeSum2D(const vector<vector<T>> &vs): data(vs) {}",
      "",
      "    void set(int y, int x, T v) { data[y + 1][x + 1] = v; }",
      "",
      "    void build() {",
      "      for (int i = 1; i < static_cast<int>(data.size()); i++) {",
      "        for (int j = 1; j < static_cast<int>(data[i].size()); j++) {",
      "          data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];",
      "        }",
      "      }",
      "    }",
      "",
      "    // [ (sy,sx), (gy,gx) )",
      "    T query(int sy, int sx, int gy, int gx) { return data[gy][gx] - data[gy][sx] - data[sy][gx] + data[sy][sx]; }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of cumulative_sum_2d",
    "scope": ""
  },
  "segment-tree.hpp": {
    "prefix": "cppsegment_tree",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  // verify:AOJ_DSL_2_A",
      "  template <typename T, T (*op)(T, T), T (*e)()>",
      "  class SegmentTree {",
      "  private:",
      "    int n;",
      "    vector<T> data;",
      "",
      "    T search(int l, int r) {",
      "      T vl = e(), vr = e();",
      "      l += n, r += n;",
      "      while (l < r) {",
      "        if (l & 1) vl = op(vl, data[l++]);",
      "        if (r & 1) vr = op(vr, data[--r]);",
      "        l >>= 1, r >>= 1;",
      "      }",
      "      return op(vl, vr);",
      "    }",
      "",
      "  public:",
      "    SegmentTree() {}",
      "    SegmentTree(int _n) { assign(_n); }",
      "",
      "    void assign(int _n) {",
      "      n = 1;",
      "      while (n < _n) {",
      "        n <<= 1;",
      "      }",
      "      data.assign(2 * n, e());",
      "    }",
      "",
      "    T get(int i) { return data[i + n]; }",
      "",
      "    void set(int i, T key) {",
      "      i += n;",
      "      data[i] = key;",
      "      while (i > 0) {",
      "        i >>= 1;",
      "        data[i] = op(data[i << 1 | 0], data[i << 1 | 1]);",
      "      }",
      "    }",
      "",
      "    // [l, r)",
      "    T prod(int l, int r) { return search(l, r); }",
      "",
      "    T all_prod() { return n != 0 ? data[0] : e(); }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of segment_tree",
    "scope": ""
  },
  "dynamic-imos.hpp": {
    "prefix": "cppdynamic_imos",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <tuple>",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T>",
      "  struct DynamicImos {",
      "    vector<T> xs, imos;",
      "    vector<tuple<T, T, T>> intervals;",
      "",
      "    DynamicImos() {}",
      "",
      "    // [l, r)",
      "    void add(T l, T r, T v) {",
      "      intervals.emplace_back(l, r, v);",
      "      xs.emplace_back(l);",
      "      xs.emplace_back(r);",
      "    }",
      "",
      "    void build() {",
      "      sort(xs.begin(), xs.end());",
      "      xs.erase(unique(xs.begin(), xs.end()), xs.end());",
      "      imos.assign(xs.size(), 0);",
      "",
      "      for (auto [l, r, v]: intervals) {",
      "        l = lower_bound(xs.begin(), xs.end(), l) - xs.begin();",
      "        r = lower_bound(xs.begin(), xs.end(), r) - xs.begin();",
      "        imos[l] += v;",
      "        imos[r] -= v;",
      "      }",
      "",
      "      for (int i = 1; i < static_cast<int>(imos.size()); i++) {",
      "        imos[i] += imos[i - 1];",
      "      }",
      "    }",
      "",
      "    // vector<[l,r), value>",
      "    vector<pair<pair<T, T>, T>> interval_values() {",
      "      vector<pair<pair<T, T>, T>> res(xs.size() - 1);",
      "      for (int i = 0; i < static_cast<int>(xs.size()) - 1; i++) {",
      "        T l = xs[i];",
      "        T r = xs[i + 1];",
      "        T v = imos[i];",
      "        res[i] = pair(pair(l, r), v);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of dynamic_imos",
    "scope": ""
  },
  "fenwick-tree-2d.hpp": {
    "prefix": "cppfenwick_tree_2d",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  // 1-indexed",
      "  template <typename T>",
      "  class FenwickTree2D {",
      "  private:",
      "    int H, W;",
      "    vector<vector<T>> dat;",
      "",
      "    // 1<=i<=y 1<=j<=x",
      "    T internal_sum(int y, int x) {",
      "      T res = 0;",
      "      for (int i = y; i > 0; i -= (i & -i)) {",
      "        for (int j = x; j > 0; j -= (j & -j)) {",
      "          res += dat[i][j];",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "",
      "  public:",
      "    FenwickTree2D() {}",
      "    FenwickTree2D(int H_, int W_) { init(H_, W_); }",
      "    void init(int H_, int W_) {",
      "      H = H_ + 1;",
      "      W = W_ + 1;",
      "      dat.assign(H, vector<T>(W, 0));",
      "    }",
      "",
      "    // {h,w} += x",
      "    void add(int h, int w, T x) {",
      "      assert(1 <= h and h <= H and 1 <= w and w <= W);",
      "      for (int i = h; i < H; i += (i & -i)) {",
      "        for (int j = w; j < W; j += (j & -j)) {",
      "          dat[i][j] += x;",
      "        }",
      "      }",
      "    }",
      "",
      "    // [{sy,sx}, {gy,gx})",
      "    T sum(int sy, int sx, int gy, int gx) {",
      "      assert(1 <= sy and sy <= H and 1 <= sx and sx <= W and 2 <= gy and gy <= H + 1 and 2 <= gx and gx <= W + 1);",
      "      return internal_sum(gy - 1, gx - 1) - internal_sum(gy - 1, sx - 1) - internal_sum(sy - 1, gx - 1) + internal_sum(sy - 1, sx - 1);",
      "    }",
      "",
      "    T get(int y, int x) { return sum(y, x, y + 1, x + 1); }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of fenwick_tree_2d",
    "scope": ""
  },
  "splay-tree.hpp": {
    "prefix": "cppsplay_tree",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T, T (*op)(T, T) = nullptr>",
      "  struct SplayTree {",
      "    struct node {",
      "      node *left, *right, *parent;",
      "      int size;",
      "      T calc_value, value;",
      "",
      "      node(): left(nullptr), right(nullptr), parent(nullptr), size(1) {}",
      "",
      "      // 回転",
      "      void rotate() {",
      "        node *pp, *p, *c;",
      "        p = this->parent;",
      "        pp = p->parent;",
      "",
      "        if (p->left == this) {",
      "          c = this->right;",
      "          this->right = p;",
      "          p->left = c;",
      "        } else {",
      "          c = this->left;",
      "          this->left = p;",
      "          p->right = c;",
      "        }",
      "",
      "        if (pp and pp->left == p) pp->left = this;",
      "        if (pp and pp->right == p) pp->right = this;",
      "        this->parent = pp;",
      "        p->parent = this;",
      "        if (c) c->parent = p;",
      "",
      "        p->update();",
      "        this->update();",
      "      }",
      "",
      "      // 根:0, 左:1, 右:-1",
      "      int state() {",
      "        if (!this->parent) return 0;",
      "        if (this->parent->left == this) return 1;",
      "        if (this->parent->right == this) return -1;",
      "        return 0;",
      "      }",
      "",
      "      // 根になるまで回転",
      "      void splay() {",
      "        while (this->state() != 0) {",
      "          // 親が根",
      "          if (this->parent->state() == 0) {",
      "            this->rotate();",
      "          } else if (this->state() == this->parent->state()) {",
      "            this->parent->rotate();",
      "            this->rotate();",
      "          } else {",
      "            this->rotate();",
      "            this->rotate();",
      "          }",
      "        }",
      "      }",
      "",
      "      // 左右の子に対して操作",
      "      void update() {",
      "        this->size = 1;",
      "        this->calc_value = value;",
      "        if (this->left) {",
      "          this->size += left->size;",
      "          if (op) this->calc_value = op(this->calc_value, this->left->calc_value);",
      "        }",
      "        if (this->right) {",
      "          this->size += right->size;",
      "          if (op) this->calc_value = op(this->calc_value, this->right->calc_value);",
      "        }",
      "      }",
      "    };",
      "",
      "    node *_root;",
      "    vector<node> nodes;",
      "    SplayTree(int n): nodes(n) {",
      "      for (int i = 0; i < n - 1; i++) {",
      "        nodes[i].parent = &nodes[i + 1];",
      "        nodes[i + 1].left = &nodes[i];",
      "        nodes[i + 1].update();",
      "      }",
      "      _root = &nodes[n - 1];",
      "    }",
      "",
      "    T &operator[](int idx) {",
      "      get(idx, _root);",
      "      _root->update();",
      "      return _root->value;",
      "    }",
      "",
      "    node *&root() { return _root; }",
      "",
      "    // rootの左からのidx番目の頂点を根にして返す",
      "    node *get(int idx, node *root) {",
      "      node *now = root;",
      "      while (true) {",
      "        int lsize = now->left ? now->left->size : 0;",
      "        if (idx < lsize) now = now->left;",
      "        if (idx == lsize) {",
      "          now->splay();",
      "          break;",
      "        }",
      "        if (idx > lsize) {",
      "          now = now->right;",
      "          idx = idx - lsize - 1;",
      "        }",
      "      }",
      "      _root = now;",
      "      return now;",
      "    }",
      "",
      "    // lrootとrrootをマージ",
      "    node *merge(node *lroot, node *rroot) {",
      "      if (!lroot) return rroot;",
      "      if (!rroot) return lroot;",
      "      lroot = get(lroot->size - 1, lroot);",
      "      lroot->right = rroot;",
      "      rroot->parent = lroot;",
      "      lroot->update();",
      "      return lroot;",
      "    }",
      "",
      "    // [0,n) -> [0,idx),[idx,n)",
      "    pair<node *, node *> split(int idx, node *root) {",
      "      if (idx == 0) return { nullptr, root };",
      "      if (idx == root->size) return { root, nullptr };",
      "",
      "      root = get(idx, root);",
      "      node *lroot, *rroot;",
      "      lroot = root->left;",
      "      rroot = root;",
      "      rroot->left = nullptr;",
      "      lroot->parent = nullptr;",
      "      rroot->update();",
      "      return { lroot, rroot };",
      "    }",
      "",
      "    node *insert(int idx, node *tmp, node *root) {",
      "      auto trees = split(idx, root);",
      "      node *lroot = trees.first;",
      "      node *rroot = trees.second;",
      "      return merge(merge(lroot, tmp), rroot);",
      "    }",
      "",
      "    pair<node *, node *> erase(int idx, node *root) {",
      "      root = get(idx, root);",
      "      node *lroot = root->left;",
      "      node *rroot = root->right;",
      "      if (lroot) lroot->parent = nullptr;",
      "      if (rroot) rroot->parent = nullptr;",
      "      root->left = nullptr;",
      "      root->right = nullptr;",
      "      root->update();",
      "      return { merge(lroot, rroot), root };",
      "    }",
      "",
      "    node *shift(int l, int r, node *root) {",
      "      auto temp = erase(r, root);",
      "      root = temp.first;",
      "      node *node = temp.second;",
      "      return insert(l, node, root);",
      "    }",
      "",
      "    pair<node *, int> prod(int l, int r, node *root) {",
      "      node *lroot, *croot, *rroot;",
      "      auto temp = split(r + 1, root);",
      "      rroot = temp.second;",
      "      temp = split(l, temp.first);",
      "      lroot = temp.first;",
      "      croot = temp.second;",
      "      int ans = croot->calc_value;",
      "      return { merge(merge(lroot, croot), rroot), ans };",
      "    }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of splay_tree",
    "scope": ""
  },
  "fenwick-tree.hpp": {
    "prefix": "cppfenwick_tree",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  // verify:ARC033_C",
      "  template <typename T>",
      "  class FenwickTree {",
      "  private:",
      "    int n;",
      "    vector<T> dat;",
      "",
      "    // [1,r]",
      "    T sum(int r) {",
      "      T res = 0;",
      "      for (int k = r; k > 0; k -= (k & -k)) {",
      "        res += dat[k];",
      "      }",
      "      return res;",
      "    }",
      "",
      "  public:",
      "    FenwickTree(int n_): n(n_ + 2), dat(n_ + 2, 0) {}",
      "",
      "    // i:0-indexed",
      "    void add(int i, T x) {",
      "      for (int k = ++i; k < n; k += (k & -k)) {",
      "        dat[k] += x;",
      "      }",
      "    }",
      "",
      "    T get(int k) { return dat[++k]; }",
      "",
      "    // [l,r)",
      "    T sum(int l, int r) { return sum(r) - sum(l); }",
      "",
      "    // min({x | sum(x) >= w})",
      "    int lower_bound(T w) {",
      "      if (w <= 0) return 0;",
      "      int x = 0, twopow = 1;",
      "      while (twopow < n) {",
      "        twopow <<= 1;",
      "      }",
      "      for (int sz = twopow; sz > 0; sz >>= 1) {",
      "        if (x + sz < n and dat[x + sz] < w) {",
      "          w -= dat[x + sz];",
      "          x += sz;",
      "        }",
      "      }",
      "      return x;",
      "    }",
      "",
      "    // min({x | sum(x) > w})",
      "    int upper_bound(T w) { return lower_bound(w + 1); }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of fenwick_tree",
    "scope": ""
  },
  "union-find.hpp": {
    "prefix": "cppunion_find",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <map>",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T>",
      "  class UnionFind {",
      "    int grp_cnt, merge_cnt;",
      "    vector<int> siz, par;",
      "    vector<T> val;",
      "",
      "  public:",
      "    UnionFind(int N): grp_cnt(N), merge_cnt(0), siz(N, 1), par(N), val(N, 0) { iota(par.begin(), par.end(), 0); }",
      "    UnionFind(int N, T init): grp_cnt(N), merge_cnt(0), siz(N, 1), par(N), val(N, init) { iota(par.begin(), par.end(), 0); }",
      "",
      "    // 根（そのグループの識別番号）",
      "    int root(int x) {",
      "      if (x == par[x]) return x;",
      "      return par[x] = root(par[x]);",
      "    }",
      "",
      "    T root_value(int x) { return val[root(x)]; }",
      "",
      "    void set_root_value(int x, T v) { val[root(x)] = v; }",
      "",
      "    // 連結成分の個数",
      "    int group_count() { return grp_cnt; }",
      "",
      "    int merge_count() { return merge_cnt; }",
      "",
      "    int size(int x) { return siz[root(x)]; }",
      "",
      "    bool same(int x, int y) { return root(x) == root(y); }",
      "",
      "    bool merge(int x, int y) {",
      "      x = root(x);",
      "      y = root(y);",
      "      if (x == y) return false;",
      "      if (siz[x] < siz[y]) swap(x, y);",
      "      siz[x] += siz[y];",
      "      par[y] = x;",
      "      grp_cnt--;",
      "      merge_cnt++;",
      "      if (val[x] == -1) {",
      "        val[x] = val[y];",
      "      } else {",
      "        val[y] = val[x];",
      "      }",
      "      return true;",
      "    }",
      "",
      "    // Θ(N)",
      "    vector<vector<int>> groups() {",
      "      int n = par.size();",
      "      vector<vector<int>> grps(n);",
      "      for (int i = 0; i < n; i++) {",
      "        grps[root(i)].emplace_back(i);",
      "      }",
      "      vector<vector<int>> res;",
      "      res.reserve(group_count());",
      "      for (int i = 0; i < n; i++) {",
      "        if (grps[i].empty()) continue;",
      "        res.emplace_back(grps[i]);",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // Θ(NlogN)",
      "    // 2つのUnionFindでi番目の頂点と同じ連結成分であるものの個数(i番目の頂点を含む)",
      "    vector<int> connect_count(UnionFind tree) {",
      "      map<pair<int, int>, int> mp;",
      "",
      "      int n = par.size();",
      "      for (int i = 0; i < n; i++) {",
      "        pair<int, int> p = make_pair(root(i), tree.root(i));",
      "        mp[p]++;",
      "      }",
      "",
      "      vector<int> res(n);",
      "      for (int i = 0; i < n; i++) {",
      "        pair<int, int> p = make_pair(root(i), tree.root(i));",
      "        res[i] = mp[p];",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of union_find",
    "scope": ""
  },
  "cumulative-sum.hpp": {
    "prefix": "cppcumulative_sum",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T>",
      "  struct CumulativeSum {",
      "    vector<T> data;",
      "    CumulativeSum(int n): data(n + 1, 0) {}",
      "    CumulativeSum(int n, T x): data(n + 1, x) {}",
      "",
      "    void set(int k, T x) { data[k + 1] = x; }",
      "",
      "    void add(int k, T x) { data[k + 1] = x; }",
      "",
      "    T get(int k) { return data[k + 1]; }",
      "",
      "    void build() {",
      "      for (int i = 0; i < static_cast<int>(data.size()) - 1; i++) {",
      "        data[i + 1] += data[i];",
      "      }",
      "    }",
      "",
      "    // [l,r)",
      "    T query(int l, int r) { return data[r] - data[l]; }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of cumulative_sum",
    "scope": ""
  },
  "mex-set.hpp": {
    "prefix": "cppmex_set",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <set>",
      "",
      "namespace data_structure {",
      "  // verify:hhkb2020_C",
      "  template <typename T = long long>",
      "  struct MexSet {",
      "    set<pair<T, T>> s;",
      "",
      "    T inf() { return numeric_limits<T>::max() / 2; }",
      "",
      "    MexSet() {",
      "      s.emplace(inf(), inf());",
      "      s.emplace(-inf(), -inf());",
      "    }",
      "",
      "    bool contains(T x) const {",
      "      auto [lower, upper] = *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      return lower <= x and x <= upper;",
      "    }",
      "",
      "    bool insert(T x) {",
      "      if (contains(x)) return false;",
      "      auto nit = s.lower_bound(pair(x + 1, x + 1));",
      "      auto it = prev(nit);",
      "      auto [l, u] = *it;",
      "      auto [nl, nu] = *nit;",
      "      if (u == x - 1) {",
      "        if (nl == x + 1) {",
      "          s.erase(it);",
      "          s.erase(nit);",
      "          s.emplace(l, nu);",
      "        } else {",
      "          s.erase(it);",
      "          s.emplace(l, x);",
      "        }",
      "      } else {",
      "        if (nl == x + 1) {",
      "          s.erase(nit);",
      "          s.emplace(x, nu);",
      "        } else {",
      "          s.emplace(x, x);",
      "        }",
      "      }",
      "      return true;",
      "    }",
      "",
      "    bool erase(T x) {",
      "      if (!contains(x)) return false;",
      "      auto it = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      auto [l, u] = *it;",
      "      s.erase(it);",
      "      if (x != l) s.emplace(l, x - 1);",
      "      if (x != u) s.emplace(x + 1, u);",
      "      return true;",
      "    }",
      "",
      "    T mex(T x = 0) const {",
      "      auto [l, u] = *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      if (l <= x and x <= u) {",
      "        return u + 1;",
      "      } else {",
      "        return x;",
      "      }",
      "    }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of mex_set",
    "scope": ""
  },
  "interval-set.hpp": {
    "prefix": "cppinterval_set",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <set>",
      "",
      "namespace data_structure {",
      "  // verify:ABC228_D",
      "  template <typename T = long long>",
      "  struct IntervalSet {",
      "    set<pair<T, T>> s;",
      "",
      "    IntervalSet() {",
      "      s.emplace(-inf(), -inf());",
      "      s.emplace(inf(), inf());",
      "    }",
      "",
      "    T inf() const { return numeric_limits<T>::max() / 2; }",
      "",
      "    bool empty() const { return static_cast<int>(s.size()) == 2; }",
      "",
      "    bool contains(T x) const {",
      "      if (empty()) return false;",
      "      auto [lower, upper] = *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      return lower <= x and x <= upper;",
      "    }",
      "",
      "    // max({ (lower, upper) | lower <= x <= upper })",
      "    pair<T, T> get(T x) const {",
      "      assert(contains(x));",
      "      return *prev(s.lower_bound(pair(x + 1, x + 1)));",
      "    }",
      "",
      "    bool insert(T x) {",
      "      if (contains(x)) return false;",
      "      auto nit = s.lower_bound(pair(x + 1, x + 1));",
      "      auto it = prev(nit);",
      "      auto [l, u] = *it;",
      "      auto [nl, nu] = *nit;",
      "      if (u == x - 1 and nl == x + 1) {",
      "        s.erase(it);",
      "        s.erase(nit);",
      "        s.emplace(l, nu);",
      "      } else if (u == x - 1 and nl != x + 1) {",
      "        s.erase(it);",
      "        s.emplace(l, x);",
      "      } else if (u != x - 1 and nl == x + 1) {",
      "        s.erase(nit);",
      "        s.emplace(x, nu);",
      "      } else if (u != x - 1 and nl != x + 1) {",
      "        s.emplace(x, x);",
      "      }",
      "      return true;",
      "    }",
      "",
      "    bool insert(T x, T y) {",
      "      if (x > y) swap(x, y);",
      "      bool contains_x = contains(x);",
      "      bool contains_y = contains(y);",
      "      if (!contains_x and !contains_y) {",
      "        s.emplace(x, y);",
      "      } else if (!contains_x and contains_y) {",
      "        auto yit = prev(s.lower_bound(pair(y + 1, y + 1)));",
      "        auto [yl, yu] = *yit;",
      "        s.erase(yit);",
      "        s.emplace(x, yu);",
      "      } else if (contains_x and !contains_y) {",
      "        auto xit = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "        auto [xl, xu] = *xit;",
      "        s.erase(xit);",
      "        s.emplace(xl, y);",
      "      } else {",
      "        auto xit = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "        auto yit = prev(s.lower_bound(pair(y + 1, y + 1)));",
      "        if (xit == yit) return false;",
      "        auto [xl, xu] = *xit;",
      "        auto [yl, yu] = *yit;",
      "        s.erase(xit);",
      "        s.erase(yit);",
      "        s.emplace(xl, yu);",
      "      }",
      "      return true;",
      "    }",
      "",
      "    bool insert(pair<T, T> p) { return insert(p.first, p.second); }",
      "",
      "    // { (l, u) | l <= x <= u } => { (l, x - 1), (x + 1, u) | l <= x <= u }",
      "    bool erase(T x) {",
      "      assert(x != -inf() and x != inf());",
      "      if (!contains(x)) return false;",
      "      auto it = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      auto [l, u] = *it;",
      "      s.erase(it);",
      "      if (x != l) s.emplace(l, x - 1);",
      "      if (x != u) s.emplace(x + 1, u);",
      "      return true;",
      "    }",
      "",
      "    // { (l, u) | l <= x <= u } => { (l, x), (x, u) | l <= x <= u }",
      "    bool cut(T x) {",
      "      assert(x != -inf() and x != inf());",
      "      if (!contains(x)) return false;",
      "      auto it = prev(s.lower_bound(pair(x + 1, x + 1)));",
      "      auto [l, u] = *it;",
      "      s.erase(it);",
      "      s.emplace(l, x);",
      "      s.emplace(x, u);",
      "      return true;",
      "    }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of interval_set",
    "scope": ""
  },
  "union-find-undo.hpp": {
    "prefix": "cppunion_find_undo",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <map>",
      "#include <numeric>",
      "#include <stack>",
      "#include <tuple>",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  // 経路圧縮なし",
      "  class UnionFindUndo {",
      "  private:",
      "    int grp_cnt, merge_cnt;",
      "    vector<int> siz, par;",
      "    stack<tuple<int, int, int>> history;",
      "",
      "  public:",
      "    UnionFindUndo(int N): grp_cnt(N), merge_cnt(0), siz(N, 1), par(N) { iota(par.begin(), par.end(), 0); }",
      "",
      "    // 根（そのグループの識別番号）",
      "    int root(int x) {",
      "      if (x == par[x]) return x;",
      "      return root(par[x]);",
      "    }",
      "",
      "    // 連結成分の個数",
      "    int group_count() { return grp_cnt; }",
      "",
      "    int merge_count() { return merge_cnt; }",
      "",
      "    int size(int x) { return siz[root(x)]; }",
      "",
      "    bool same(int x, int y) { return root(x) == root(y); }",
      "",
      "    bool merge(int x, int y) {",
      "      x = root(x);",
      "      y = root(y);",
      "      if (x == y) return false;",
      "      if (siz[x] < siz[y]) swap(x, y);",
      "      history.emplace(make_tuple(x, par[x], siz[x]));",
      "      history.emplace(make_tuple(y, par[y], siz[y]));",
      "      siz[x] += siz[y];",
      "      par[y] = x;",
      "      grp_cnt--;",
      "      merge_cnt++;",
      "      return true;",
      "    }",
      "",
      "    bool undo() {",
      "      if (history.empty()) return false;",
      "      auto [x, x_par, x_siz] = history.top();",
      "      history.pop();",
      "      auto [y, y_par, y_siz] = history.top();",
      "      history.pop();",
      "",
      "      par[x] = x_par;",
      "      siz[x] = x_siz;",
      "      par[y] = y_par;",
      "      siz[y] = y_siz;",
      "      return true;",
      "    }",
      "",
      "    void clear_history() {",
      "      while (!history.empty()) {",
      "        history.pop();",
      "      }",
      "    }",
      "",
      "    void all_undo() {",
      "      while (undo()) {}",
      "    }",
      "",
      "    // Θ(N)",
      "    vector<vector<int>> groups() {",
      "      int n = par.size();",
      "      vector<vector<int>> grps(n);",
      "      for (int i = 0; i < n; i++) {",
      "        grps[root(i)].emplace_back(i);",
      "      }",
      "      vector<vector<int>> res;",
      "      res.reserve(group_count());",
      "      for (int i = 0; i < n; i++) {",
      "        if (grps[i].empty()) continue;",
      "        res.emplace_back(grps[i]);",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // Θ(NlogN)",
      "    // 2つのunion_findでi番目の頂点と同じ連結成分であるものの個数(i番目の頂点を含む)",
      "    vector<int> connect_count(UnionFindUndo tree) {",
      "      map<pair<int, int>, int> mp;",
      "",
      "      int n = par.size();",
      "      for (int i = 0; i < n; i++) {",
      "        pair<int, int> p = make_pair(root(i), tree.root(i));",
      "        mp[p]++;",
      "      }",
      "",
      "      vector<int> res(n);",
      "      for (int i = 0; i < n; i++) {",
      "        pair<int, int> p = make_pair(root(i), tree.root(i));",
      "        res[i] = mp[p];",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "",
      "} // namespace data_structure"
    ],
    "description": "Template of union_find_undo",
    "scope": ""
  },
  "range-fenwick-tree.hpp": {
    "prefix": "cpprange_fenwick_tree",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T>",
      "  class RangeFenwickTree {",
      "  private:",
      "    int n;",
      "    vector<T> data[2];",
      "",
      "    void init(int n_) {",
      "      n = n_ + 1;",
      "      for (int p = 0; p < 2; p++)",
      "        data[p].assign(n, 0);",
      "    }",
      "",
      "    void internal_add(int p, int i, T x) {",
      "      for (int k = i; k < n; k += k & -k) {",
      "        data[p][k] += x;",
      "      }",
      "    }",
      "",
      "    T internal_sum(int p, int i) {",
      "      T res = 0;",
      "      for (int k = i; k > 0; k -= k & -k) {",
      "        res += data[p][k];",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // [1,r)",
      "    T sum(int r) {",
      "      r--;",
      "      return internal_sum(0, r) + internal_sum(1, r) * r;",
      "    }",
      "",
      "  public:",
      "    RangeFenwickTree(int n_) { init(n_); }",
      "",
      "    // [l, r)",
      "    void add(int l, int r, T x) {",
      "      internal_add(0, l, -x * (l - 1));",
      "      internal_add(0, r, x * (r - 1));",
      "      internal_add(1, l, x);",
      "      internal_add(1, r, -x);",
      "    }",
      "",
      "    // [l,r)",
      "    T sum(int l, int r) { return sum(r) - sum(l); }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of range_fenwick_tree",
    "scope": ""
  },
  "dynamic-segment-tree.hpp": {
    "prefix": "cppdynamic_segment_tree",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <iostream>",
      "#include <string>",
      "",
      "namespace data_structure {",
      "  template <typename T, T (*op)(T, T), T (*e)()>",
      "  class DynamicSegmentTree {",
      "  private:",
      "    using ll = long long;",
      "    struct node {",
      "      node *left, *right;",
      "      T v;",
      "",
      "      node(): left(nullptr), right(nullptr), v(e()) {}",
      "    };",
      "",
      "    ll n;",
      "",
      "    T prod(ll a, ll b, node *now, ll l, ll r) {",
      "      if (a <= l and r <= b) { return now->v; }",
      "      if (r <= a or b <= l) { return e(); }",
      "",
      "      T lv = e(), rv = e();",
      "      if (now->left) lv = prod(a, b, now->left, l, (l + r) / 2);",
      "      if (now->right) rv = prod(a, b, now->right, (l + r) / 2, r);",
      "      return op(lv, rv);",
      "    }",
      "",
      "    void debug_dfs(node *now, string spaces) {",
      "      if (now->right) { debug_dfs(now->right, spaces + \"   \"); }",
      "      cerr << spaces << now->v << \"\\n\";",
      "      if (now->left) { debug_dfs(now->left, spaces + \"   \"); }",
      "    }",
      "",
      "  public:",
      "    node *root;",
      "    DynamicSegmentTree(ll n_) {",
      "      n = 1;",
      "      while (n < n_) {",
      "        n *= 2;",
      "      }",
      "      root = new node();",
      "    }",
      "",
      "    void add(ll k, T x) {",
      "      node *now = root;",
      "      ll l = 0, r = n;",
      "      now->v = op(now->v, x);",
      "      while (r - l > 1) {",
      "        ll m = (l + r) / 2;",
      "        if (k < m) {",
      "          if (!now->left) now->left = new node();",
      "          now = now->left;",
      "          r = m;",
      "        } else {",
      "          if (!now->right) now->right = new node();",
      "          now = now->right;",
      "          l = m;",
      "        }",
      "        now->v = op(now->v, x);",
      "      }",
      "    }",
      "",
      "    void debug() { debug_dfs(root, \"\"); }",
      "",
      "    T prod(ll l, ll r) { return prod(l, r, root, 0, n); }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of dynamic_segment_tree",
    "scope": ""
  },
  "weighted-union-find.hpp": {
    "prefix": "cppweighted_union_find",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T>",
      "  struct WeightedUnionFind {",
      "    vector<int> par;",
      "    vector<int> siz;",
      "    vector<T> w;",
      "    WeightedUnionFind(int N): par(N), siz(N, 1), w(N, 0) { iota(par.begin(), par.end(), 0); }",
      "",
      "    int size(int x) { return siz[x]; }",
      "",
      "    T diff(int x, int y) { return weight(y) - weight(x); }",
      "",
      "    bool issame(int x, int y) { return root(x) == root(y); }",
      "",
      "    void unite(int x, int y, T z) {",
      "      z += weight(x);",
      "      z -= weight(y);",
      "      x = root(x);",
      "      y = root(y);",
      "      if (x == y) return;",
      "      if (x < y) {",
      "        swap(x, y);",
      "        z = -z;",
      "      }",
      "      siz[x] += siz[y];",
      "      par[y] = x;",
      "      w[y] = z;",
      "    }",
      "",
      "    int root(int x) {",
      "      if (x == par[x]) return x;",
      "      int rx = root(par[x]);",
      "      w[x] += w[par[x]];",
      "      par[x] = rx;",
      "      return rx;",
      "    }",
      "",
      "    T weight(int x) {",
      "      root(x);",
      "      return w[x];",
      "    }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of weighted_union_find",
    "scope": ""
  },
  "interval-scheduling.hpp": {
    "prefix": "cppinterval_scheduling",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  // verify:https://atcoder.jp/contests/keyence2020/tasks/keyence2020_b",
      "  template <typename T>",
      "  class IntervalScheduling {",
      "    vector<pair<T, T>> intervals_;",
      "    vector<bool> used;",
      "",
      "  public:",
      "    IntervalScheduling() {}",
      "",
      "    void add_interval(T l, T r) { intervals_.emplace_back(l, r); }",
      "",
      "    int inf() { return numeric_limits<int>::max() / 2; }",
      "",
      "    void build() {",
      "      used.assign(intervals_.size(), false);",
      "",
      "      sort(intervals_.begin(), intervals_.end(), [](pair<T, T> a, pair<T, T> b) {",
      "        if (a.second != b.second) return a.second < b.second;",
      "        return a.first < b.first;",
      "      });",
      "",
      "      int last = -inf();",
      "      for (size_t i = 0; i < intervals_.size(); i++) {",
      "        auto [l, r] = intervals_[i];",
      "",
      "        if (last <= l) {",
      "          used[i] = true;",
      "          last = r;",
      "        }",
      "      }",
      "    }",
      "",
      "    bool is_used(int k) { return used[k]; }",
      "",
      "    vector<pair<T, T>> intervals() {",
      "      vector<pair<T, T>> res;",
      "      for (size_t i = 0; i < intervals_.size(); i++) {",
      "        if (!used[i]) continue;",
      "        res.emplace_back(intervals_[i]);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of interval_scheduling",
    "scope": ""
  },
  "dynamic-connectivity.hpp": {
    "prefix": "cppdynamic_connectivity",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <functional>",
      "#include <iostream>",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  template <typename T>",
      "  class DynamicConnectivity {",
      "    class EulerTourTree {",
      "    public:",
      "      struct node;",
      "      using np = node *;",
      "      using lint = long long;",
      "      struct node {",
      "        np ch[2] = { nullptr, nullptr };",
      "        np p = nullptr;",
      "        int l, r, sz;",
      "        T val = et, sum = et;",
      "        bool exact;",
      "        bool child_exact;",
      "        bool edge_connected = 0;",
      "        bool child_edge_connected = 0;",
      "        node() {}",
      "        node(int l, int r): l(l), r(r), sz(l == r), exact(l < r), child_exact(l < r) {}",
      "        bool is_root() { return !p; }",
      "      };",
      "      vector<unordered_map<int, np>> ptr;",
      "      np get_node(int l, int r) {",
      "        if (ptr[l].find(r) == ptr[l].end()) ptr[l][r] = new node(l, r);",
      "        return ptr[l][r];",
      "      }",
      "      np root(np t) {",
      "        if (!t) return t;",
      "        while (t->p)",
      "          t = t->p;",
      "        return t;",
      "      }",
      "      bool same(np s, np t) {",
      "        if (s) splay(s);",
      "        if (t) splay(t);",
      "        return root(s) == root(t);",
      "      }",
      "      np reroot(np t) {",
      "        auto s = split(t);",
      "        return merge(s.second, s.first);",
      "      }",
      "      pair<np, np> split(np s) {",
      "        splay(s);",
      "        np t = s->ch[0];",
      "        if (t) t->p = nullptr;",
      "        s->ch[0] = nullptr;",
      "        return { t, update(s) };",
      "      }",
      "      pair<np, np> split2(np s) {",
      "        splay(s);",
      "        np t = s->ch[0];",
      "        np u = s->ch[1];",
      "        if (t) t->p = nullptr;",
      "        s->ch[0] = nullptr;",
      "        if (u) u->p = nullptr;",
      "        s->ch[1] = nullptr;",
      "        return { t, u };",
      "      }",
      "      tuple<np, np, np> split(np s, np t) {",
      "        auto u = split2(s);",
      "        if (same(u.first, t)) {",
      "          auto r = split2(t);",
      "          return make_tuple(r.first, r.second, u.second);",
      "        } else {",
      "          auto r = split2(t);",
      "          return make_tuple(u.first, r.first, r.second);",
      "        }",
      "      }",
      "      template <typename First, typename... Rest>",
      "      np merge(First s, Rest... t) {",
      "        return merge(s, merge(t...));",
      "      }",
      "      np merge(np s, np t) {",
      "        if (!s) return t;",
      "        if (!t) return s;",
      "        while (s->ch[1])",
      "          s = s->ch[1];",
      "        splay(s);",
      "        s->ch[1] = t;",
      "        if (t) t->p = s;",
      "        return update(s);",
      "      }",
      "      int size(np t) { return t ? t->sz : 0; }",
      "      np update(np t) {",
      "        t->sum = et;",
      "        if (t->ch[0]) t->sum = fn(t->sum, t->ch[0]->sum);",
      "        if (t->l == t->r) t->sum = fn(t->sum, t->val);",
      "        if (t->ch[1]) t->sum = fn(t->sum, t->ch[1]->sum);",
      "        t->sz = size(t->ch[0]) + (t->l == t->r) + size(t->ch[1]);",
      "        t->child_edge_connected = (t->ch[0] ? t->ch[0]->child_edge_connected : 0) | (t->edge_connected) | (t->ch[1] ? t->ch[1]->child_edge_connected : 0);",
      "        t->child_exact = (t->ch[0] ? t->ch[0]->child_exact : 0) | (t->exact) | (t->ch[1] ? t->ch[1]->child_exact : 0);",
      "        return t;",
      "      }",
      "      void push(np t) {",
      "        //遅延評価予定",
      "      }",
      "      void rot(np t, bool b) {",
      "        np x = t->p, y = x->p;",
      "        if ((x->ch[1 - b] = t->ch[b])) t->ch[b]->p = x;",
      "        t->ch[b] = x, x->p = t;",
      "        update(x);",
      "        update(t);",
      "        if ((t->p = y)) {",
      "          if (y->ch[0] == x) y->ch[0] = t;",
      "          if (y->ch[1] == x) y->ch[1] = t;",
      "          update(y);",
      "        }",
      "      }",
      "      void splay(np t) {",
      "        push(t);",
      "        while (!t->is_root()) {",
      "          np q = t->p;",
      "          if (q->is_root()) {",
      "            push(q), push(t);",
      "            rot(t, q->ch[0] == t);",
      "          } else {",
      "            np r = q->p;",
      "            push(r), push(q), push(t);",
      "            bool b = r->ch[0] == q;",
      "            if (q->ch[1 - b] == t)",
      "              rot(q, b), rot(t, b);",
      "            else",
      "              rot(t, 1 - b), rot(t, b);",
      "          }",
      "        }",
      "      }",
      "      void debug(np t) {",
      "        if (!t) return;",
      "        debug(t->ch[0]);",
      "        cerr << t->l << \"-\" << t->r << \" \";",
      "        debug(t->ch[1]);",
      "      }",
      "",
      "    public:",
      "      EulerTourTree() {}",
      "      EulerTourTree(int sz) {",
      "        ptr.resize(sz);",
      "        for (int i = 0; i < sz; i++)",
      "          ptr[i][i] = new node(i, i);",
      "      }",
      "      int size(int s) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        return t->sz;",
      "      }",
      "      bool same(int s, int t) { return same(get_node(s, s), get_node(t, t)); }",
      "      void set_size(int sz) {",
      "        ptr.resize(sz);",
      "        for (int i = 0; i < sz; i++)",
      "          ptr[i][i] = new node(i, i);",
      "      }",
      "      void update(int s, T x) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        t->val = fn(t->val, x);",
      "        update(t);",
      "      }",
      "      void edge_update(int s, auto g) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        function<void(np)> dfs = [&](np t) {",
      "          assert(t);",
      "          if (t->l < t->r and t->exact) {",
      "            splay(t);",
      "            t->exact = 0;",
      "            update(t);",
      "            g(t->l, t->r);",
      "            return;",
      "          }",
      "          if (t->ch[0] and t->ch[0]->child_exact)",
      "            dfs(t->ch[0]);",
      "          else",
      "            dfs(t->ch[1]);",
      "        };",
      "        while (t and t->child_exact) {",
      "          dfs(t);",
      "          splay(t);",
      "        }",
      "      }",
      "      bool try_reconnect(int s, auto f) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        function<bool(np)> dfs = [&](np t) -> bool {",
      "          assert(t);",
      "          if (t->edge_connected) {",
      "            splay(t);",
      "            return f(t->l);",
      "          }",
      "          if (t->ch[0] and t->ch[0]->child_edge_connected)",
      "            return dfs(t->ch[0]);",
      "          else",
      "            return dfs(t->ch[1]);",
      "        };",
      "        while (t->child_edge_connected) {",
      "          if (dfs(t)) return 1;",
      "          splay(t);",
      "        }",
      "        return 0;",
      "      }",
      "      void edge_connected_update(int s, bool b) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        t->edge_connected = b;",
      "        update(t);",
      "      }",
      "      bool link(int l, int r) {",
      "        if (same(l, r)) return 0;",
      "        merge(reroot(get_node(l, l)), get_node(l, r), reroot(get_node(r, r)), get_node(r, l));",
      "        return 1;",
      "      }",
      "      bool cut(int l, int r) {",
      "        if (ptr[l].find(r) == ptr[l].end()) return 0;",
      "        np s, t, u;",
      "        tie(s, t, u) = split(get_node(l, r), get_node(r, l));",
      "        merge(s, u);",
      "        np p = ptr[l][r];",
      "        np q = ptr[r][l];",
      "        ptr[l].erase(r);",
      "        ptr[r].erase(l);",
      "        delete p;",
      "        delete q;",
      "        return 1;",
      "      }",
      "      T get_sum(int p, int v) {",
      "        cut(p, v);",
      "        np t = get_node(v, v);",
      "        splay(t);",
      "        T res = t->sum;",
      "        link(p, v);",
      "        return res;",
      "      }",
      "      T get_sum(int s) {",
      "        np t = get_node(s, s);",
      "        splay(t);",
      "        return t->sum;",
      "      }",
      "    };",
      "    int dep = 1;",
      "    vector<EulerTourTree> ett;",
      "    vector<vector<unordered_set<int>>> edges;",
      "    int sz;",
      "",
      "  public:",
      "    DynamicConnectivity(int sz): sz(sz) {",
      "      ett.emplace_back(sz);",
      "      edges.emplace_back(sz);",
      "    }",
      "    bool link(int s, int t) {",
      "      if (s == t) return 0;",
      "      if (ett[0].link(s, t)) return 1;",
      "      edges[0][s].insert(t);",
      "      edges[0][t].insert(s);",
      "      if (edges[0][s].size() == 1) ett[0].edge_connected_update(s, 1);",
      "      if (edges[0][t].size() == 1) ett[0].edge_connected_update(t, 1);",
      "      return 0;",
      "    }",
      "",
      "    bool same(int s, int t) { return ett[0].same(s, t); }",
      "",
      "    int size(int s) { return ett[0].size(s); }",
      "",
      "    vector<int> get_vertex(int s) { return ett[0].vertex_list(s); }",
      "",
      "    void update(int s, T x) { ett[0].update(s, x); }",
      "",
      "    T get_sum(int s) { return ett[0].get_sum(s); }",
      "",
      "    bool cut(int s, int t) {",
      "      if (s == t) return 0;",
      "      for (int i = 0; i < dep; i++) {",
      "        edges[i][s].erase(t);",
      "        edges[i][t].erase(s);",
      "        if (edges[i][s].size() == 0) ett[i].edge_connected_update(s, 0);",
      "        if (edges[i][t].size() == 0) ett[i].edge_connected_update(t, 0);",
      "      }",
      "      for (int i = dep - 1; i >= 0; i--) {",
      "        if (ett[i].cut(s, t)) {",
      "          if (dep - 1 == i) {",
      "            dep++;",
      "            ett.emplace_back(sz);",
      "            edges.emplace_back(sz);",
      "          }",
      "          return !try_reconnect(s, t, i);",
      "        }",
      "      }",
      "      return 0;",
      "    }",
      "",
      "    bool try_reconnect(int s, int t, int k) {",
      "      for (int i = 0; i < k; i++) {",
      "        ett[i].cut(s, t);",
      "      }",
      "      for (int i = k; i >= 0; i--) {",
      "        if (ett[i].size(s) > ett[i].size(t)) swap(s, t);",
      "        auto g = [&](int s, int t) {",
      "          ett[i + 1].link(s, t);",
      "        };",
      "        ett[i].edge_update(s, g);",
      "        auto f = [&](int x) -> bool {",
      "          for (auto itr = edges[i][x].begin(); itr != edges[i][x].end();) {",
      "            auto y = *itr;",
      "            itr = edges[i][x].erase(itr);",
      "            edges[i][y].erase(x);",
      "            if (edges[i][x].size() == 0) ett[i].edge_connected_update(x, 0);",
      "            if (edges[i][y].size() == 0) ett[i].edge_connected_update(y, 0);",
      "            if (ett[i].same(x, y)) {",
      "              edges[i + 1][x].insert(y);",
      "              edges[i + 1][y].insert(x);",
      "              if (edges[i + 1][x].size() == 1) ett[i + 1].edge_connected_update(x, 1);",
      "              if (edges[i + 1][y].size() == 1) ett[i + 1].edge_connected_update(y, 1);",
      "            } else {",
      "              for (int j = 0; j <= i; j++) {",
      "                ett[j].link(x, y);",
      "              }",
      "              return 1;",
      "            }",
      "          }",
      "          return 0;",
      "        };",
      "        if (ett[i].try_reconnect(s, f)) return 1;",
      "      }",
      "      return 0;",
      "    }",
      "    constexpr static T et = T();",
      "    constexpr static T fn(T s, T t) { return s + t; }",
      "  };",
      "} // namespace data_structure"
    ],
    "description": "Template of dynamic_connectivity",
    "scope": ""
  },
  "base.hpp": {
    "prefix": "cppbase",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}"
    ],
    "description": "Template of base",
    "scope": ""
  },
  "longest-common-subsequence.hpp": {
    "prefix": "cpplongest_common_subsequence",
    "body": [
      "namespace dp {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace dp {",
      "  // verify:EDPC_F",
      "  template <typename T>",
      "  struct LongestCommonSubsequence {",
      "    vector<T> s, t;",
      "    int h, w;",
      "    vector<vector<int>> dp;",
      "    LongestCommonSubsequence(vector<T> _s, vector<T> _t): s(_s), t(_t) {",
      "      h = _s.size();",
      "      w = _t.size();",
      "    }",
      "    LongestCommonSubsequence(string _s, string _t) {",
      "      h = _s.size(), w = _t.size();",
      "      for (int i = 0; i < h; i++)",
      "        s.emplace_back(_s[i]);",
      "      for (int i = 0; i < w; i++)",
      "        t.emplace_back(_t[i]);",
      "    }",
      "",
      "    int build() {",
      "      dp.assign(h + 1, vector<int>(w + 1, 0));",
      "      for (int i = 0; i < h; i++) {",
      "        for (int j = 0; j < w; j++) {",
      "          if (s[i] == t[j]) {",
      "            dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + 1);",
      "            continue;",
      "          }",
      "          dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);",
      "          dp[i][j + 1] = max(dp[i][j + 1], dp[i][j]);",
      "        }",
      "      }",
      "      return dp[h][w];",
      "    }",
      "",
      "    vector<T> restore() {",
      "      vector<T> res;",
      "      int i = h, j = w;",
      "      while (i > 0 and j > 0) {",
      "        if (s[i - 1] == t[j - 1]) {",
      "          res.emplace_back(s[i - 1]);",
      "          i--;",
      "          j--;",
      "          continue;",
      "        }",
      "        if (dp[i - 1][j] > dp[i][j - 1])",
      "          i--;",
      "        else",
      "          j--;",
      "      }",
      "      reverse(res.begin(), res.end());",
      "      return res;",
      "    }",
      "  };",
      "} // namespace dp"
    ],
    "description": "Template of longest_common_subsequence",
    "scope": ""
  },
  "re-rooting-dp.hpp": {
    "prefix": "cppre_rooting_dp",
    "body": [
      "namespace dp {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <cassert>",
      "#include <stack>",
      "#include <vector>",
      "",
      "namespace dp {",
      "  // TODO verify:EDPC-V, ABC220-F, ABC160-F",
      "  // add_node: 自身の値を追加して親方向へ渡す関数 (T result, int index) |-> T",
      "  // op: 二項演算 (monoid)",
      "  // e: opに関する単位元",
      "  template <typename T, T (*add_node)(T, int), T (*op)(T, T), T (*e)()>",
      "  class ReRootingDP {",
      "    // order と parents の前計算",
      "    void dfs(int root) {",
      "      int index = 0;",
      "      stack<int> s;",
      "      s.push(root);",
      "      m_parents[root] = -1;",
      "",
      "      while (not s.empty()) {",
      "        int node = s.top();",
      "        s.pop();",
      "",
      "        m_order[index++] = node;",
      "        for (auto [adjacent, ignore]: m_tree[node]) {",
      "          if (adjacent == m_parents[node]) continue;",
      "          s.push(adjacent);",
      "          m_parents[adjacent] = node;",
      "        }",
      "      }",
      "    }",
      "",
      "    // 根の値を求めるために全頂点の子方向の値を帰りがけ順で求める",
      "    // child_subtree_results[node][i] (頂点nodeのi番目の子部分木の値) が求まる",
      "    // ただし、子方向を親としたときの child_subtree_results[node][i] は求まらない",
      "    void post_order(int root) {",
      "      vector<int> reversed_order = m_order;",
      "      reverse(reversed_order.begin(), reversed_order.end());",
      "",
      "      for (int node: reversed_order) {",
      "        if (node == root) continue;",
      "",
      "        int parent = m_parents[node];",
      "        int parent_index = -1;",
      "        T result = e();",
      "",
      "        for (int i = 0; i < (int)m_tree[node].size(); i++) {",
      "          int to = m_tree[node][i].first;",
      "          if (to == parent) {",
      "            parent_index = i;",
      "            continue;",
      "          }",
      "",
      "          result = op(result, m_child_subtree_results[node][i]);",
      "        }",
      "",
      "        assert(parent_index != -1);",
      "        m_child_subtree_results[parent][m_index_for_adjacents[node][parent_index]] = add_node(result, node);",
      "      }",
      "    }",
      "",
      "    // 全頂点の親方向の値を両側累積を使って求める(行きがけ順)",
      "    // node_results[node] が求まる",
      "    void pre_order() {",
      "      for (int node: m_order) {",
      "        int size = m_tree[node].size();",
      "",
      "        if (size == 0) continue;",
      "",
      "        vector<T> accums_front(size + 1, e()), accums_back(size, e());",
      "",
      "        for (int i = 0; i < size; i++) {",
      "          T child_subtree_result = m_child_subtree_results[node][i];",
      "          accums_front[i + 1] = op(accums_front[i], child_subtree_result);",
      "        }",
      "        for (int i = size - 1; i >= 1; i--) {",
      "          T child_subtree_result = m_child_subtree_results[node][i];",
      "          accums_back[i - 1] = op(accums_back[i], child_subtree_result);",
      "        }",
      "",
      "        for (int i = 0; i < size; i++) {",
      "          T result = add_node(op(accums_front[i], accums_back[i]), node);",
      "",
      "          int parent = m_tree[node][i].first;",
      "          int index_from_parent = m_index_for_adjacents[node][i];",
      "",
      "          m_child_subtree_results[parent][index_from_parent] = result;",
      "        }",
      "        T accum_child_subtree_result = accums_front.back();",
      "        m_node_results[node] = add_node(accum_child_subtree_result, node);",
      "      }",
      "    }",
      "",
      "  public:",
      "    using Edge = pair<int, T>;",
      "    vector<vector<Edge>> m_tree;",
      "    vector<vector<int>> m_index_for_adjacents;",
      "    vector<vector<T>> m_child_subtree_results;",
      "    vector<int> m_parents, m_order;",
      "    vector<T> m_node_results;",
      "",
      "    ReRootingDP(int n): m_tree(n), m_index_for_adjacents(n), m_parents(n), m_order(n), m_node_results(n, e()) {}",
      "",
      "    // Directed edge",
      "    void add_edge(int from, int to, T cost) {",
      "      m_tree[from].emplace_back(to, cost);",
      "      m_index_for_adjacents[to].emplace_back(m_tree[from].size() - 1);",
      "    }",
      "",
      "    void build() {",
      "      int size = m_tree.size();",
      "      assert(size != 0);",
      "      m_child_subtree_results.resize(size);",
      "      for (int i = 0; i < size; i++) {",
      "        m_child_subtree_results[i].assign(m_tree[i].size(), e());",
      "      }",
      "",
      "      dfs(/* root = */ 0);",
      "      post_order(/* root = */ 0);",
      "      pre_order();",
      "    }",
      "",
      "    T operator[](int node) { return m_node_results[node]; }",
      "  };",
      "} // namespace dp"
    ],
    "description": "Template of re_rooting_dp",
    "scope": ""
  },
  "line.hpp": {
    "prefix": "cppline",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS) return -1;",
      "    if (a > +EPS) return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) { return sign(a - b) == 0; }",
      "} // namespace geometry",
      "",
      "#include <complex>",
      "",
      "namespace geometry {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) { return Point(p.real() * k, p.imag() * k); }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) { return equals(a.real(), b.real()) and equals(a.imag(), b.imag()); }",
      "} // namespace geometry",
      "",
      "namespace geometry {",
      "  struct Line {",
      "    Point a, b;",
      "",
      "    Line() = default;",
      "    Line(const Point &a, const Point &b): a(a), b(b) {}",
      "  };",
      "} // namespace geometry"
    ],
    "description": "Template of line",
    "scope": ""
  },
  "point.hpp": {
    "prefix": "cpppoint",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS) return -1;",
      "    if (a > +EPS) return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) { return sign(a - b) == 0; }",
      "} // namespace geometry",
      "",
      "#include <complex>",
      "",
      "namespace geometry {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) { return Point(p.real() * k, p.imag() * k); }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) { return equals(a.real(), b.real()) and equals(a.imag(), b.imag()); }",
      "} // namespace geometry"
    ],
    "description": "Template of point",
    "scope": ""
  },
  "projection.hpp": {
    "prefix": "cppprojection",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS) return -1;",
      "    if (a > +EPS) return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) { return sign(a - b) == 0; }",
      "} // namespace geometry",
      "",
      "",
      "",
      "#include <complex>",
      "",
      "namespace geometry {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) { return Point(p.real() * k, p.imag() * k); }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) { return equals(a.real(), b.real()) and equals(a.imag(), b.imag()); }",
      "} // namespace geometry",
      "",
      "namespace geometry {",
      "  struct Line {",
      "    Point a, b;",
      "",
      "    Line() = default;",
      "    Line(const Point &a, const Point &b): a(a), b(b) {}",
      "  };",
      "} // namespace geometry",
      "",
      "",
      "namespace geometry {",
      "  Real cross(const Point &a, const Point &b) { return a.real() * b.imag() - a.imag() * b.real(); }",
      "",
      "  Real dot(const Point &a, const Point &b) { return a.real() * b.real() + a.imag() * b.imag(); }",
      "} // namespace geometry",
      "",
      "namespace geometry {",
      "  Point projection(const Line &l, const Point &p) {",
      "    // Real",
      "  }",
      "} // namespace geometry"
    ],
    "description": "Template of projection",
    "scope": ""
  },
  "product.hpp": {
    "prefix": "cppproduct",
    "body": [
      "#include <cmath>",
      "",
      "namespace geometry {",
      "  using namespace std;",
      "  using Real = double;",
      "",
      "  constexpr Real PI = M_PI;",
      "  constexpr Real EPS = 1e-9;",
      "",
      "  inline int sign(Real a) {",
      "    if (a < -EPS) return -1;",
      "    if (a > +EPS) return +1;",
      "    return 0;",
      "  }",
      "",
      "  inline bool equals(Real a, Real b) { return sign(a - b) == 0; }",
      "} // namespace geometry",
      "",
      "",
      "#include <complex>",
      "",
      "namespace geometry {",
      "  using Point = complex<Real>;",
      "",
      "  istream &operator>>(istream &is, Point &p) {",
      "    Real x, y;",
      "    is >> x >> y;",
      "    p = Point(x, y);",
      "    return is;",
      "  }",
      "",
      "  ostream &operator<<(ostream &os, const Point &p) {",
      "    os << p.real() << \" \" << p.imag();",
      "    return os;",
      "  }",
      "",
      "  Point operator*(const Point &p, const Real &k) { return Point(p.real() * k, p.imag() * k); }",
      "",
      "  Point rotate_cw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.imag();",
      "    Real i = sinl(radian) * p.real() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  Point rotate_ccw(const Real &radian, Point p, const Point &origin = Point(0, 0)) {",
      "    p -= origin;",
      "    Real r = cosl(radian) * p.real() + sinl(-radian) * p.real();",
      "    Real i = sinl(radian) * p.imag() + cosl(-radian) * p.imag();",
      "    p = Point(r, i);",
      "    p += origin;",
      "    return p;",
      "  }",
      "",
      "  bool equals(const Point &a, const Point &b) { return equals(a.real(), b.real()) and equals(a.imag(), b.imag()); }",
      "} // namespace geometry",
      "",
      "namespace geometry {",
      "  Real cross(const Point &a, const Point &b) { return a.real() * b.imag() - a.imag() * b.real(); }",
      "",
      "  Real dot(const Point &a, const Point &b) { return a.real() * b.real() + a.imag() * b.imag(); }",
      "} // namespace geometry"
    ],
    "description": "Template of product",
    "scope": ""
  },
  "shortest-hamiltonian-cycle.hpp": {
    "prefix": "cppshortest_hamiltonian_cycle",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <limits>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  // verify:AOJ_DPL_2_A",
      "  // sから始めて1度だけ訪問し、sに戻ってきた閉路の最短経路距離",
      "  // buildでinfinity()が帰ってきたらそのような経路はない",
      "  template <typename T>",
      "  struct ShortestHamiltonianCycle {",
      "    struct edge {",
      "      int to;",
      "      T cost;",
      "      edge(int to, T cost): to(to), cost(cost) {}",
      "    };",
      "",
      "    int V;",
      "    int start;",
      "    vector<vector<edge>> G;",
      "    vector<vector<T>> dp;",
      "",
      "    ShortestHamiltonianCycle(int V_): V(V_), G(V_) {}",
      "",
      "    T inf() { return numeric_limits<T>::max() / 2; }",
      "",
      "    void add_edge(int from, int to, T cost) { G[from].emplace_back(to, cost); }",
      "",
      "    T build(int s) {",
      "      start = s;",
      "      dp.assign(V, vector<T>(1 << V, -1));",
      "      return dfs(s, 0);",
      "    }",
      "",
      "    // private method",
      "    T dfs(int v, int Set) {",
      "      T &res = dp[v][Set];",
      "      if (Set + 1 == 1 << V and v == start) res = 0;",
      "      if (res != -1) return res;",
      "      res = inf();",
      "      for (auto [to, cost]: G[v]) {",
      "        int bit = 1 << to;",
      "        if (Set & bit) continue;",
      "        res = min(res, dfs(to, Set | bit) + cost);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of shortest_hamiltonian_cycle",
    "scope": ""
  },
  "lowest-common-ancestor.hpp": {
    "prefix": "cpplowest_common_ancestor",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace graph {",
      "  class LowestCommonAncestor {",
      "  private:",
      "    int h;",
      "    vector<vector<int>> G, par;",
      "    vector<int> dep;",
      "",
      "    void dfs(int v, int p, int d) {",
      "      par[0][v] = p;",
      "      dep[v] = d;",
      "      for (int u: G[v])",
      "        if (u != p) dfs(u, v, d + 1);",
      "    }",
      "",
      "  public:",
      "    LowestCommonAncestor(int n): G(n), dep(n) {",
      "      h = 1;",
      "      while ((1 << h) <= n)",
      "        h++;",
      "      par.assign(h, vector<int>(n, -1));",
      "    }",
      "",
      "    void add_edge(int u, int v) {",
      "      G[u].emplace_back(v);",
      "      // G[v].emplace_back(u);",
      "    }",
      "",
      "    void build(int root = 0) {",
      "      int n = G.size();",
      "      dfs(root, -1, 0);",
      "      for (int k = 0; k + 1 < h; k++)",
      "        for (int v = 0; v < n; v++)",
      "          if (~par[k][v]) par[k + 1][v] = par[k][par[k][v]];",
      "    }",
      "",
      "    int query(int u, int v) {",
      "      if (dep[u] > dep[v]) swap(u, v);",
      "      for (int k = 0; k < h; k++)",
      "        if ((dep[v] - dep[u]) >> k & 1) v = par[k][v];",
      "",
      "      if (u == v) return u;",
      "",
      "      for (int k = h - 1; k >= 0; k--)",
      "        if (par[k][u] != par[k][v]) u = par[k][u], v = par[k][v];",
      "",
      "      return par[0][u];",
      "    }",
      "",
      "    int distance(int u, int v) { return dep[u] + dep[v] - dep[query(u, v)] * 2; }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of lowest_common_ancestor",
    "scope": ""
  },
  "bellman-ford.hpp": {
    "prefix": "cppbellman_ford",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  template <typename T>",
      "  class BellmanFord {",
      "  public:",
      "    struct edge {",
      "      int from, to;",
      "      T cost;",
      "      edge() {}",
      "      edge(int f, int t, T c): from(f), to(t), cost(c) {}",
      "    };",
      "",
      "  private:",
      "    bool neg_cycle;",
      "    bool neg_cycle_to_goal;",
      "",
      "  public:",
      "    int V;",
      "    vector<edge> es;",
      "    vector<T> ds;",
      "    vector<int> bs;",
      "",
      "    BellmanFord(int N): V(N), neg_cycle(false), neg_cycle_to_goal(false) {}",
      "",
      "    void add_edge(int from, int to, T cost) { es.emplace_back(from, to, cost); }",
      "",
      "    bool neg() { return neg_cycle; }",
      "",
      "    bool neg_to_goal() { return neg_cycle_to_goal; }",
      "",
      "    T inf() { return numeric_limits<T>::max() / 2; }",
      "",
      "    void build(int s, int g = -1) {",
      "      if (g == -1) g = V - 1;",
      "      ds.assign(V, inf());",
      "      bs.assign(V, -1);",
      "      ds[s] = 0;",
      "",
      "      for (int i = 0; i < 2 * V; i++) {",
      "        for (edge e: es) {",
      "          if (ds[e.from] >= inf()) continue;",
      "          if (ds[e.to] <= ds[e.from] + e.cost) continue;",
      "",
      "          ds[e.to] = ds[e.from] + e.cost;",
      "          bs[e.from] = e.to;",
      "          if (i >= V - 1) {",
      "            ds[e.to] = -inf();",
      "            neg_cycle = true;",
      "            if (e.to == g) {",
      "              neg_cycle_to_goal = true;",
      "              return;",
      "            }",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    T operator[](int k) { return ds[k]; }",
      "",
      "    vector<int> restore(int to) {",
      "      vector<int> res;",
      "      if (bs[to] == -1) {",
      "        res.emplace_back(to);",
      "        return res;",
      "      }",
      "      while (bs[to] != -1) {",
      "        res.emplace_back(to);",
      "        to = bs[to];",
      "      }",
      "      reverse(res.begin(), res.end());",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of bellman_ford",
    "scope": ""
  },
  "convert-graph.hpp": {
    "prefix": "cppconvert_graph",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  // grid graph -> adjacency list",
      "  vector<vector<int>> convert_graph(const vector<string> &s) {",
      "    int h = s.size(), w = s[0].size();",
      "    constexpr int dy[] = { 1, 0, -1, 0 }, dx[] = { 0, 1, 0, -1 };",
      "    vector<vector<int>> res(h * w);",
      "    for (int i = 0; i < h; i++) {",
      "      for (int j = 0; j < w; j++) {",
      "        int from = i * w + j;",
      "        for (int k = 0; k < 4; k++) {",
      "          int ny = i + dy[k], nx = j + dx[k];",
      "          if (ny < 0 or nx < 0 or ny >= h or nx >= w) continue;",
      "          int to = ny * w + j;",
      "          res[from].push_back(to);",
      "        }",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "} // namespace graph"
    ],
    "description": "Template of convert_graph",
    "scope": ""
  },
  "euler-tour.hpp": {
    "prefix": "cppeuler_tour",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace graph {",
      "  class EulerTour {",
      "    vector<int> in_time, out_time, dep, par, edge_table_;",
      "    vector<vector<int>> G;",
      "",
      "    void dfs(int v, int &time, int d) {",
      "      in_time[v] = time;",
      "      dep[v] = d;",
      "      edge_table_[time] = v;",
      "      time++;",
      "      for (auto to: G[v]) {",
      "        if (in_time[to] != -1) continue;",
      "        par[to] = v;",
      "        dfs(to, time, d + 1);",
      "      }",
      "      out_time[v] = time;",
      "      edge_table_[time] = -v;",
      "      time++;",
      "    }",
      "",
      "  public:",
      "    EulerTour(int n): G(n) {}",
      "",
      "    void add_edge(int from, int to) { G[from].emplace_back(to); }",
      "",
      "    void build(int s) {",
      "      in_time.assign(G.size(), -1);",
      "      out_time.assign(G.size(), -1);",
      "      dep.assign(G.size(), -1);",
      "      par.assign(G.size(), -1);",
      "      edge_table_.assign(2 * G.size(), -1);",
      "",
      "      int time = 0;",
      "      dfs(s, time, 0);",
      "    }",
      "",
      "    int in(int v) { return in_time[v]; }",
      "    int out(int v) { return out_time[v]; }",
      "    int depth(int v) { return dep[v]; }",
      "    int parent(int v) { return par[v]; }",
      "    vector<int> edge_table() { return edge_table_; }",
      "",
      "    // edge_table:[first, second), vertex_table:[first, second]",
      "    pair<int, int> subtree(int v) { return pair(in_time[v], out_time[v]); }",
      "",
      "    vector<int> vertex_table() {",
      "      vector<int> res = edge_table_;",
      "      for (auto &v: res) {",
      "        if (v < 0) v = par[v];",
      "      }",
      "      // 半開区間->閉区間の誤差",
      "      res.pop_back();",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of euler_tour",
    "scope": ""
  },
  "low-link.hpp": {
    "prefix": "cpplow_link",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  class LowLink {",
      "  public:",
      "    vector<int> articulations;",
      "    vector<pair<int, int>> bridges;",
      "",
      "    LowLink(int V): G(V) {}",
      "",
      "    void add_edge(int from, int to) { G[from].emplace_back(to); }",
      "",
      "    void build() {",
      "      int V = G.size();",
      "      ord.assign(V, -1);",
      "      low.resize(V);",
      "",
      "      int k = 0;",
      "      for (int i = 0; i < V; i++) {",
      "        if (ord[i] == -1) dfs(i, k, -1);",
      "      }",
      "      sort(articulations.begin(), articulations.end());",
      "      sort(bridges.begin(), bridges.end());",
      "    }",
      "",
      "  private:",
      "    vector<vector<int>> G;",
      "    vector<int> ord, low;",
      "",
      "    void dfs(int id, int &k, int par) {",
      "      ord[id] = low[id] = k;",
      "      k++;",
      "",
      "      bool is_articulation = false;",
      "      int child_cnt = 0;",
      "",
      "      for (int to: G[id]) {",
      "        if (ord[to] == -1) {",
      "          child_cnt++;",
      "          dfs(to, k, id);",
      "",
      "          low[id] = min(low[id], low[to]);",
      "          if (par != -1 and ord[id] <= low[to]) is_articulation = true;",
      "          if (ord[id] < low[to]) bridges.emplace_back(min(id, to), max(id, to));",
      "        } else if (to != par) {",
      "          low[id] = min(low[id], ord[to]);",
      "        }",
      "      }",
      "",
      "      if (par == -1 and child_cnt >= 2) is_articulation = true;",
      "      if (is_articulation) articulations.emplace_back(id);",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of low_link",
    "scope": ""
  },
  "strongly-connected-component.hpp": {
    "prefix": "cppstrongly_connected_component",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <queue>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  class StronglyConnectedComponent {",
      "  private:",
      "    // sccは強連結成分ごとの集合",
      "    vector<vector<int>> G, rG, scc;",
      "    vector<int> groups, post_order;",
      "    vector<bool> arrived;",
      "    vector<pair<int, int>> edges;",
      "    int cnt;",
      "",
      "    void dfs(int idx) {",
      "      arrived[idx] = true;",
      "      for (int to: G[idx]) {",
      "        if (arrived[to]) continue;",
      "        dfs(to);",
      "      }",
      "      post_order.emplace_back(idx);",
      "    }",
      "",
      "    void rdfs(int idx, int num) {",
      "      arrived[idx] = true;",
      "      groups[idx] = num;",
      "      for (int to: rG[idx]) {",
      "        if (arrived[to]) continue;",
      "        rdfs(to, num);",
      "      }",
      "    }",
      "",
      "  public:",
      "    StronglyConnectedComponent(int V): G(V), rG(V) {}",
      "",
      "    void add_edge(int from, int to) {",
      "      G[from].emplace_back(to);",
      "      rG[to].emplace_back(from);",
      "      edges.emplace_back(from, to);",
      "    }",
      "",
      "    void build() {",
      "      int V = G.size();",
      "      arrived.assign(V, false);",
      "",
      "      for (int i = 0; i < V; i++) {",
      "        if (arrived[i]) continue;",
      "        dfs(i);",
      "      }",
      "",
      "      cnt = 0;",
      "      groups.assign(V, 0);",
      "      arrived.assign(V, false);",
      "      scc.resize(V);",
      "",
      "      for (int i = V - 1; i >= 0; i--) {",
      "        int idx = post_order[i];",
      "        if (arrived[idx]) continue;",
      "        rdfs(idx, cnt);",
      "        cnt++;",
      "      }",
      "",
      "      for (int i = 0; i < V; i++) {",
      "        scc[groups[i]].emplace_back(i);",
      "      }",
      "    }",
      "",
      "    // 強連結成分をトポロジカルソートしたもの",
      "    vector<vector<int>> topological_sort() {",
      "      vector<vector<int>> graph(cnt);",
      "      vector<int> in_degree(cnt);",
      "      for (int i = 0; i < static_cast<int>(edges.size()); i++) {",
      "        auto [from, to] = edges[i];",
      "        if (same(from, to)) continue;",
      "        graph[groups[from]].emplace_back(groups[to]);",
      "        in_degree[groups[to]]++;",
      "      }",
      "",
      "      queue<int> q;",
      "      for (int i = 0; i < cnt; i++) {",
      "        if (in_degree[i] == 0) q.push(i);",
      "      }",
      "",
      "      vector<vector<int>> res;",
      "      while (!q.empty()) {",
      "        int v = q.front();",
      "        q.pop();",
      "        res.emplace_back(scc[v]);",
      "        for (int to: graph[v]) {",
      "          in_degree[to]--;",
      "          if (in_degree[to] == 0) q.push(to);",
      "        }",
      "      }",
      "",
      "      return res;",
      "    }",
      "",
      "    int size() { return cnt; }",
      "",
      "    bool same(int a, int b) { return groups[a] == groups[b]; }",
      "",
      "    int operator[](int k) { return groups[k]; }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of strongly_connected_component",
    "scope": ""
  },
  "shortest-hamiltonian-path.hpp": {
    "prefix": "cppshortest_hamiltonian_path",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <limits>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  // 全頂点を1度だけ訪問したときの最短経路距離",
      "  // buildでinfが帰ってきたらそのような経路はない",
      "  template <typename T>",
      "  struct ShortestHamiltonianPath {",
      "    struct edge {",
      "      int to;",
      "      T cost;",
      "      edge(int to, T cost): to(to), cost(cost) {}",
      "    };",
      "",
      "    int V;",
      "    vector<vector<edge>> G;",
      "    vector<vector<T>> dp;",
      "",
      "    ShortestHamiltonianPath(int V_): V(V_), G(V_) {}",
      "",
      "    T inf() { return numeric_limits<T>::max() / 2; }",
      "",
      "    void add_edge(int from, int to, T cost) { G[from].emplace_back(to, cost); }",
      "",
      "    T build() {",
      "      T res = inf();",
      "      dp.assign(V, vector<T>(1 << V, -1));",
      "      for (int sv = 0; sv < V; sv++) {",
      "        res = min(res, dfs(sv, 1 << sv));",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // private method",
      "    T dfs(int v, int Set) {",
      "      T &res = dp[v][Set];",
      "      if (Set + 1 == 1 << V) res = 0;",
      "      if (res != -1) return res;",
      "      res = inf();",
      "      for (auto [to, cost]: G[v]) {",
      "        int bit = 1 << to;",
      "        if (Set & bit) continue;",
      "        res = min(res, dfs(to, Set | bit) + cost);",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of shortest_hamiltonian_path",
    "scope": ""
  },
  "tree.hpp": {
    "prefix": "cpptree",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "// WIP",
      "",
      "namespace graph {",
      "  // path_query    : op,e,inv",
      "  // subtree_query : op,e",
      "  // op   : T, T -> T (operation)",
      "  // e    : void -> T (identity element)",
      "  // inv  : T    -> T (inverse element)",
      "  // T is weight type and value type",
      "  template <typename T, T (*op)(T, T), T (*e)(), T (*inv)(T)>",
      "  class WeightedTree {",
      "  private:",
      "    struct SparseTable {",
      "      vector<vector<pair<int, int>>> st;",
      "      vector<int> lookup;",
      "",
      "      SparseTable() {}",
      "",
      "      void build(const vector<pair<int, int>> &v) {",
      "        int b = 0;",
      "        while ((1 << b) <= static_cast<int>(v.size()))",
      "          ++b;",
      "        st.assign(b, vector<pair<int, int>>(1 << b));",
      "        for (int i = 0; i < static_cast<int>(v.size()); i++) {",
      "          st[0][i] = v[i];",
      "        }",
      "        for (int i = 1; i < b; i++) {",
      "          for (int j = 0; j + (1 << i) <= (1 << b); j++) {",
      "            st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);",
      "          }",
      "        }",
      "        lookup.resize(v.size() + 1);",
      "        for (int i = 2; i < static_cast<int>(lookup.size()); i++) {",
      "          lookup[i] = lookup[i >> 1] + 1;",
      "        }",
      "      }",
      "",
      "      inline pair<int, int> query(int l, int r) {",
      "        int b = lookup[r - l];",
      "        return min(st[b][l], st[b][r - (1 << b)]);",
      "      }",
      "    };",
      "",
      "    class SegmentTree {",
      "    private:",
      "      int n;",
      "      vector<T> data;",
      "",
      "      T search(int l, int r) {",
      "        T vl = e(), vr = e();",
      "        l += n, r += n;",
      "        while (l < r) {",
      "          if (l & 1) vl = op(vl, data[l++]);",
      "          if (r & 1) vr = op(vr, data[--r]);",
      "          l >>= 1, r >>= 1;",
      "        }",
      "        return op(vl, vr);",
      "      }",
      "",
      "    public:",
      "      SegmentTree() {}",
      "",
      "      void assign(int _n) {",
      "        n = 1;",
      "        while (n < _n) {",
      "          n <<= 1;",
      "        }",
      "        data.assign(2 * n, e());",
      "      }",
      "",
      "      T get(int i) { return data[i + n]; }",
      "",
      "      void set(int i, T key) {",
      "        i += n;",
      "        data[i] = key;",
      "        while (i > 0) {",
      "          i >>= 1;",
      "          data[i] = op(data[i << 1 | 0], data[i << 1 | 1]);",
      "        }",
      "      }",
      "",
      "      void add(int i, T key) { set(i, get(i) + key); }",
      "",
      "      T prod(int l, int r) { return search(l, r); }",
      "",
      "      T all_prod() { return n != 0 ? data[0] : e(); }",
      "    };",
      "",
      "    SparseTable min_dep_idx;",
      "    SegmentTree data;",
      "    vector<int> in, out, dep, par, dia_to, edge_table;",
      "    pair<T, int> dia;",
      "    vector<vector<int>> doubling_par;",
      "    vector<vector<pair<int, T>>> G;",
      "    vector<T> data;",
      "    const int LOG;",
      "",
      "    void dfs(int v, int &time, int depth) {",
      "      in[v] = time;",
      "      dep[time] = depth;",
      "      edge_table[time++] = v;",
      "      for (auto to: G[v]) {",
      "        if (in[to] != -1) continue;",
      "        par[to] = v;",
      "        dfs(to, time, depth + 1);",
      "      }",
      "      out[v] = time;",
      "      dep[time] = depth - 1;",
      "      edge_table[time++] = -v;",
      "    }",
      "",
      "    pair<T, int> dfs_diameter(int v, int p) {",
      "      pair<T, int> res(0, v);",
      "      for (auto [to, cost]: G[v]) {",
      "        if (to == par) continue;",
      "        auto [ncost, u] = dfs_diameter(to, v);",
      "        if (res < make_pair(ncost + cost, u)) {",
      "          res = make_pair(ncost + cost);",
      "          dia_to[v] = to;",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "",
      "    // min({ x | 2^x > n })",
      "    int log_two(int n) {",
      "      int x = 1;",
      "      while ((1 << x) <= n) {",
      "        x++;",
      "      }",
      "      return x;",
      "    }",
      "",
      "  public:",
      "    WeightedTree(int n): G(n), data(n), LOG(log_two(n)), dia(-1) { data.assign(n); }",
      "",
      "    void add_edge(int from, int to, T cost = 1) { G[from].emplace_back(to, cost); }",
      "",
      "    T path_query(int v) { return data.prod(0, in[v] + 1); }",
      "",
      "    // O(log N)",
      "    T path_query(int u, int v) {",
      "      T res = op(path_query(u), path_query(v));",
      "      res = op(res, inv(path_query(lca(u, v))));",
      "      res = op(res, inv(path_query(lca(u, v))));",
      "      return res;",
      "    }",
      "",
      "    // O(log N)",
      "    T subtree_query(int v) { return data.prod(in[v], out[v]); }",
      "",
      "    // O(Nlog N)",
      "    void build(int s) {",
      "      int n = G.size();",
      "",
      "      dia_to.assign(n, -1);",
      "      dia = dfs_diameter(dfs_diameter(s, -1).second, -1);",
      "",
      "      in.assign(n, -1);",
      "      out.assign(n, -1);",
      "      par.assign(n, 0);",
      "      dep.assign(2 * n, 0);",
      "      edge_table.assign(2 * n, -1);",
      "      int time = 0;",
      "      dfs(s, time, 0);",
      "      dep.back() = s;",
      "",
      "      // build doubling parent",
      "      doubling_par.assign(LOG, vector<int>(n, -1));",
      "      for (int i = 0; i < n; i++) {",
      "        doubling_par[0][i] = par[i];",
      "      }",
      "      for (int k = 0; k < LOG - 1; k++) {",
      "        for (int i = 0; i < n; i++) {",
      "          if (doubling_par[k][i] == -1) {",
      "            doubling_par[k + 1][i] = -1;",
      "            continue;",
      "          }",
      "          doubling_par[k + 1][i] = doubling_par[k][doubling_par[k][i]];",
      "        }",
      "      }",
      "",
      "      // build sparse table",
      "      vector<pair<int, int>> dep_idx(dep.size());",
      "      for (int i = 0; i < static_cast<int>(dep.size()); i++) {",
      "        auto &[depth, idx] = dep_idx[i];",
      "        depth = dep[i];",
      "        idx = i;",
      "      }",
      "      min_dep_idx.build(dep_idx);",
      "    }",
      "",
      "    // O(1)",
      "    T diameter() { return dia.first; }",
      "",
      "    // O(N)",
      "    vector<int> diameter_path() {",
      "      int v = dia.second;",
      "      vector<int> path;",
      "      path.reserve(dia.first);",
      "      while (v != -1) {",
      "        path.emplace_back(v);",
      "        v = dia_to[v];",
      "      }",
      "      return path;",
      "    }",
      "",
      "    // O(1)",
      "    bool in_subtree(int subroot, int v) { return in[subroot] < in[v] and out[v] < out[subroot]; }",
      "",
      "    // O(1) : lowest common ancestor",
      "    int lca(int u, int v) {",
      "      int idx = min_dep_idx.query(min(in[u], in[v]), max(in[u], in[v]) + 1).second;",
      "      int res = edge_table[idx];",
      "      if (res < 0) res = par[-res];",
      "      return res;",
      "    }",
      "",
      "    // O(log N) : level ancestor",
      "    int la(int v, int depth) {",
      "      int anc = v;",
      "      for (int i = 0; i < LOG; i++) {",
      "        if (depth >> i & 1) anc = doubling_par[i][anc];",
      "      }",
      "      return anc;",
      "    }",
      "",
      "    // O(1)",
      "    int depth(int v) { return dep[in[v]]; }",
      "",
      "    // O(1)",
      "    int distance(int u, int v) { return depth(u) + depth(v) - 2 * depth(lca(u, v)); }",
      "",
      "    // O(1) : from v to root move k step",
      "    int up(int v, int k) { return la(v, depth(v) - k); }",
      "",
      "    // O(1) : from u to v move k step",
      "    int next(int u, int v, int k = 1) {",
      "      if (k <= distance(u, lca(u, v))) return up(u, k);",
      "      return up(v, distance(v, lca(u, v)) - k);",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of tree",
    "scope": ""
  },
  "topological-sort.hpp": {
    "prefix": "cpptopological_sort",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <queue>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  struct TopologicalSort {",
      "    vector<vector<int>> G;",
      "    vector<int> in_degree;",
      "",
      "    TopologicalSort(int V): G(V), in_degree(V, 0) {}",
      "",
      "    void add_edge(int from, int to) {",
      "      G[from].emplace_back(to);",
      "      in_degree[to]++;",
      "    }",
      "",
      "    vector<int> build() {",
      "      int V = G.size();",
      "      queue<int> q;",
      "      for (int i = 0; i < V; i++) {",
      "        if (in_degree[i] == 0) q.push(i);",
      "      }",
      "",
      "      vector<int> res;",
      "      while (!q.empty()) {",
      "        int v = q.front();",
      "        q.pop();",
      "        res.emplace_back(v);",
      "        for (int to: G[v]) {",
      "          in_degree[to]--;",
      "          if (in_degree[to] == 0) q.push(to);",
      "        }",
      "      }",
      "",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of topological_sort",
    "scope": ""
  },
  "dijkstra.hpp": {
    "prefix": "cppdijkstra",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <limits>",
      "#include <queue>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  template <typename T>",
      "  struct Dijkstra {",
      "    struct edge {",
      "      int to;",
      "      T cost;",
      "      edge() {}",
      "      edge(int to, T cost): to(to), cost(cost) {}",
      "      bool operator<(const edge &e) const { return cost > e.cost; }",
      "    };",
      "",
      "    T inf() { return numeric_limits<T>::max() / 2; }",
      "",
      "    vector<vector<edge>> G;",
      "    vector<T> ds;",
      "    vector<int> bs;",
      "    vector<pair<int, pair<int, T>>> es;",
      "    Dijkstra(int n): G(n) {}",
      "",
      "    void add_edge(int from, int to, T cost) {",
      "      G[from].emplace_back(to, cost);",
      "      es.emplace_back(from, to, cost);",
      "    }",
      "",
      "    void build(int start) {",
      "      int n = G.size();",
      "      ds.assign(n, inf());",
      "      bs.assign(n, -1);",
      "",
      "      priority_queue<edge> Q;",
      "      ds[start] = 0;",
      "      Q.emplace(start, ds[start]);",
      "",
      "      while (!Q.empty()) {",
      "        auto p = Q.top();",
      "        Q.pop();",
      "        int v = p.to;",
      "        if (ds[v] < p.cost) continue;",
      "        for (auto e: G[v]) {",
      "          if (ds[e.to] > ds[v] + e.cost) {",
      "            ds[e.to] = ds[v] + e.cost;",
      "            bs[e.to] = v;",
      "            Q.emplace(e.to, ds[e.to]);",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    T operator[](int k) { return ds[k]; }",
      "",
      "    pair<int, pair<int, T>> get_edge(int k) { return es[k]; }",
      "",
      "    vector<pair<int, pair<int, T>>> edges() { return es; }",
      "",
      "    vector<int> restore(int to) {",
      "      vector<int> res;",
      "      if (bs[to] == -1) {",
      "        res.emplace_back(to);",
      "        return res;",
      "      }",
      "      while (to != -1) {",
      "        res.emplace_back(to);",
      "        to = bs[to];",
      "      }",
      "      reverse(res.begin(), res.end());",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of dijkstra",
    "scope": ""
  },
  "warshall-floyd.hpp": {
    "prefix": "cppwarshall_floyd",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <limits>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  template <typename T>",
      "  struct WarshallFloyd {",
      "    vector<vector<T>> ds;",
      "    vector<vector<int>> ns;",
      "",
      "    T inf() { return numeric_limits<T>::max() / 2; }",
      "",
      "    WarshallFloyd(int V): ds(V, vector<T>(V, inf())) {",
      "      for (int i = 0; i < V; i++)",
      "        ds[i][i] = 0;",
      "    }",
      "",
      "    void add_edge(int from, int to, T cost) { ds[from][to] = cost; }",
      "",
      "    void build() {",
      "      int V = ds.size();",
      "",
      "      ns.resize(V, vector<int>(V));",
      "      for (int i = 0; i < V; i++) {",
      "        for (int j = 0; j < V; j++) {",
      "          ns[i][j] = j;",
      "        }",
      "      }",
      "",
      "      for (int k = 0; k < V; k++) {",
      "        for (int i = 0; i < V; i++) {",
      "          for (int j = 0; j < V; j++) {",
      "            if (ds[i][k] == inf() or ds[k][j] == inf()) continue;",
      "            if (ds[i][j] > ds[i][k] + ds[k][j]) {",
      "              ds[i][j] = ds[i][k] + ds[k][j];",
      "              ns[i][j] = ns[i][k];",
      "            }",
      "          }",
      "        }",
      "      }",
      "    }",
      "",
      "    vector<T> &operator[](int k) { return ds[k]; }",
      "",
      "    bool neg_cycle() {",
      "      int V = ds.size();",
      "      for (int i = 0; i < V; i++) {",
      "        if (ds[i][i] < 0) return true;",
      "      }",
      "      return true;",
      "    }",
      "",
      "    vector<int> restore(int s, int g) {",
      "      vector<int> res;",
      "      for (int v = s; v != g; v = ns[v][g]) {",
      "        res.emplace_back(v);",
      "      }",
      "      res.emplace_back(g);",
      "      return res;",
      "    }",
      "  };",
      "} // namespace graph"
    ],
    "description": "Template of warshall_floyd",
    "scope": ""
  },
  "grid-bfs.hpp": {
    "prefix": "cppgrid_bfs",
    "body": [
      "namespace graph {",
      "  using namespace std;",
      "}",
      "",
      "#include <queue>",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace graph {",
      "  vector<vector<int>> grid_bfs(vector<string> &s, char start, const string &wall = \"#\") {",
      "    constexpr int dy[] = { 0, 1, 0, -1 }, dx[] = { 1, 0, -1, 0 };",
      "    int h = s.size(), w = s[0].size();",
      "    vector<vector<int>> res(h, vector<int>(w, -1));",
      "    queue<pair<int, int>> q;",
      "    for (int i = 0; i < h; i++) {",
      "      for (int j = 0; j < w; j++) {",
      "        if (s[i][j] == start) {",
      "          q.emplace(i, j);",
      "          res[i][j] = 0;",
      "        }",
      "      }",
      "    }",
      "    while (!q.empty()) {",
      "      auto p = q.front();",
      "      q.pop();",
      "      for (int i = 0; i < 4; i++) {",
      "        int ny = p.first + dy[i], nx = p.second + dx[i];",
      "        if (ny < 0 or nx < 0 or ny >= h or nx >= w) continue;",
      "        if (res[ny][nx] != -1) continue;",
      "        if (wall.find(s[ny][nx]) != string::npos) continue;",
      "        res[ny][nx] = res[p.first][p.second] + 1;",
      "        q.emplace(ny, nx);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "} // namespace graph"
    ],
    "description": "Template of grid_bfs",
    "scope": ""
  },
  "is-prime.hpp": {
    "prefix": "cppis_prime",
    "body": [
      "namespace math {",
      "  bool is_prime(int n) {",
      "    if (n <= 1) return false;",
      "    for (int i = 2; i * i <= n; i++) {",
      "      if (n % i == 0) return false;",
      "    }",
      "    return true;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of is_prime",
    "scope": ""
  },
  "mod-factorial.hpp": {
    "prefix": "cppmod_factorial",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  using mint = atcoder::modint1000000007;",
      "  template <typename ModInt = mint>",
      "  class ModFactorial {",
      "    vector<ModInt> fact, invfact;",
      "",
      "    int min_pow2_greater_equal_than(int k) {",
      "      int pow2 = 1;",
      "      while (pow2 < k) {",
      "        pow2 <<= 1;",
      "      }",
      "      return pow2;",
      "    }",
      "",
      "  public:",
      "    ModFactorial(): fact(1, 1), invfact(1, 1) {}",
      "",
      "    ModInt factorial(int k) {",
      "      if (k < 0) return 0;",
      "      if (k < static_cast<int>(fact.size())) return fact[k];",
      "",
      "      int pow2 = min_pow2_greater_equal_than(k);",
      "      int old_size = fact.size();",
      "      fact.resize(pow2 + 1);",
      "",
      "      for (int i = old_size - 1; i < pow2; i++) {",
      "        fact[i + 1] = fact[i] * ModInt(i + 1);",
      "      }",
      "      return fact[k];",
      "    }",
      "",
      "    ModInt inv_factorial(int k) {",
      "      if (k < 0) return 0;",
      "      if (k < static_cast<int>(invfact.size())) return invfact[k];",
      "",
      "      int pow2 = min_pow2_greater_equal_than(k);",
      "      int old_size = fact.size();",
      "      invfact.resize(pow2 + 1);",
      "",
      "      invfact[pow2] = ModInt(1) / factorial(pow2);",
      "      for (int i = pow2; i > old_size; i--) {",
      "        invfact[i - 1] = invfact[i] * ModInt(i);",
      "      }",
      "      return invfact[k];",
      "    }",
      "",
      "    ModInt inv(int k) { return ModInt(1) / ModInt(k); }",
      "",
      "    ModInt permutation(int n, int k) { return factorial(n) * inv_factorial(n - k); }",
      "    ModInt combination(int n, int k) { return factorial(n) * inv_factorial(k) * inv_factorial(n - k); }",
      "    ModInt homogeneous(int n, int k) { return combination(n + k - 1, k); }",
      "  };",
      "} // namespace math"
    ],
    "description": "Template of mod_factorial",
    "scope": ""
  },
  "factorize.hpp": {
    "prefix": "cppfactorize",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  vector<ll> factorize(ll n) {",
      "    vector<ll> res;",
      "    for (ll i = 2; i * i <= n; i++) {",
      "      while (n % i == 0) {",
      "        res.emplace_back(i);",
      "        n /= i;",
      "      }",
      "    }",
      "    if (n > 1) res.emplace_back(n);",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of factorize",
    "scope": ""
  },
  "binomial.hpp": {
    "prefix": "cppbinomial",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "namespace math {",
      "  ll binomial(ll n, ll r) {",
      "    ll res = 1;",
      "    for (ll i = 0; i < r; i++) {",
      "      res *= n - i;",
      "      res /= i + 1;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of binomial",
    "scope": ""
  },
  "totient.hpp": {
    "prefix": "cpptotient",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "namespace math {",
      "  ll totient(ll n) {",
      "    ll res = n;",
      "    for (ll i = 2; i * i <= n; i++) {",
      "      if (n % i == 0) {",
      "        res -= res / i;",
      "        while (n % i == 0)",
      "          n /= i;",
      "      }",
      "    }",
      "    if (n > 1) res -= res / n;",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of totient",
    "scope": ""
  },
  "segment-sieve.hpp": {
    "prefix": "cppsegment_sieve",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <cassert>",
      "#include <cmath>",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace math {",
      "  class SegmentSieve {",
      "    ll l, r, sqrt_r;",
      "    vector<int> small_sieve;",
      "    vector<vector<ll>> large_sieve;",
      "    vector<ll> aux; // aux[i] := large_sieve[i] の素因数の積",
      "",
      "  public:",
      "    SegmentSieve(ll l, ll r): l(l), r(r), sqrt_r(sqrt(r) + 1) {",
      "      small_sieve.resize(sqrt_r);",
      "      iota(small_sieve.begin(), small_sieve.end(), 0);",
      "      large_sieve.resize(r - l);",
      "      aux.assign(r - l, 1);",
      "",
      "      for (ll i = 2; i * i < r; i++) {",
      "        if (small_sieve[i] < i) continue;",
      "",
      "        small_sieve[i] = i;",
      "        for (ll j = i * i; j < sqrt_r; j += i) {",
      "          if (small_sieve[j] == j) small_sieve[j] = i;",
      "        }",
      "",
      "        ll begin = (l + i - 1) / i * i;",
      "",
      "        for (ll j = begin; j < r; j += i) {",
      "          ll k = j;",
      "          do {",
      "            // aux[j - l] > sqrt_r ?",
      "            if (aux[j - l] * aux[j - l] > r) break;",
      "",
      "            large_sieve[j - l].push_back(i);",
      "            aux[j - l] *= i;",
      "            k /= i;",
      "          } while (k % i == 0);",
      "        }",
      "      }",
      "    }",
      "",
      "    vector<ll> factor(ll n) {",
      "      assert(l <= n and n < r);",
      "",
      "      vector<ll> res = large_sieve[n - l];",
      "      n /= aux[n - l];",
      "",
      "      if (n >= sqrt_r) {",
      "        res.push_back(n);",
      "        return res;",
      "      }",
      "",
      "      while (n > 1) {",
      "        res.push_back(small_sieve[n]);",
      "        n /= small_sieve[n];",
      "      }",
      "",
      "      return res;",
      "    }",
      "  };",
      "}; // namespace math"
    ],
    "description": "Template of segment_sieve",
    "scope": ""
  },
  "partition-table.hpp": {
    "prefix": "cpppartition_table",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  template <typename T>",
      "  vector<vector<T>> PartitionTable(int n, int k) {",
      "    vector<vector<T>> dp(n + 1, vector<T>(k + 1));",
      "    dp[0][0] = 1;",
      "    for (int i = 0; i <= n; i++) {",
      "      for (int j = 1; j <= k; j++) {",
      "        if (i - j >= 0)",
      "          dp[i][j] = dp[i][j - 1] + dp[i - j][j];",
      "        else",
      "          dp[i][j] = dp[i][j - 1];",
      "      }",
      "    }",
      "    return dp;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of partition_table",
    "scope": ""
  },
  "fibonacci.hpp": {
    "prefix": "cppfibonacci",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "// WIP",
      "",
      "namespace math {",
      "  template <typename T>",
      "  struct matrix {",
      "    vector<vector<T>> dat;",
      "",
      "    matrix(int r, int c): dat(r, vector<T>(c, 0)) {}",
      "    matrix(vector<vector<T>> _dat): dat(_dat) {}",
      "",
      "    size_t size() const { return dat.size(); }",
      "    bool empty() const { return dat.empty(); }",
      "  };",
      "",
      "  long long fibonacci(long long n) {",
      "    long long f0 = 1, f1 = 1;",
      "    // {(1,1),(1,0)}",
      "",
      "",
      "    // if ( p <= 1 ) return 0;",
      "    // if ( p == 0 ) p = numeric_limits<T>::max();",
      "    // T res = 1;",
      "    // while ( e > 0 ) {",
      "    //   if ( e & 1 ) res = (res * a) % p;",
      "    //   a = (a * a) % p;",
      "    //   e >>= 1;",
      "    // }",
      "    // return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of fibonacci",
    "scope": ""
  },
  "lucas-combination.hpp": {
    "prefix": "cpplucas_combination",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  struct LucasCombination {",
      "    vector<vector<ll>> data;",
      "    int MOD;",
      "    LucasCombination(int MOD_) {",
      "      MOD = MOD_;",
      "      data.assign(MOD + 1, vector<ll>(MOD + 1, 0));",
      "      data[0][0] = 1;",
      "      for (int i = 0; i < MOD; i++) {",
      "        for (int j = 0; j <= i; j++) {",
      "          data[i + 1][j] += data[i][j];",
      "          data[i + 1][j] %= MOD;",
      "          data[i + 1][j + 1] += data[i][j];",
      "          data[i + 1][j + 1] %= MOD;",
      "        }",
      "      }",
      "    }",
      "",
      "    ll query(int n, int r) {",
      "      ll res = 1;",
      "      while (n > 0) {",
      "        int ni = n % MOD;",
      "        int ri = r % MOD;",
      "        res *= data[ni][ri];",
      "        res %= MOD;",
      "        n /= MOD;",
      "        r /= MOD;",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace math"
    ],
    "description": "Template of lucas_combination",
    "scope": ""
  },
  "count-factor.hpp": {
    "prefix": "cppcount_factor",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <cstdint>",
      "#include <vector>",
      "",
      "namespace math {",
      "  vector<int> count_factor(int N) {",
      "    constexpr int INF = INT32_MAX / 2;",
      "    vector<int> table(N + 1, 0);",
      "",
      "    for (int i = 2; i <= N; i++) {",
      "      if (table[i]) continue;",
      "      table[i] = 1;",
      "      for (int j = 2 * i; j <= N; j += i) {",
      "        if (j % (i * i) == 0)",
      "          table[j] = -INF;",
      "        else",
      "          table[j]++;",
      "      }",
      "    }",
      "    return table;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of count_factor",
    "scope": ""
  },
  "factorize-table.hpp": {
    "prefix": "cppfactorize_table",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  struct FactorizeTable {",
      "    vector<int> ps;",
      "    FactorizeTable(int N): ps(N + 1, 1) {}",
      "",
      "    void build() {",
      "      int N = ps.size();",
      "      for (ll i = 2; i <= N; i++) {",
      "        if (ps[i] != 1) continue;",
      "        ps[i] = i;",
      "        for (ll j = i * i; j <= N; j += i) {",
      "          if (ps[j] != 1) continue;",
      "          ps[j] = i;",
      "        }",
      "      }",
      "    }",
      "",
      "    vector<int> factorize(int x) {",
      "      vector<int> res;",
      "      while (ps[x] != 1) {",
      "        res.push_back(ps[x]);",
      "        x /= ps[x];",
      "      }",
      "      return res;",
      "    }",
      "",
      "    bool is_prime(int k) {",
      "      if (k <= 1) return false;",
      "      return ps[k] == k;",
      "    }",
      "",
      "    int operator[](int i) { return ps[i]; }",
      "  };",
      "} // namespace math"
    ],
    "description": "Template of factorize_table",
    "scope": ""
  },
  "extgcd.hpp": {
    "prefix": "cppextgcd",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "namespace math {",
      "  ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "    if (b == 0) {",
      "      x = 1;",
      "      y = 0;",
      "      return a;",
      "    }",
      "    ll d = extgcd(b, a % b, y, x);",
      "    y = y - (a / b) * x;",
      "    return d;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of extgcd",
    "scope": ""
  },
  "convert-base.hpp": {
    "prefix": "cppconvert_base",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  // from-ary n -> to-ary n",
      "  template <typename T>",
      "  vector<T> convert_base(vector<T> n, T from, T to) {",
      "    auto to_base = [&](T n, T b) {",
      "      if (n == 0 or b <= 1) return vector<T>{ 0 };",
      "      vector<T> res;",
      "      for (; n > 0; n /= b) {",
      "        res.emplace_back(n % b);",
      "      }",
      "      reverse(res.begin(), res.end());",
      "      return res;",
      "    };",
      "",
      "    auto to_decimal = [&](vector<T> n, T b) {",
      "      T res = 0, x = 1;",
      "      for (int i = n.size() - 1; i >= 0; i--, x *= b) {",
      "        res += x * (n[i]);",
      "      }",
      "      return res;",
      "    };",
      "",
      "    T temp = to_decimal(n, from);",
      "    return to_base(temp, to);",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of convert_base",
    "scope": ""
  },
  "alternative-totient.hpp": {
    "prefix": "cppalternative_totient",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  vector<ll> factorize(ll n) {",
      "    vector<ll> res;",
      "    for (ll i = 2; i * i <= n; i++) {",
      "      while (n % i == 0) {",
      "        res.emplace_back(i);",
      "        n /= i;",
      "      }",
      "    }",
      "    if (n > 1) res.emplace_back(n);",
      "    return res;",
      "  }",
      "} // namespace math",
      "",
      "#include <algorithm>",
      "",
      "namespace math {",
      "  long long alternative_totient(long long x, long long n) {",
      "    if (x == 1) return n;",
      "    auto ps = factorize(x);",
      "    ps.erase(unique(ps.begin(), ps.end()), ps.end());",
      "    int k = ps.size();",
      "    long long res = n - x;",
      "    for (int i = 1; i < (1 << k); i++) {",
      "      long long prod = 1;",
      "      int cnt = 0;",
      "      for (int j = 0; j < k; j++) {",
      "        if (i >> j & 1) {",
      "          prod *= ps[j];",
      "          cnt++;",
      "        }",
      "      }",
      "      if (cnt % 2) {",
      "        res += (n - x) / prod;",
      "      } else {",
      "        res -= (n - x) / prod;",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of alternative_totient",
    "scope": ""
  },
  "floor-div.hpp": {
    "prefix": "cppfloor_div",
    "body": [
      "namespace math {",
      "  template <typename T>",
      "  T floor_div(T n, T d) {",
      "    assert(d != 0);",
      "    return n / d - (((n ^ d) < 0) and (n % d));",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of floor_div",
    "scope": ""
  },
  "to-base.hpp": {
    "prefix": "cppto_base",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace math {",
      "  // decimal n -> b-ary",
      "  template <typename T>",
      "  vector<T> to_base(T n, T b) {",
      "    if (n == 0 or b <= 1) return vector<T>{ 0 };",
      "    vector<T> res;",
      "    for (; n > 0; n /= b) {",
      "      res.emplace_back(n % b);",
      "    }",
      "    reverse(res.begin(), res.end());",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of to_base",
    "scope": ""
  },
  "binomial-table.hpp": {
    "prefix": "cppbinomial_table",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  template <typename T>",
      "  struct BinomialTable {",
      "    vector<vector<T>> data;",
      "    BinomialTable(int N) {",
      "      data.assign(N + 1, vector<T>(N + 1, 0));",
      "      data[0][0] = 1;",
      "      for (int i = 0; i < N; i++) {",
      "        for (int j = 0; j <= i; j++) {",
      "          data[i + 1][j] += data[i][j];",
      "          data[i + 1][j + 1] += data[i][j];",
      "        }",
      "      }",
      "    }",
      "",
      "    T query(int n, int r) { return data[n][r]; }",
      "  };",
      "} // namespace math"
    ],
    "description": "Template of binomial_table",
    "scope": ""
  },
  "divisor.hpp": {
    "prefix": "cppdivisor",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace math {",
      "  vector<ll> divisor(ll n) {",
      "    vector<ll> res;",
      "    for (ll i = 1; i * i <= n; i++) {",
      "      if (n % i == 0) {",
      "        res.emplace_back(i);",
      "        if (i * i != n) res.emplace_back(n / i);",
      "      }",
      "    }",
      "    sort(res.begin(), res.end());",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of divisor",
    "scope": ""
  },
  "ceil-div.hpp": {
    "prefix": "cppceil_div",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <cassert>",
      "",
      "namespace math {",
      "  ll ceil_div(ll n, ll d) {",
      "    assert(d != 0);",
      "    return n / d + (((n ^ d) >= 0) and (n % d));",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of ceil_div",
    "scope": ""
  },
  "divisor-table.hpp": {
    "prefix": "cppdivisor_table",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  struct DivisorTable {",
      "    vector<int> smallest_ps;",
      "    DivisorTable(int N): smallest_ps(N + 1, 1) {}",
      "",
      "    void build() {",
      "      int N = smallest_ps.size();",
      "      for (long long i = 2; i <= N; i++) {",
      "        if (smallest_ps[i] != 1) continue;",
      "        smallest_ps[i] = i;",
      "        for (long long j = i * i; j <= N; j += i) {",
      "          if (smallest_ps[j] != 1) continue;",
      "          smallest_ps[j] = i;",
      "        }",
      "      }",
      "    }",
      "",
      "    // M := count({ p = prime, p|x })",
      "    // O(M2^M log x)",
      "    vector<int> divisor(int x) {",
      "      vector<int> ps;",
      "      while (smallest_ps[x] != 1) {",
      "        ps.push_back(smallest_ps[x]);",
      "        x /= smallest_ps[x];",
      "      }",
      "      int m = ps.size();",
      "      vector<int> ds(1 << m);",
      "      for (int i = 0; i < (1 << m); i++) {",
      "        int prod = 1;",
      "        for (int j = 0; j < m; j++) {",
      "          if (i >> j & 1) prod *= ps[j];",
      "        }",
      "        ds[i] = prod;",
      "      }",
      "      return ds;",
      "    }",
      "",
      "    bool is_prime(int k) {",
      "      if (k <= 1) return false;",
      "      return smallest_ps[k] == k;",
      "    }",
      "",
      "    int operator[](int i) { return smallest_ps[i]; }",
      "  };",
      "} // namespace math"
    ],
    "description": "Template of divisor_table",
    "scope": ""
  },
  "alternative-totient-table.hpp": {
    "prefix": "cppalternative_totient_table",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "",
      "#include <cstdint>",
      "#include <vector>",
      "",
      "namespace math {",
      "  vector<int> count_factor(int N) {",
      "    constexpr int INF = INT32_MAX / 2;",
      "    vector<int> table(N + 1, 0);",
      "",
      "    for (int i = 2; i <= N; i++) {",
      "      if (table[i]) continue;",
      "      table[i] = 1;",
      "      for (int j = 2 * i; j <= N; j += i) {",
      "        if (j % (i * i) == 0)",
      "          table[j] = -INF;",
      "        else",
      "          table[j]++;",
      "      }",
      "    }",
      "    return table;",
      "  }",
      "} // namespace math",
      "",
      "",
      "namespace math {",
      "  // Θ(NloglogN)",
      "  vector<int> alternative_totient_table(int N) {",
      "    vector<int> table = count_factor(N);",
      "",
      "    vector<int> alt(N + 1, 0);",
      "    alt[1] = N;",
      "    for (int i = 2; i <= N; i++) {",
      "      alt[i] = N - i;",
      "    }",
      "",
      "    for (int i = 2; i <= N; i++) {",
      "      if (table[i] < 0) continue;",
      "",
      "      for (int j = i; j < N; j += i) {",
      "        if (table[i] % 2) {",
      "          alt[j] -= (N - j) / i;",
      "        } else {",
      "          alt[j] += (N - j) / i;",
      "        }",
      "      }",
      "    }",
      "    return alt;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of alternative_totient_table",
    "scope": ""
  },
  "eratosthenes-sieve.hpp": {
    "prefix": "cpperatosthenes_sieve",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  struct EratosthenesSieve {",
      "    vector<bool> prime_table;",
      "",
      "    EratosthenesSieve() {}",
      "    EratosthenesSieve(int N): prime_table(N + 1, true) { prime_table[0] = prime_table[1] = false; }",
      "",
      "    void build() {",
      "      int n = prime_table.size();",
      "      for (ll i = 2; i * i < n; i++) {",
      "        if (!prime_table[i]) continue;",
      "        for (ll j = i * i; j < n; j += i) {",
      "          prime_table[j] = false;",
      "        }",
      "      }",
      "    }",
      "",
      "    bool operator[](int k) { return prime_table[k]; }",
      "  };",
      "} // namespace math"
    ],
    "description": "Template of eratosthenes_sieve",
    "scope": ""
  },
  "totient-table.hpp": {
    "prefix": "cpptotient_table",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <vector>",
      "",
      "namespace math {",
      "  vector<int> totient_table(int n) {",
      "    vector<int> euler(n + 1);",
      "    for (int i = 0; i <= n; i++) {",
      "      euler[i] = i;",
      "    }",
      "    for (int i = 2; i <= n; i++) {",
      "      if (euler[i] == i) {",
      "        for (int j = i; j <= n; j += i) {",
      "          euler[j] = euler[j] / i * (i - 1);",
      "        }",
      "      }",
      "    }",
      "    return euler;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of totient_table",
    "scope": ""
  },
  "logarithm.hpp": {
    "prefix": "cpplogarithm",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <cassert>",
      "",
      "namespace math {",
      "  int logarithm(ll base, ll n) {",
      "    assert(base != 0);",
      "    int cnt = 0;",
      "    while (n % base == 0) {",
      "      n /= base;",
      "      cnt++;",
      "    }",
      "    return cnt;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of logarithm",
    "scope": ""
  },
  "fast-factorize.hpp": {
    "prefix": "cppfast_factorize",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "#include <atcoder/modint>",
      "#include <cstdint>",
      "#include <cstdlib>",
      "#include <vector>",
      "",
      "namespace math {",
      "  namespace inner {",
      "    using u32 = uint32_t;",
      "    using u64 = uint64_t;",
      "    using i64 = int64_t;",
      "    using u128 = __uint128_t;",
      "",
      "    u64 gcd_impl(u64 n, u64 m) {",
      "      constexpr u64 K = 5;",
      "      for (int i = 0; i < 80; ++i) {",
      "        u64 t = n - m;",
      "        u64 s = n - m * K;",
      "        bool q = t < m;",
      "        bool p = t < m * K;",
      "        n = q ? m : t;",
      "        m = q ? t : m;",
      "        if (m == 0) return n;",
      "        n = p ? n : s;",
      "      }",
      "      return gcd_impl(m, n % m);",
      "    }",
      "",
      "    u64 gcd_pre(u64 n, u64 m) {",
      "      for (int i = 0; i < 4; ++i) {",
      "        u64 t = n - m;",
      "        bool q = t < m;",
      "        n = q ? m : t;",
      "        m = q ? t : m;",
      "        if (m == 0) return n;",
      "      }",
      "      return gcd_impl(n, m);",
      "    }",
      "",
      "    u64 gcd_fast(u64 n, u64 m) { return n > m ? gcd_pre(n, m) : gcd_pre(m, n); }",
      "",
      "    struct modint64 {",
      "      using u64 = uint64_t;",
      "",
      "    public:",
      "      static u64 mod;",
      "      static u64 r, n2;",
      "      static void set_mod(u64 m) {",
      "        mod = m;",
      "        n2 = -u128(m) % m;",
      "        r = get_r();",
      "        assert(r * mod == 1);",
      "      }",
      "      modint64(): a(0) {}",
      "      modint64(const i64 &b): a(reduce((u128(b) + mod) * n2)) {}",
      "",
      "      modint64 &operator+=(const modint64 &b) {",
      "        if (i64(a += b.a - 2 * mod) < 0) a += 2 * mod;",
      "        return *this;",
      "      }",
      "",
      "      modint64 &operator-=(const modint64 &b) {",
      "        if (i64(a -= b.a) < 0) a += 2 * mod;",
      "        return *this;",
      "      }",
      "",
      "      modint64 &operator*=(const modint64 &b) {",
      "        a = reduce(u128(a) * b.a);",
      "        return *this;",
      "      }",
      "",
      "      modint64 &operator/=(const modint64 &b) {",
      "        *this *= b.inverse();",
      "        return *this;",
      "      }",
      "",
      "      modint64 operator+(const modint64 &b) const { return modint64(*this) += b; }",
      "      modint64 operator-(const modint64 &b) const { return modint64(*this) -= b; }",
      "      modint64 operator*(const modint64 &b) const { return modint64(*this) *= b; }",
      "      modint64 operator/(const modint64 &b) const { return modint64(*this) /= b; }",
      "",
      "      modint64 pow(u128 n) const {",
      "        modint64 ret(1), mul(*this);",
      "        while (n > 0) {",
      "          if (n & 1) ret *= mul;",
      "          mul *= mul;",
      "          n >>= 1;",
      "        }",
      "        return ret;",
      "      }",
      "",
      "      modint64 inverse() const { return pow(mod - 2); }",
      "",
      "      u64 val() const {",
      "        u64 ret = reduce(a);",
      "        return ret >= mod ? ret - mod : ret;",
      "      }",
      "",
      "      static u64 get_mod() { return mod; }",
      "",
      "    private:",
      "      u64 a;",
      "",
      "      static u64 get_r() {",
      "        u64 ret = mod;",
      "        for (int i = 0; i < 5; i++)",
      "          ret *= 2 - mod * ret;",
      "        return ret;",
      "      }",
      "",
      "      static u64 reduce(const u128 &b) { return (b + u128(u64(b) * u64(-r)) * mod) >> 64; }",
      "    };",
      "    typename modint64::u64 modint64::mod, modint64::r, modint64::n2;",
      "",
      "    u64 rnd() {",
      "      static u64 x = 10150724397891781847ull;",
      "      x ^= x << 7;",
      "      return x ^= x >> 9;",
      "    }",
      "",
      "    bool is_prime(const u64 n) {",
      "      if (~n & 1) return n == 2;",
      "      if (n < (1ll << 30)) return atcoder::internal::is_prime_constexpr(n);",
      "      u64 d = n - 1;",
      "      while (~d & 1)",
      "        d >>= 1;",
      "      if (modint64::get_mod() != n) modint64::set_mod(n);",
      "      for (const u64 a: { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 }) {",
      "        if (n <= a) break;",
      "        modint64 t = d, y = modint64(a).pow(d);",
      "        while (t.val() != n - 1 and y.val() != 1 and y.val() != n - 1) {",
      "          y *= y;",
      "          t *= 2;",
      "        }",
      "        if (y.val() != n - 1 and ~t.val() & 1) return false;",
      "      }",
      "      return true;",
      "    }",
      "",
      "    u64 pollard_rho(const u64 n) {",
      "      if (~n & 1) return 2;",
      "      if (is_prime(n)) return n;",
      "      if (modint64::get_mod() != n) modint64::set_mod(n);",
      "      modint64 R, one = 1;",
      "      auto f = [&](modint64 x) {",
      "        return x * x + R;",
      "      };",
      "      auto rng = [&]() {",
      "        return rnd() % (n - 2) + 2;",
      "      };",
      "      for (;;) {",
      "        modint64 x, y(rng()), ys, q = one;",
      "        R = rng();",
      "        u64 g = 1;",
      "        constexpr int m = 128;",
      "        for (int r = 1; g == 1; r <<= 1) {",
      "          x = y;",
      "          for (int i = 0; i < r; i++)",
      "            y = f(y);",
      "          for (int k = 0; g == 1 and k < r; k += m) {",
      "            ys = y;",
      "            for (int i = 0; i < m and i < r - k; i++)",
      "              q *= x - (y = f(y));",
      "            g = gcd_fast(q.val(), n);",
      "          }",
      "        }",
      "        if (g == n) do",
      "            g = gcd_fast((x - (ys = f(ys))).val(), n);",
      "          while (g == 1);",
      "        if (g != n) return g;",
      "      }",
      "      exit(1);",
      "    }",
      "",
      "    std::vector<u64> factorize(const u64 n) {",
      "      if (n == 1) return {};",
      "      if (is_prime(n)) return { n };",
      "      auto d = pollard_rho(n);",
      "      auto res = factorize(d);",
      "      auto sub = factorize(n / d);",
      "      std::copy(sub.begin(), sub.end(), std::back_inserter(res));",
      "      return res;",
      "    }",
      "",
      "  }; // namespace inner",
      "  using inner::is_prime;",
      "",
      "  template <typename ll>",
      "  std::vector<ll> fast_factorize(const ll n) {",
      "    auto tmp = inner::factorize(n);",
      "    std::vector<ll> res{ tmp.begin(), tmp.end() };",
      "    std::sort(res.begin(), res.end());",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of fast_factorize",
    "scope": ""
  },
  "mod-inv.hpp": {
    "prefix": "cppmod_inv",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "",
      "namespace math {",
      "  ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "    if (b == 0) {",
      "      x = 1;",
      "      y = 0;",
      "      return a;",
      "    }",
      "    ll d = extgcd(b, a % b, y, x);",
      "    y = y - (a / b) * x;",
      "    return d;",
      "  }",
      "} // namespace math",
      "",
      "namespace math {",
      "  ll modinv(ll n, ll mod) {",
      "    ll x, y;",
      "    extgcd(n, mod, x, y);",
      "    return (x % mod + mod) % mod;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of mod_inv",
    "scope": ""
  },
  "power.hpp": {
    "prefix": "cpppower",
    "body": [
      "namespace math {",
      "  using namespace std;",
      "  using ll = long long;",
      "} // namespace math",
      "",
      "",
      "namespace math {",
      "  ll extgcd(ll a, ll b, ll &x, ll &y) {",
      "    if (b == 0) {",
      "      x = 1;",
      "      y = 0;",
      "      return a;",
      "    }",
      "    ll d = extgcd(b, a % b, y, x);",
      "    y = y - (a / b) * x;",
      "    return d;",
      "  }",
      "} // namespace math",
      "",
      "#include <cassert>",
      "#include <numeric>",
      "",
      "namespace math {",
      "  // verify:AOJ_NTL_1_B",
      "  ll power(ll a, ll e, ll p = -1) {",
      "    assert(p != 0);",
      "    assert(p >= -1);",
      "",
      "    if (e < 0) {",
      "      assert(p != -1 and gcd(a, p) == 1);",
      "      ll x, y;",
      "      extgcd(a, p, x, y);",
      "      a = (x % p + p) % p;",
      "      e *= -1;",
      "    }",
      "",
      "    ll res = 1;",
      "    while (e > 0) {",
      "      if (e & 1) {",
      "        res *= a;",
      "        if (p != -1) res %= p;",
      "      }",
      "      a *= a;",
      "      if (p != -1) a %= p;",
      "      e >>= 1;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace math"
    ],
    "description": "Template of power",
    "scope": ""
  },
  "split.hpp": {
    "prefix": "cppsplit",
    "body": [
      "namespace library_string {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace library_string {",
      "  vector<string> split(const string &str, const string &sep, const int &max_split = INT32_MAX) {",
      "    vector<string> res;",
      "    string t = \"\";",
      "    int cnt_split = 0;",
      "    for (auto c: str) {",
      "      if (sep.find(c) == string::npos or cnt_split >= max_split) {",
      "        t += c;",
      "        continue;",
      "      }",
      "      res.emplace_back(t);",
      "      t = \"\";",
      "      cnt_split++;",
      "    }",
      "    if (t != \"\") res.emplace_back(t);",
      "    return res;",
      "  }",
      "} // namespace library_string"
    ],
    "description": "Template of split",
    "scope": ""
  },
  "join.hpp": {
    "prefix": "cppjoin",
    "body": [
      "namespace library_string {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace library_string {",
      "  string join(const vector<string> &strs, const string &sep) {",
      "    string res = \"\";",
      "    for (int i = 0; i < static_cast<int>(strs.size()); i++) {",
      "      if (i) res += sep;",
      "      res += strs[i];",
      "    }",
      "    return res;",
      "  }",
      "} // namespace library_string"
    ],
    "description": "Template of join",
    "scope": ""
  },
  "rolling-hash-2d.hpp": {
    "prefix": "cpprolling_hash_2d",
    "body": [
      "namespace library_string {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace library_string {",
      "  // verify:AOJ_ALDS1_14_C",
      "  // recomend:{ MOD:2^61-1, base1,base2:random }",
      "  struct RollingHash2D {",
      "    using i128 = __int128_t;",
      "    using ll = long long;",
      "    ll mod, base1, base2;",
      "    struct CumulativeSum2D {",
      "      vector<vector<ll>> data;",
      "      CumulativeSum2D() {}",
      "",
      "      void set(int y, int x, ll v) { data[y + 1][x + 1] = v; }",
      "",
      "      void build(ll mod) {",
      "        for (int i = 1; i < static_cast<int>(data.size()); i++) {",
      "          for (int j = 1; j < static_cast<int>(data[i].size()); j++) {",
      "            data[i][j] += (data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1]) % mod;",
      "            if (data[i][j] < 0) data[i][j] += mod;",
      "          }",
      "        }",
      "      }",
      "",
      "      // [ (sy,sx), (gy,gx) )",
      "      ll query(int sy, int sx, int gy, int gx, ll mod) {",
      "        ll res = (data[gy][gx] - data[gy][sx] - data[sy][gx] + data[sy][sx]) % mod;",
      "        if (res < 0) res += mod;",
      "        return res;",
      "      }",
      "    };",
      "",
      "    CumulativeSum2D sum;",
      "    vector<vector<ll>> dat, inv;",
      "    RollingHash2D(const vector<vector<ll>> &vs, ll B1 = (int)1e9 + 7, ll B2 = (int)1e8 + 7, ll MOD = (1LL << 61) - 1): dat(vs) {",
      "      set_base(B1, B2);",
      "      set_mod(MOD);",
      "    }",
      "    RollingHash2D(const vector<string> &s, ll B1 = (int)1e9 + 7, ll B2 = (int)1e8 + 7, ll MOD = (1LL << 61) - 1) {",
      "      set_base(B1, B2);",
      "      set_mod(MOD);",
      "      dat.resize(s.size());",
      "      for (int i = 0; i < static_cast<int>(s.size()); i++) {",
      "        for (char c: s[i]) {",
      "          dat[i].emplace_back(c);",
      "        }",
      "      }",
      "    }",
      "",
      "    void set_mod(ll M) { mod = M; }",
      "    void set_base(ll B1, ll B2) { base1 = B1, base2 = B2; }",
      "",
      "    // mod multiprecation",
      "    ll mod_mul(ll a, ll b) {",
      "      i128 res = a;",
      "      res *= b;",
      "      res = (res >> 61) + (res & mod);",
      "      if (res >= mod) res -= mod;",
      "      return (ll)res;",
      "    }",
      "",
      "    ll pow(ll a, i128 e) {",
      "      if (e == 0) return 1;",
      "      if (e % 2 == 0) {",
      "        ll res = pow(a, e / 2);",
      "        return mod_mul(res, res);",
      "      }",
      "      return mod_mul(pow(a, e - 1), a);",
      "    }",
      "",
      "    void build() {",
      "      int h = dat.size(), w = dat[0].size();",
      "      inv.assign(h + 1, vector<ll>(w + 1, 0));",
      "      sum.data.assign(h + 1, vector<ll>(w + 1, 0));",
      "      vector<ll> pow_table1(h + 1), pow_table2(w + 1);",
      "",
      "      i128 e = mod - 2;",
      "      inv[h][w] = mod_mul(pow(base1, h * e), pow(base2, w * e));",
      "      pow_table1[0] = 1;",
      "      pow_table2[0] = 1;",
      "",
      "      for (int i = h - 1; i >= 0; i--) {",
      "        pow_table1[h - i] = mod_mul(base1, pow_table1[h - i - 1]);",
      "        inv[i][w] = mod_mul(base1, inv[i + 1][w]);",
      "      }",
      "      for (int j = w - 1; j >= 0; j--) {",
      "        pow_table2[w - j] = mod_mul(base2, pow_table2[w - j - 1]);",
      "        inv[h][j] = mod_mul(base2, inv[h][j + 1]);",
      "      }",
      "      for (int i = h - 1; i >= 0; i--) {",
      "        for (int j = w - 1; j >= 0; j--) {",
      "          inv[i][j] = mod_mul(inv[i + 1][j + 1], base1);",
      "          inv[i][j] = mod_mul(inv[i][j], base2);",
      "        }",
      "      }",
      "      for (int i = 0; i < h; i++) {",
      "        for (int j = 0; j < w; j++) {",
      "          ll val = mod_mul(dat[i][j], pow_table1[i]);",
      "          val = mod_mul(val, pow_table2[j]);",
      "          sum.set(i, j, val);",
      "        }",
      "      }",
      "      sum.build(mod);",
      "    }",
      "",
      "    ll find(int sy, int sx, int gy, int gx) { return mod_mul(sum.query(sy, sx, gy, gx, mod), inv[sy][sx]); }",
      "  };",
      "} // namespace library_string"
    ],
    "description": "Template of rolling_hash_2d",
    "scope": ""
  },
  "rolling-hash.hpp": {
    "prefix": "cpprolling_hash",
    "body": [
      "namespace library_string {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace library_string {",
      "  // verify:AOJ_ALDS1_14_B",
      "  // recommend { MOD:2^61-1, base:random }",
      "  struct RollingHash {",
      "    using i128 = __int128_t;",
      "    using ll = long long;",
      "    ll base, mod;",
      "    vector<ll> dat, hash, cumulative_sum, inv;",
      "    RollingHash(vector<ll> vs, ll B = (int)1e9 + 7, ll MOD = (1LL << 61) - 1): dat(vs) {",
      "      set_base(B);",
      "      set_mod(MOD);",
      "    }",
      "    RollingHash(string &s, ll B = (int)1e9 + 7, ll MOD = (1LL << 61) - 1) {",
      "      for (char c: s) {",
      "        dat.emplace_back(c);",
      "      }",
      "      set_base(B);",
      "      set_mod(MOD);",
      "    }",
      "",
      "    void set_base(ll B) { base = B; }",
      "    void set_mod(ll MOD) { mod = MOD; }",
      "",
      "    // mod multiprecation",
      "    ll mod_mul(ll a, ll b) {",
      "      i128 res = a;",
      "      res *= b;",
      "      res = (res >> 61) + (res & mod);",
      "      if (res >= mod) res -= mod;",
      "      return (ll)res;",
      "    }",
      "",
      "    ll pow(ll a, i128 e) {",
      "      if (e == 0) return 1;",
      "      if (e % 2 == 0) {",
      "        ll res = pow(a, e / 2);",
      "        return mod_mul(res, res);",
      "      }",
      "      return mod_mul(pow(a, e - 1), a);",
      "    }",
      "",
      "    void build() {",
      "      int n = dat.size();",
      "      hash.assign(n, 0);",
      "      cumulative_sum.assign(n + 1, 0);",
      "      inv.assign(n + 1, 0);",
      "      vector<ll> pow_table(n + 1);",
      "",
      "      i128 e = mod - 2;",
      "      inv[n] = pow(base, n * e);",
      "      pow_table[0] = 1;",
      "",
      "      for (int i = n - 1; i >= 0; i--) {",
      "        pow_table[n - i] = mod_mul(pow_table[n - i - 1], base);",
      "        inv[i] = mod_mul(inv[i + 1], base);",
      "      }",
      "      for (int i = 0; i < n; i++) {",
      "        hash[i] = mod_mul(dat[i], pow_table[i]);",
      "      }",
      "      for (int i = 0; i < n; i++) {",
      "        cumulative_sum[i + 1] = (hash[i] + cumulative_sum[i]) % mod;",
      "      }",
      "    }",
      "",
      "    // [l,r)",
      "    long long find(int l, int r) {",
      "      ll res = cumulative_sum[r] - cumulative_sum[l];",
      "      if (res < 0) res += mod;",
      "      res = mod_mul(res, inv[l]);",
      "      return (long long)res;",
      "    }",
      "  };",
      "} // namespace library_string"
    ],
    "description": "Template of rolling_hash",
    "scope": ""
  },
  "substr.hpp": {
    "prefix": "cppsubstr",
    "body": [
      "namespace library_string {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "",
      "namespace library_string {",
      "  string substr(const string &s, int l, int r) {",
      "    string res = \"\";",
      "    for (int i = l; i < r; i++) {",
      "      res += s[i];",
      "    }",
      "    return res;",
      "  }",
      "} // namespace library_string"
    ],
    "description": "Template of substr",
    "scope": ""
  },
  "cppint.hpp": {
    "prefix": "cppcppint",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <boost/multiprecision/cpp_int.hpp>",
      "#include <cassert>",
      "#include <string>",
      "",
      "namespace tools {",
      "  namespace cpp_int_helper {",
      "    namespace mp = boost::multiprecision;",
      "",
      "    string to_string(mp::cpp_int a) {",
      "      string res = \"\";",
      "      if (a < 0) {",
      "        a *= -1;",
      "        res += \"-\";",
      "      }",
      "",
      "      while (a) {",
      "        res += static_cast<char>(a % 10 + '0');",
      "        a /= 10;",
      "      }",
      "      return res;",
      "    }",
      "",
      "    mp::cpp_int gcd(mp::cpp_int a, mp::cpp_int b) {",
      "      mp::cpp_int tmp;",
      "      while (b > 0) {",
      "        tmp = a;",
      "        a = b;",
      "        b = tmp % b;",
      "      }",
      "      return a;",
      "    }",
      "",
      "    mp::cpp_int lcm(mp::cpp_int a, mp::cpp_int b) { return a * b / gcd(a, b); }",
      "",
      "    namespace power_helper {",
      "",
      "      mp::cpp_int extgcd(mp::cpp_int a, mp::cpp_int b, mp::cpp_int &x, mp::cpp_int &y) {",
      "        if (b == 0) {",
      "          x = 1;",
      "          y = 0;",
      "          return a;",
      "        }",
      "        mp::cpp_int d = extgcd(b, a % b, y, x);",
      "        y = y - (a / b) * x;",
      "        return d;",
      "      }",
      "",
      "    } // namespace power_helper",
      "",
      "    mp::cpp_int power(mp::cpp_int a, mp::cpp_int e, mp::cpp_int p = -1) {",
      "      assert(p != 0);",
      "      assert(p >= -1);",
      "",
      "      if (e < 0) {",
      "        assert(p != -1 and gcd(a, p) == 1);",
      "        mp::cpp_int x, y;",
      "        power_helper::extgcd(a, p, x, y);",
      "        a = (x % p + p) % p;",
      "        e *= -1;",
      "      }",
      "",
      "      mp::cpp_int res = 1;",
      "      while (e > 0) {",
      "        if (e & 1) {",
      "          res *= a;",
      "          if (p != -1) res %= p;",
      "        }",
      "        a *= a;",
      "        if (p != -1) a %= p;",
      "        e >>= 1;",
      "      }",
      "      return res;",
      "    }",
      "",
      "  } // namespace cpp_int_helper",
      "  using namespace cpp_int_helper;",
      "  using cint = boost::multiprecision::cpp_int;",
      "} // namespace tools"
    ],
    "description": "Template of cppint",
    "scope": ""
  },
  "runlength.hpp": {
    "prefix": "cpprunlength",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace tools {",
      "  template <typename Iterator>",
      "  auto runlength(Iterator first, Iterator last) {",
      "    vector<pair<remove_reference_t<decltype(*first)>, int>> res;",
      "    for (auto it = first; it != last; it++) {",
      "      if (res.empty() or res.back().first != *it) res.emplace_back(*it, 0);",
      "      res.back().second++;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of runlength",
    "scope": ""
  },
  "debug.hpp": {
    "prefix": "cppdebug",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <iostream>",
      "#include <stack>",
      "#include <string>",
      "",
      "namespace tools {",
      "#define debug(...) debug_function(#__VA_ARGS__, __VA_ARGS__)",
      "",
      "  int find_comma_not_bracketed(string_view s) {",
      "    stack<char> bs;",
      "    string lbs = \"({[\", rbs = \")}]\";",
      "    for (size_t i = 0; i < s.size(); i++) {",
      "      if (lbs.find(s[i]) != string::npos) bs.push(s[i]);",
      "      if (rbs.find(s[i]) != string::npos and !bs.empty()) bs.pop();",
      "      if (s[i] == ',' and bs.empty()) return i;",
      "    }",
      "    return s.size();",
      "  }",
      "",
      "  template <typename T, typename... Ts>",
      "  void debug_function(string_view name, const T &a, Ts &&...rest) {",
      "    int end = find_comma_not_bracketed(name);",
      "    cerr << name.substr(0, end) << \":\" << a;",
      "    if constexpr (sizeof...(rest) == 0) {",
      "      cerr << '\\n';",
      "    } else {",
      "      cerr << ' ';",
      "      debug_function(name.substr(name.find_first_not_of(' ', end + 1)), forward<Ts>(rest)...);",
      "    }",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of debug",
    "scope": ""
  },
  "vector-to-string.hpp": {
    "prefix": "cppvector_to_string",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace tools {",
      "  template <typename T>",
      "  string vector_to_string(const vector<T> &vs, const string &sep = \" \") {",
      "    stringstream ss;",
      "    for (int i = 0; i < static_cast<int>(vs.size()); i++) {",
      "      if (i) ss << sep;",
      "      ss << vs[i];",
      "    }",
      "    return ss.str();",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of vector_to_string",
    "scope": ""
  },
  "i128.hpp": {
    "prefix": "cppi128",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <string>",
      "",
      "namespace tools {",
      "  namespace int128 {",
      "    __int128_t parse(const string &s) {",
      "      __int128_t res = 0;",
      "      for (char c: s) {",
      "        if (isdigit(c)) res = res * 10 + (c - '0');",
      "      }",
      "      if (s[0] == '-') res *= -1;",
      "      return res;",
      "    }",
      "",
      "    istream &operator>>(istream &is, __int128_t &v) {",
      "      string s;",
      "      is >> s;",
      "      v = parse(s);",
      "      return is;",
      "    }",
      "",
      "    ostream &operator<<(ostream &os, const __int128_t &v) {",
      "      if (!ostream::sentry(os)) return os;",
      "      char buf[64];",
      "      char *d = end(buf);",
      "      __uint128_t tmp = (v < 0 ? -v : v);",
      "",
      "      do {",
      "        d--;",
      "        *d = char(tmp % 10 + '0');",
      "        tmp /= 10;",
      "      } while (tmp);",
      "      if (v < 0) {",
      "        d--;",
      "        *d = '-';",
      "      }",
      "      int len = end(buf) - d;",
      "      if (os.rdbuf()->sputn(d, len) != len) { os.setstate(ios_base::badbit); }",
      "      return os;",
      "    }",
      "",
      "    __int128_t gcd(__int128_t a, __int128_t b) {",
      "      __int128_t tmp;",
      "      while (b > 0) {",
      "        tmp = a;",
      "        a = b;",
      "        b = tmp % b;",
      "      }",
      "      return a;",
      "    }",
      "",
      "    __int128_t lcm(__int128_t a, __int128_t b) { return a * b / gcd(a, b); }",
      "",
      "",
      "    namespace template_internal_math {",
      "",
      "      __int128_t extgcd(__int128_t a, __int128_t b, __int128_t &x, __int128_t &y) {",
      "        if (b == 0) {",
      "          x = 1;",
      "          y = 0;",
      "          return a;",
      "        }",
      "        __int128_t d = extgcd(b, a % b, y, x);",
      "        y = y - (a / b) * x;",
      "        return d;",
      "      }",
      "",
      "    } // namespace template_internal_math",
      "",
      "    __int128_t power(__int128_t a, __int128_t e, __int128_t p = -1) {",
      "      assert(p != 0);",
      "      assert(p >= -1);",
      "",
      "      if (e < 0) {",
      "        assert(p != -1 and gcd(a, p) == 1);",
      "        __int128_t x, y;",
      "        template_internal_math::extgcd(a, p, x, y);",
      "        a = (x % p + p) % p;",
      "        e *= -1;",
      "      }",
      "",
      "      __int128_t res = 1;",
      "      while (e > 0) {",
      "        if (e & 1) {",
      "          res *= a;",
      "          if (p != -1) res %= p;",
      "        }",
      "        a *= a;",
      "        if (p != -1) a %= p;",
      "        e >>= 1;",
      "      }",
      "      return res;",
      "    }",
      "  } // namespace int128",
      "  using namespace int128;",
      "  using i128 = __int128_t;",
      "} // namespace tools"
    ],
    "description": "Template of i128",
    "scope": ""
  },
  "function-measure.hpp": {
    "prefix": "cppfunction_measure",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <chrono>",
      "#include <functional>",
      "#include <iomanip>",
      "#include <ios>",
      "#include <iostream>",
      "",
      "namespace tools {",
      "  struct FunctionMeasure {",
      "    chrono::system_clock::time_point start, end;",
      "",
      "    template <auto f, typename... Args>",
      "    void measure(Args... args) {",
      "      start = chrono::system_clock::now();",
      "",
      "      f(args...);",
      "",
      "      end = chrono::system_clock::now();",
      "    }",
      "",
      "    // bias:1000 -> [ms]",
      "    double time(double bias = 1000.0) { return static_cast<double>(chrono::duration_cast<chrono::microseconds>(end - start).count() / bias); }",
      "",
      "    void print(double bias = 1000.0) {",
      "      cout << fixed << setprecision(10);",
      "      cout << time(bias) << \"\\n\";",
      "    }",
      "  };",
      "} // namespace tools"
    ],
    "description": "Template of function_measure",
    "scope": ""
  },
  "to-array.hpp": {
    "prefix": "cppto_array",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <array>",
      "#include <vector>",
      "",
      "namespace tools {",
      "  template <typename T, size_t length>",
      "  array<T, length> to_array(const vector<T> &vs) {",
      "    array<T, length> res;",
      "    for (int i = 0; i < (int)length; i++) {",
      "      res[i] = vs[i];",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of to_array",
    "scope": ""
  },
  "has-find.hpp": {
    "prefix": "cpphas_find",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "",
      "namespace tools {",
      "  template <typename T>",
      "  class HasIterator {",
      "    template <typename Container>",
      "    static true_type check(typename Container::iterator *);",
      "",
      "    template <typename Container>",
      "    static false_type check(...);",
      "",
      "  public:",
      "    static const bool value = decltype(check<T>(0))::value;",
      "  };",
      "",
      "  template <typename T>",
      "  using has_iterator_t = enable_if_t<HasIterator<T>::value, typename T::iterator>;",
      "} // namespace tools",
      "",
      "#include <cstddef>",
      "",
      "namespace tools {",
      "  template <typename Container, typename T>",
      "  class HasFind {",
      "    static false_type check(...);",
      "",
      "    template <typename C, enable_if_t<(static_cast<has_iterator_t<C> (C::*)(const T &)>(&C::find), true), nullptr_t> = nullptr>",
      "    static true_type check(C *);",
      "",
      "    static Container *container;",
      "",
      "  public:",
      "    static constexpr bool value = decltype(check(container))::value;",
      "  };",
      "",
      "  template <typename Container, typename T>",
      "  static constexpr bool has_find_v = HasFind<Container, T>::value;",
      "} // namespace tools"
    ],
    "description": "Template of has_find",
    "scope": ""
  },
  "reversed.hpp": {
    "prefix": "cppreversed",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "",
      "#include <array>",
      "#include <deque>",
      "#include <forward_list>",
      "#include <list>",
      "#include <map>",
      "#include <queue>",
      "#include <set>",
      "#include <stack>",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "#include <vector>",
      "",
      "",
      "namespace tools {",
      "",
      "  namespace traits_helper {",
      "    template <template <typename...> typename Container, typename Type>",
      "    struct IsTemplate: false_type {};",
      "",
      "    template <template <typename...> typename Container, typename... Args>",
      "    struct IsTemplate<Container, Container<Args...>>: true_type {};",
      "  } // namespace traits_helper",
      "",
      "  // Sequence containers",
      "  template <typename T>",
      "  struct IsArray: false_type {};",
      "",
      "  template <typename T, size_t Size>",
      "  struct IsArray<array<T, Size>>: true_type {};",
      "",
      "  template <typename... Args>",
      "  inline constexpr bool is_array_v = IsArray<Args...>::value;",
      "",
      "  template <typename T>",
      "  using IsVector = traits_helper::IsTemplate<vector, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_vector_v = IsVector<T>::value;",
      "",
      "  template <typename T>",
      "  using IsDeque = traits_helper::IsTemplate<deque, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_deque_v = IsDeque<T>::value;",
      "",
      "  template <typename T>",
      "  using IsForwardList = traits_helper::IsTemplate<forward_list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_forward_list_v = IsForwardList<T>::value;",
      "",
      "  template <typename T>",
      "  using IsList = traits_helper::IsTemplate<list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_list_v = IsList<T>::value;",
      "",
      "  // Associative containers",
      "  template <typename T>",
      "  using IsSet = traits_helper::IsTemplate<set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_set_v = IsSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMap = traits_helper::IsTemplate<map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_map_v = IsMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultiset = traits_helper::IsTemplate<multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multiset_v = IsMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultimap = traits_helper::IsTemplate<multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multimap_v = IsMultimap<T>::value;",
      "",
      "  // Unordered associative containers",
      "  template <typename T>",
      "  using IsUnorderedSet = traits_helper::IsTemplate<unordered_set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_set_v = IsUnorderedSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMap = traits_helper::IsTemplate<unordered_map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_map_v = IsUnorderedMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultiset = traits_helper::IsTemplate<unordered_multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multiset_v = IsUnorderedMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultimap = traits_helper::IsTemplate<unordered_multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multimap_v = IsUnorderedMultimap<T>::value;",
      "",
      "  // Container adaptors",
      "  template <typename T>",
      "  using IsQueue = traits_helper::IsTemplate<queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_queue_v = IsQueue<T>::value;",
      "",
      "  template <typename T>",
      "  using IsStack = traits_helper::IsTemplate<stack, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_stack_v = IsStack<T>::value;",
      "",
      "  template <typename T>",
      "  using IsPriorityQueue = traits_helper::IsTemplate<priority_queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_priority_queue_v = IsPriorityQueue<T>::value;",
      "",
      "  // Container types",
      "  template <typename T>",
      "  using IsSequenceContainer = disjunction<IsArray<T>, IsVector<T>, IsDeque<T>, IsForwardList<T>, IsList<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_sequence_container_v = IsSequenceContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsAssociativeContainer = disjunction<IsSet<T>, IsMap<T>, IsMultiset<T>, IsMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_associative_container_v = IsAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedAssociativeContainer = disjunction<IsUnorderedSet<T>, IsUnorderedMap<T>, IsUnorderedMultiset<T>, IsUnorderedMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_associative_container_v = IsUnorderedAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainerAdaptor = disjunction<IsQueue<T>, IsStack<T>, IsPriorityQueue<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_adaptor_v = IsContainerAdaptor<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainer = disjunction<IsSequenceContainer<T>, IsAssociativeContainer<T>, IsUnorderedAssociativeContainer<T>, IsContainerAdaptor<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_v = IsContainer<T>::value;",
      "",
      "} // namespace tools",
      "",
      "#include <algorithm>",
      "#include <type_traits>",
      "",
      "namespace tools {",
      "  // array or vector or deque or string",
      "  template <typename Container>",
      "  constexpr Container reversed(const Container &c) {",
      "    Container res = c;",
      "    reverse(res.begin(), res.end());",
      "    return res;",
      "  }",
      "",
      "  // list or forward_list",
      "  template <template <typename T> typename Container, typename T, enable_if_t<(is_forward_list_v<Container<T>> or is_list_v<Container<T>>)> * = nullptr>",
      "  constexpr auto reversed(const Container<T> &ls) {",
      "    Container<T> res = ls;",
      "    res.reverse();",
      "    return res;",
      "  }",
      "",
      "  // set or multiset",
      "  template <template <typename T, typename Compare> typename Container, typename T, typename Compare, enable_if_t<(is_set_v<Container<T, Compare>> or is_multiset_v<Container<T, Compare>>)> * = nullptr>",
      "  constexpr auto reversed(const Container<T, Compare> &st) {",
      "    if constexpr (is_same_v<Compare, less<T>>) {",
      "      Container<T, greater<T>> res;",
      "      for (const auto &v: st) {",
      "        res.emplace_hint(res.begin(), v);",
      "      }",
      "      return res;",
      "    } else {",
      "      Container<T, less<T>> res;",
      "      for (const auto &v: st) {",
      "        res.emplace_hint(res.begin(), v);",
      "      }",
      "      return res;",
      "    }",
      "  }",
      "",
      "  // map or multimap",
      "  template <template <typename T1, typename T2, typename Compare> typename Container,",
      "            typename T1,",
      "            typename T2,",
      "            typename Compare,",
      "            enable_if_t<(is_map_v<Container<T1, T2, Compare>> or is_multimap_v<Container<T1, T2, Compare>>)> * = nullptr>",
      "  constexpr auto reversed(const Container<T1, T2, Compare> &mp) {",
      "    if constexpr (is_same_v<Compare, less<T1>>) {",
      "      Container<T1, T2, greater<T1>> res;",
      "      for (const auto &p: mp) {",
      "        res.emplace_hint(res.begin(), p);",
      "      }",
      "      return res;",
      "    } else {",
      "      Container<T1, T2, less<T1>> res;",
      "      for (const auto &p: mp) {",
      "        res.emplace_hint(res.begin(), p);",
      "      }",
      "      return res;",
      "    }",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of reversed",
    "scope": ""
  },
  "inversion.hpp": {
    "prefix": "cppinversion",
    "body": [
      "namespace data_structure {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace data_structure {",
      "  // verify:ARC033_C",
      "  template <typename T>",
      "  class FenwickTree {",
      "  private:",
      "    int n;",
      "    vector<T> dat;",
      "",
      "    // [1,r]",
      "    T sum(int r) {",
      "      T res = 0;",
      "      for (int k = r; k > 0; k -= (k & -k)) {",
      "        res += dat[k];",
      "      }",
      "      return res;",
      "    }",
      "",
      "  public:",
      "    FenwickTree(int n_): n(n_ + 2), dat(n_ + 2, 0) {}",
      "",
      "    // i:0-indexed",
      "    void add(int i, T x) {",
      "      for (int k = ++i; k < n; k += (k & -k)) {",
      "        dat[k] += x;",
      "      }",
      "    }",
      "",
      "    T get(int k) { return dat[++k]; }",
      "",
      "    // [l,r)",
      "    T sum(int l, int r) { return sum(r) - sum(l); }",
      "",
      "    // min({x | sum(x) >= w})",
      "    int lower_bound(T w) {",
      "      if (w <= 0) return 0;",
      "      int x = 0, twopow = 1;",
      "      while (twopow < n) {",
      "        twopow <<= 1;",
      "      }",
      "      for (int sz = twopow; sz > 0; sz >>= 1) {",
      "        if (x + sz < n and dat[x + sz] < w) {",
      "          w -= dat[x + sz];",
      "          x += sz;",
      "        }",
      "      }",
      "      return x;",
      "    }",
      "",
      "    // min({x | sum(x) > w})",
      "    int upper_bound(T w) { return lower_bound(w + 1); }",
      "  };",
      "} // namespace data_structure",
      "",
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "",
      "namespace tools {",
      "  // verify:AOJ_ALDS1_5_D",
      "  template <typename T>",
      "  long long inversion(vector<T> vs) {",
      "    auto uni = vs;",
      "    sort(uni.begin(), uni.end());",
      "    uni.erase(unique(uni.begin(), uni.end()), uni.end());",
      "    for (T &v: vs) {",
      "      v = lower_bound(uni.begin(), uni.end(), v) - uni.begin();",
      "    }",
      "",
      "    int n = vs.size();",
      "    data_structure::FenwickTree<long long> ft(n + 1);",
      "    long long res = 0;",
      "    for (T v: vs) {",
      "      res += ft.sum(v + 1, n);",
      "      ft.add(v, 1);",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of inversion",
    "scope": ""
  },
  "stopwatch.hpp": {
    "prefix": "cppstopwatch",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <chrono>",
      "",
      "namespace tools {",
      "  struct Stopwatch {",
      "    chrono::high_resolution_clock::time_point start;",
      "",
      "    Stopwatch() { restart(); }",
      "",
      "    void restart() { start = chrono::high_resolution_clock::now(); }",
      "",
      "    chrono::milliseconds::rep elapsed() {",
      "      auto end = chrono::high_resolution_clock::now();",
      "      return chrono::duration_cast<chrono::milliseconds>(end - start).count();",
      "    }",
      "  };",
      "} // namespace tools"
    ],
    "description": "Template of stopwatch",
    "scope": ""
  },
  "container-traits.hpp": {
    "prefix": "cppcontainer_traits",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <array>",
      "#include <deque>",
      "#include <forward_list>",
      "#include <list>",
      "#include <map>",
      "#include <queue>",
      "#include <set>",
      "#include <stack>",
      "#include <unordered_map>",
      "#include <unordered_set>",
      "#include <vector>",
      "",
      "",
      "namespace tools {",
      "",
      "  namespace traits_helper {",
      "    template <template <typename...> typename Container, typename Type>",
      "    struct IsTemplate: false_type {};",
      "",
      "    template <template <typename...> typename Container, typename... Args>",
      "    struct IsTemplate<Container, Container<Args...>>: true_type {};",
      "  } // namespace traits_helper",
      "",
      "  // Sequence containers",
      "  template <typename T>",
      "  struct IsArray: false_type {};",
      "",
      "  template <typename T, size_t Size>",
      "  struct IsArray<array<T, Size>>: true_type {};",
      "",
      "  template <typename... Args>",
      "  inline constexpr bool is_array_v = IsArray<Args...>::value;",
      "",
      "  template <typename T>",
      "  using IsVector = traits_helper::IsTemplate<vector, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_vector_v = IsVector<T>::value;",
      "",
      "  template <typename T>",
      "  using IsDeque = traits_helper::IsTemplate<deque, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_deque_v = IsDeque<T>::value;",
      "",
      "  template <typename T>",
      "  using IsForwardList = traits_helper::IsTemplate<forward_list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_forward_list_v = IsForwardList<T>::value;",
      "",
      "  template <typename T>",
      "  using IsList = traits_helper::IsTemplate<list, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_list_v = IsList<T>::value;",
      "",
      "  // Associative containers",
      "  template <typename T>",
      "  using IsSet = traits_helper::IsTemplate<set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_set_v = IsSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMap = traits_helper::IsTemplate<map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_map_v = IsMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultiset = traits_helper::IsTemplate<multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multiset_v = IsMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsMultimap = traits_helper::IsTemplate<multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_multimap_v = IsMultimap<T>::value;",
      "",
      "  // Unordered associative containers",
      "  template <typename T>",
      "  using IsUnorderedSet = traits_helper::IsTemplate<unordered_set, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_set_v = IsUnorderedSet<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMap = traits_helper::IsTemplate<unordered_map, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_map_v = IsUnorderedMap<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultiset = traits_helper::IsTemplate<unordered_multiset, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multiset_v = IsUnorderedMultiset<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedMultimap = traits_helper::IsTemplate<unordered_multimap, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_multimap_v = IsUnorderedMultimap<T>::value;",
      "",
      "  // Container adaptors",
      "  template <typename T>",
      "  using IsQueue = traits_helper::IsTemplate<queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_queue_v = IsQueue<T>::value;",
      "",
      "  template <typename T>",
      "  using IsStack = traits_helper::IsTemplate<stack, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_stack_v = IsStack<T>::value;",
      "",
      "  template <typename T>",
      "  using IsPriorityQueue = traits_helper::IsTemplate<priority_queue, T>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_priority_queue_v = IsPriorityQueue<T>::value;",
      "",
      "  // Container types",
      "  template <typename T>",
      "  using IsSequenceContainer = disjunction<IsArray<T>, IsVector<T>, IsDeque<T>, IsForwardList<T>, IsList<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_sequence_container_v = IsSequenceContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsAssociativeContainer = disjunction<IsSet<T>, IsMap<T>, IsMultiset<T>, IsMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_associative_container_v = IsAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsUnorderedAssociativeContainer = disjunction<IsUnorderedSet<T>, IsUnorderedMap<T>, IsUnorderedMultiset<T>, IsUnorderedMultimap<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_unordered_associative_container_v = IsUnorderedAssociativeContainer<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainerAdaptor = disjunction<IsQueue<T>, IsStack<T>, IsPriorityQueue<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_adaptor_v = IsContainerAdaptor<T>::value;",
      "",
      "  template <typename T>",
      "  using IsContainer = disjunction<IsSequenceContainer<T>, IsAssociativeContainer<T>, IsUnorderedAssociativeContainer<T>, IsContainerAdaptor<T>>;",
      "",
      "  template <typename T>",
      "  inline constexpr bool is_container_v = IsContainer<T>::value;",
      "",
      "} // namespace tools"
    ],
    "description": "Template of container_traits",
    "scope": ""
  },
  "has-iterator.hpp": {
    "prefix": "cpphas_iterator",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "",
      "namespace tools {",
      "  template <typename T>",
      "  class HasIterator {",
      "    template <typename Container>",
      "    static true_type check(typename Container::iterator *);",
      "",
      "    template <typename Container>",
      "    static false_type check(...);",
      "",
      "  public:",
      "    static const bool value = decltype(check<T>(0))::value;",
      "  };",
      "",
      "  template <typename T>",
      "  using has_iterator_t = enable_if_t<HasIterator<T>::value, typename T::iterator>;",
      "} // namespace tools"
    ],
    "description": "Template of has_iterator",
    "scope": ""
  },
  "rotate-2d.hpp": {
    "prefix": "cpprotate_2d",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <vector>",
      "",
      "namespace tools {",
      "  template <typename ArrayType>",
      "  vector<ArrayType> rotate_cw(const vector<ArrayType> &s) {",
      "    int h = s.size(), w = s[0].size();",
      "    vector<ArrayType> res(w);",
      "    for (int i = 0; i < w; i++) {",
      "      for (int j = 0; j < h; j++) {",
      "        res[i].push_back(s[h - 1 - j][i]);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "",
      "  template <typename ArrayType>",
      "  vector<ArrayType> rotate_ccw(const vector<ArrayType> &s) {",
      "    int h = s.size(), w = s[0].size();",
      "    vector<ArrayType> res(w);",
      "    for (int i = 0; i < w; i++) {",
      "      for (int j = 0; j < h; j++) {",
      "        res[i].push_back(s[j][w - 1 - i]);",
      "      }",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of rotate_2d",
    "scope": ""
  },
  "sorted-index.hpp": {
    "prefix": "cppsorted_index",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <numeric>",
      "#include <vector>",
      "",
      "namespace tools {",
      "  template <typename Iterator>",
      "  vector<int> sorted_index(Iterator first, Iterator last) {",
      "    using T = remove_reference_t<decltype(*first)>;",
      "    vector<T> a(first, last);",
      "    vector<int> res(a.size());",
      "    iota(res.begin(), res.end(), 0);",
      "    stable_sort(res.begin(), res.end(), [&](int i, int j) {",
      "      return a[i] < a[j];",
      "    });",
      "    return res;",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of sorted_index",
    "scope": ""
  },
  "sliced.hpp": {
    "prefix": "cppsliced",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <cstdint>",
      "#include <string>",
      "#include <vector>",
      "",
      "namespace tools {",
      "  struct Sliced {",
      "    static constexpr int init = INT32_MAX;",
      "    Sliced() {}",
      "",
      "    template <typename T>",
      "    vector<T> operator()(const vector<T> &v, int l, int r = init, int stride = init) {",
      "      assert(stride != 0);",
      "      if (r == init) r = v.size();",
      "      if (stride == init) stride = 1;",
      "      vector<T> res;",
      "      int start = (stride > 0 ? l : r - 1);",
      "      for (int i = start; (stride > 0 ? i < r : i >= l); i += stride) {",
      "        if (i >= 0) {",
      "          res.emplace_back(v[i]);",
      "        } else {",
      "          res.emplace_back(v.end()[i]);",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "",
      "    string operator()(const string &s, int l, int r = init, int stride = init) {",
      "      assert(stride != 0);",
      "      if (r == init) r = s.size();",
      "      if (stride == init) stride = 1;",
      "      string res;",
      "      int start = (stride > 0 ? l : r - 1);",
      "      for (int i = start; (stride > 0 ? i < r : i >= l); i += stride) {",
      "        if (i >= 0) {",
      "          res.push_back(s[i]);",
      "        } else {",
      "          res.push_back(s.end()[i]);",
      "        }",
      "      }",
      "      return res;",
      "    }",
      "  };",
      "} // namespace tools"
    ],
    "description": "Template of sliced",
    "scope": ""
  },
  "mod-int.hpp": {
    "prefix": "cppmod_int",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <cassert>",
      "#include <iostream>",
      "#include <utility>",
      "",
      "namespace tools {",
      "  template <int m>",
      "  class ModInt {",
      "    unsigned int v;",
      "",
      "    static constexpr unsigned int umod() { return m; }",
      "",
      "    void static_assertions() const { static_assert(1 <= m); }",
      "",
      "    long long extgcd(long long a, long long b, long long &x, long long &y) {",
      "      if (b == 0) {",
      "        x = 1;",
      "        y = 0;",
      "        return a;",
      "      }",
      "      long long d = extgcd(b, a % b, y, x);",
      "      y -= a / b * x;",
      "      return d;",
      "    }",
      "",
      "    // pair(g, x), g = gcd(v, umod()), vx = g (mod umod())",
      "    pair<long long, long long> gcd_inv() const {",
      "      long long x, y;",
      "      long long d = extgcd(v, umod(), x, y);",
      "      return pair(d, x);",
      "    }",
      "",
      "  public:",
      "    ModInt(): v(0) { static_assertions(); }",
      "    ModInt(long long x) {",
      "      static_assertions();",
      "      v = x % umod();",
      "    }",
      "",
      "    unsigned int val() const { return v; }",
      "",
      "    ModInt &operator++() {",
      "      v++;",
      "      if (v == umod()) v = 0;",
      "      return *this;",
      "    }",
      "",
      "    ModInt &operator--() {",
      "      if (v == 0) v = umod();",
      "      v--;",
      "      return *this;",
      "    }",
      "",
      "    ModInt operator++([[maybe_unused]] int unused) {",
      "      ModInt old = *this;",
      "      ++*this;",
      "      return old;",
      "    }",
      "",
      "    ModInt operator--([[maybe_unused]] int unused) {",
      "      ModInt old = *this;",
      "      --*this;",
      "      return old;",
      "    }",
      "",
      "    ModInt &operator+=(const ModInt &rhs) {",
      "      v += rhs.v;",
      "      if (v >= umod()) v -= umod();",
      "      return *this;",
      "    }",
      "",
      "    ModInt &operator-=(const ModInt &rhs) {",
      "      v -= rhs.v;",
      "      if (v >= umod()) v += umod();",
      "      return *this;",
      "    }",
      "",
      "    ModInt &operator*=(const ModInt &rhs) {",
      "      unsigned long long z = v;",
      "      z *= rhs.v;",
      "      v = z % umod();",
      "      return *this;",
      "    }",
      "",
      "    ModInt operator/=(const ModInt &rhs) { return *this = *this * rhs.inv(); }",
      "",
      "    ModInt operator+() const { return *this; }",
      "    ModInt operator-() const { return ModInt() - *this; }",
      "",
      "    ModInt pow(long long n) const {",
      "      assert(0 <= n);",
      "      ModInt x = *this, res = 1;",
      "      while (n) {",
      "        if (n & 1) res *= x;",
      "        x *= x;",
      "        n >>= 1;",
      "      }",
      "      return res;",
      "    }",
      "",
      "    ModInt inv() const {",
      "      const auto &[g, x] = gcd_inv();",
      "      assert(g == 1);",
      "      return x;",
      "    }",
      "",
      "    friend ModInt operator+(const ModInt &lhs, const ModInt &rhs) { return ModInt(lhs) += rhs; }",
      "",
      "    friend ModInt operator-(const ModInt &lhs, const ModInt &rhs) { return ModInt(lhs) -= rhs; }",
      "",
      "    friend ModInt operator*(const ModInt &lhs, const ModInt &rhs) { return ModInt(lhs) *= rhs; }",
      "",
      "    friend ModInt operator/(const ModInt &lhs, const ModInt &rhs) { return ModInt(lhs) /= rhs; }",
      "",
      "    friend bool operator==(const ModInt &lhs, const ModInt &rhs) { return lhs.v == rhs.v; }",
      "",
      "    friend bool operator!=(const ModInt &lhs, const ModInt &rhs) { return lhs.v != rhs.v; }",
      "",
      "    friend istream &operator>>(istream &is, ModInt &rhs) {",
      "      long long temp;",
      "      cin >> temp;",
      "      rhs = ModInt(temp);",
      "      return is;",
      "    }",
      "",
      "    friend ostream &operator<<(ostream &os, const ModInt &rhs) {",
      "      os << rhs.val();",
      "      return os;",
      "    }",
      "  };",
      "} // namespace tools"
    ],
    "description": "Template of mod_int",
    "scope": ""
  },
  "compress.hpp": {
    "prefix": "cppcompress",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <algorithm>",
      "#include <vector>",
      "",
      "namespace tools {",
      "  // verify:ABC036_C",
      "  template <typename T>",
      "  struct Compress {",
      "    vector<T> xs;",
      "    Compress() {}",
      "    Compress(int N): xs(N, 0) {}",
      "    Compress(const vector<T> &vs): xs(vs) {}",
      "",
      "    void set(int i, T x) { xs[i] = x; }",
      "",
      "    void set(const vector<T> &vs) {",
      "      for (int i = 0; i < min<int>(xs.size(), vs.size()); i++) {",
      "        xs[i] = vs[i];",
      "      }",
      "    }",
      "",
      "    void add(T x) { xs.emplace_back(x); }",
      "",
      "    void add(const vector<T> &vs) {",
      "      for (const T &x: vs) {",
      "        xs.emplace_back(x);",
      "      }",
      "    }",
      "",
      "    Compress<T> build() {",
      "      sort(xs.begin(), xs.end());",
      "      xs.erase(unique(xs.begin(), xs.end()), xs.end());",
      "      return *this;",
      "    }",
      "",
      "    vector<T> get(const vector<T> &vs) const {",
      "      vector<T> res = vs;",
      "      for (T &x: res) {",
      "        x = lower_bound(xs.begin(), xs.end(), x) - xs.begin();",
      "      }",
      "      return res;",
      "    }",
      "",
      "    int get(T k) const { return lower_bound(xs.begin(), xs.end(), k) - xs.begin(); }",
      "",
      "    const T &operator[](int k) const { return xs[k]; }",
      "  };",
      "} // namespace tools"
    ],
    "description": "Template of compress",
    "scope": ""
  },
  "contains.hpp": {
    "prefix": "cppcontains",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <type_traits>",
      "",
      "namespace tools {",
      "  template <typename T>",
      "  class HasIterator {",
      "    template <typename Container>",
      "    static true_type check(typename Container::iterator *);",
      "",
      "    template <typename Container>",
      "    static false_type check(...);",
      "",
      "  public:",
      "    static const bool value = decltype(check<T>(0))::value;",
      "  };",
      "",
      "  template <typename T>",
      "  using has_iterator_t = enable_if_t<HasIterator<T>::value, typename T::iterator>;",
      "} // namespace tools",
      "",
      "#include <cstddef>",
      "",
      "namespace tools {",
      "  template <typename Container, typename T>",
      "  class HasFind {",
      "    static false_type check(...);",
      "",
      "    template <typename C, enable_if_t<(static_cast<has_iterator_t<C> (C::*)(const T &)>(&C::find), true), nullptr_t> = nullptr>",
      "    static true_type check(C *);",
      "",
      "    static Container *container;",
      "",
      "  public:",
      "    static constexpr bool value = decltype(check(container))::value;",
      "  };",
      "",
      "  template <typename Container, typename T>",
      "  static constexpr bool has_find_v = HasFind<Container, T>::value;",
      "} // namespace tools",
      "",
      "#include <algorithm>",
      "#include <iterator>",
      "",
      "namespace tools {",
      "  template <typename Container, typename T>",
      "  bool contains(const Container &container, const T &x) {",
      "    if constexpr (has_find_v<Container, T>) {",
      "      return container.find(x) != end(container);",
      "    } else {",
      "      return find(begin(container), end(container), x) != end(container);",
      "    }",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of contains",
    "scope": ""
  },
  "fix-point.hpp": {
    "prefix": "cppfix_point",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <utility>",
      "",
      "namespace tools {",
      "  template <typename F>",
      "  struct FixPoint: F {",
      "    FixPoint(F &&f) noexcept: F{ forward<F>(f) } {}",
      "",
      "    template <typename... Args>",
      "    decltype(auto) operator()(Args &&...args) const {",
      "      return F::operator()(*this, forward<Args>(args)...);",
      "    }",
      "  };",
      "",
      "  template <typename F>",
      "  inline decltype(auto) make_fix_point(F &&f) {",
      "    return FixPoint<F>{ forward<F>(f) };",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of fix_point",
    "scope": ""
  },
  "range.hpp": {
    "prefix": "cpprange",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <iterator>",
      "#include <type_traits>",
      "#include <vector>",
      "",
      "namespace tools {",
      "  // begin,endを持つ構造体",
      "  template <typename Iterator>",
      "  class Range {",
      "    const Iterator begin_;",
      "    const Iterator end_;",
      "",
      "  public:",
      "    Range(Iterator &&b, Iterator &&e) noexcept: begin_(forward<Iterator>(b)), end_(forward<Iterator>(e)) {}",
      "",
      "    Iterator begin() const noexcept { return begin_; }",
      "",
      "    Iterator end() const noexcept { return end_; }",
      "  }; // class Range",
      "",
      "  template <typename Iterator>",
      "  Range<Iterator> make_range(Iterator &&begin, Iterator &&end) noexcept {",
      "    return Range<Iterator>{ forward<Iterator>(begin), forward<Iterator>(end) };",
      "  }",
      "",
      "  // initiaizer_list用",
      "  template <typename T>",
      "  decltype(auto) make_reversed_range(const initializer_list<T> &init_list) noexcept {",
      "    return make_range(rbegin(init_list), rend(init_list));",
      "  }",
      "",
      "  // rbegin,rendを持っている方",
      "  template <typename T>",
      "  decltype(auto) make_reversed_range(T &&container) noexcept {",
      "    return make_range(rbegin(container), rend(container));",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of range",
    "scope": ""
  },
  "counter.hpp": {
    "prefix": "cppcounter",
    "body": [
      "namespace tools {",
      "  using namespace std;",
      "}",
      "",
      "#include <map>",
      "",
      "namespace tools {",
      "  template <typename Iterator>",
      "  auto counter(Iterator first, Iterator last) {",
      "    using T = remove_reference_t<decltype(*first)>;",
      "    map<T, int> res;",
      "    for (auto it = first; it != last; it++) {",
      "      T value = *it;",
      "      res[value]++;",
      "    }",
      "    return res;",
      "  }",
      "} // namespace tools"
    ],
    "description": "Template of counter",
    "scope": ""
  }
}